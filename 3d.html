<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Modeler Pro - BowesProduct</title>
  <script async src="https://unpkg.com/es-module-shims@1.8.2/dist/es-module-shims.js"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
    }
  }
  </script>
  <style>
    *, *::before, *::after { box-sizing: border-box; }
    html, body { margin: 0; height: 100%; background: #020617; color: white; font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif; overflow: hidden; -webkit-font-smoothing: antialiased; }
    .site-header {
      position: sticky; top: 0; z-index: 1000; background: rgba(2,6,23,0.95); border-bottom: 1px solid #1e293b; backdrop-filter: blur(10px);
    }
    .header-inner { max-width: 1200px; margin: 0 auto; padding: 0.6rem 1rem; display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 0.5rem; }
    .header-left { display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; }
    .logo a { font-size: 1.3rem; font-weight: 700; color: white; text-decoration: none; white-space: nowrap; }
    .main-nav { display: flex; gap: 1rem; flex-wrap: wrap; }
    .main-nav a { color: #e5e7eb; text-decoration: none; font-size: 0.9rem; white-space: nowrap; }
    .main-nav a:hover, .main-nav a.active { color: #60a5fa; }
    .header-right { display: flex; align-items: center; gap: 0.8rem; min-height: 44px; flex-wrap: wrap; }
    #profilePic { width: 32px; height: 32px; border-radius: 50%; border: 2px solid #60a5fa; object-fit: cover; display: none; }
    .login-btn { padding: 0.45rem 1.1rem; border-radius: 999px; border: 1.5px solid #60a5fa; background: transparent; color: #60a5fa; font-size: 0.95rem; cursor: pointer; }
    #levelInfo { display: none; font-size: 0.8rem; color: #cbd5e1; }
    #levelText { white-space: nowrap; font-size: 0.75rem; }
    #xpOuter { width: 100px; height: 5px; background: #1e293b; border-radius: 3px; margin-top: 4px; }
    #xpBar { height: 100%; width: 0%; background: #60a5fa; border-radius: 3px; transition: width 0.35s ease; }
    @media (max-width: 900px) {
      .header-inner { padding: 0.5rem; }
      .header-left { width: 100%; justify-content: space-between; }
      .main-nav { gap: 0.8rem; order: 3; width: 100%; }
      .main-nav a { font-size: 0.85rem; }
      .header-right { width: 100%; justify-content: space-between; }
      #levelInfo { flex: 1; }
      #xpOuter { width: 100%; }
    }
    #container { position: relative; width: 100%; height: 100%; padding-top: 70px; padding-bottom: 80px; }
    #canvas { display: block; width: 100%; height: 100%; touch-action: none; outline: none; }
    .panel {
      position: absolute; top: 90px; right: 20px; width: 420px; max-height: calc(100vh - 220px);
      background: rgba(2, 6, 23, 0.95); border: 1px solid #1e293b; border-radius: 12px; padding: 1.5rem;
      overflow-y: auto; z-index: 20; backdrop-filter: blur(10px); transition: transform 0.3s ease;
      box-shadow: 0 10px 25px rgba(0,0,0,0.3);
    }
    .panel.hidden { transform: translateX(460px); }
    .panel::-webkit-scrollbar { width: 6px; }
    .panel::-webkit-scrollbar-track { background: #0f172a; }
    .panel::-webkit-scrollbar-thumb { background: #334155; border-radius: 3px; }
    #panelToggle {
      position: absolute; left: -60px; top: 50%; transform: translateY(-50%);
      width: 60px; height: 110px; background: rgba(2, 6, 23, 0.98); border: 1px solid #1e293b;
      border-right: none; border-radius: 20px 0 0 20px; color: #60a5fa; font-size: 2.4rem;
      font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center;
      z-index: 21; backdrop-filter: blur(12px); box-shadow: 0 6px 30px rgba(0,0,0,0.5); transition: all 0.3s ease;
    }
    #panelToggle:hover { background: rgba(30, 41, 59, 0.98); color: white; transform: translateY(-50%) translateX(-4px); }
    @media (max-width: 900px) {
      .panel {
        position: absolute; top: auto; right: 0; left: 0; bottom: 0; width: 100%; height: 85vh;
        max-height: none; border-radius: 20px 20px 0 0; transform: translateY(calc(100% - 60px));
        transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1); padding-top: 20px; padding-bottom: 120px;
        z-index: 1100; overflow-y: auto; background: rgba(2, 6, 23, 0.95); border: 1px solid #1e293b;
        border-bottom: none; box-shadow: 0 -5px 25px rgba(0,0,0,0.5);
      }
      .panel.visible { transform: translateY(0); }
      #panelToggle { display: none; }
    }
    #mobilePanelToggle {
      position: fixed; bottom: 20px; right: 20px; width: 140px; height: 44px;
      background: rgba(2, 6, 23, 0.9); border: 1px solid #60a5fa; border-radius: 22px;
      color: #60a5fa; font-size: 0.85rem; font-weight: 700; display: flex; align-items: center;
      justify-content: center; cursor: pointer; z-index: 1200; backdrop-filter: blur(12px);
      box-shadow: 0 4px 20px rgba(0,0,0,0.6); transition: background 0.2s, transform 0.1s;
      text-transform: uppercase; letter-spacing: 0.5px;
    }
    #mobilePanelToggle:active { transform: scale(0.96); }
    #mobilePanelToggle::before {
      content: ''; position: absolute; top: -6px; left: 50%; transform: translateX(-50%);
      width: 40px; height: 4px; background: #94a3b8; border-radius: 2px; opacity: 0.5;
    }
    @media (min-width: 901px) { #mobilePanelToggle { display: none; } }
    @media (max-width: 900px) { #mobilePanelToggle { display: flex; } }
    .panel h2 { color: #60a5fa; margin: 1.5rem 0 1rem; font-size: 1.1rem; border-bottom: 1px solid #1e293b; padding-bottom: 0.5rem; }
    .control-group { margin-bottom: 1.2rem; }
    label { display: block; font-size: 0.9rem; color: #e5e7eb; margin-bottom: 0.4rem; }
    input, select, button { width: 100%; padding: 0.5rem; border-radius: 0.375rem; border: 1px solid #1f2937; background: #020617; color: #e5e7eb; font: inherit; }
    input[type="range"] { padding: 0.3rem 0; accent-color: #60a5fa; }
    input[type="color"] { height: 44px; padding: 0.2rem; }
    button { background: #60a5fa; border: none; color: white; cursor: pointer; margin-top: 0.8rem; font-weight: 600; transition: background 0.2s; }
    button:hover { background: #3b82f6; }
    button:disabled { background: #475569; cursor: not-allowed; }
    #modeIndicator {
      position: fixed; top: 80px; left: 20px; background: rgba(2, 6, 23, 0.9);
      border: 2px solid #60a5fa; border-radius: 8px; padding: 8px 16px; font-size: 1.2rem;
      font-weight: 700; color: #60a5fa; z-index: 100; backdrop-filter: blur(12px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.4); display: none;
    }
    #modeIndicator.visible { display: block; }
    #transformStatus {
      position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%);
      background: rgba(2, 6, 23, 0.95); border: 2px solid #f59e0b; border-radius: 8px;
      padding: 12px 24px; font-size: 1rem; color: #f59e0b; z-index: 100;
      backdrop-filter: blur(12px); box-shadow: 0 4px 12px rgba(0,0,0,0.4); display: none;
    }
    #transformStatus.visible { display: block; }
    #axisIndicator {
      position: fixed; bottom: 130px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 8px; z-index: 100;
    }
    .axis-btn {
      background: rgba(2, 6, 23, 0.95); border: 2px solid #475569; border-radius: 6px;
      padding: 8px 16px; font-size: 0.9rem; font-weight: 700; color: #94a3b8;
      cursor: pointer; transition: all 0.2s;
    }
    .axis-btn.active { border-color: #f59e0b; color: #f59e0b; }
    .axis-btn:hover { border-color: #60a5fa; color: #60a5fa; }
    #layersList { list-style: none; padding: 0; margin: 0 0 1rem; }
    .layer-item {
      display: flex; align-items: center; gap: 8px; padding: 10px; background: #0f172a;
      border-radius: 8px; margin-bottom: 8px; cursor: pointer; border: 1px solid transparent;
    }
    .layer-item.active { background: #1e293b; border-color: #60a5fa; }
    .layer-item.group { background: #162032; }
    .layer-item.group > .layer-name::before { content: "üìÅ "; }
    .layer-visibility { font-size: 1.3rem; cursor: pointer; width: 24px; text-align: center; }
    .layer-name { flex: 1; font-size: 0.95rem; }
    .layer-delete { color: #ef4444; cursor: pointer; font-size: 1.2rem; width: 24px; text-align: center; }
    .layer-toggle { cursor: pointer; font-size: 1rem; width: 20px; }
    .hint { font-size: 0.75rem; color: #94a3b8; margin-top: 0.25rem; }
    #loader {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      color: #60a5fa; font-size: 1.5rem; font-weight: bold; pointer-events: none; z-index: 0;
      text-shadow: 0 2px 10px rgba(0,0,0,0.5);
    }
    .transform-controls { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 1rem; }
    .transform-input label { font-size: 0.75rem; color: #94a3b8; margin: 0; }
    .object-info { background: #0f172a; padding: 10px; border-radius: 8px; margin-bottom: 1rem; border: 1px solid #1e293b; }
    .object-info h3 { margin: 0 0 8px; font-size: 0.95rem; color: #60a5fa; }
    .site-footer { position: fixed; bottom: 0; left: 0; right: 0; background: rgba(2,6,23,0.95); border-top: 1px solid #1e293b; padding: 1rem; z-index: 1000; backdrop-filter: blur(10px); }
    .footer-inner { max-width: 1200px; margin: 0 auto; display: flex; justify-content: space-between; flex-wrap: wrap; gap: 1.5rem; font-size: 0.85rem; }
    .footer-nav a { color: #cbd5e1; text-decoration: none; }
    .footer-nav a:hover { color: #60a5fa; }
    #sculptingControls { display: none; }
    #sculptingControls.visible { display: block; }
    .sculpt-tool-btn { width: auto; display: inline-block; margin: 2px; font-size: 0.8rem; }
    .sculpt-row { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 0.8rem; }
    .sculpt-row button { flex: 1; min-width: 60px; }
    .mode-badge {
      display: inline-block; padding: 4px 8px; border-radius: 4px; font-size: 0.75rem;
      font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px;
    }
    .mode-badge.object { background: #60a5fa; color: white; }
    .mode-badge.edit { background: #f59e0b; color: white; }
  </style>
</head>
<body>
<header class="site-header">
  <div class="header-inner">
    <div class="header-left">
      <div class="logo"><a href="index.html">BowesProduct</a></div>
      <nav class="main-nav">
        <a href="index.html">Home</a>
        <a href="models.html">Models</a>
        <a href="retexture.html">Retexture</a>
        <a href="editor.html">Editor</a>
        <a href="3d.html" class="active">3D</a>
      </nav>
    </div>
    <div class="header-right">
      <img id="profilePic" alt="Profile">
      <div id="levelInfo">
        <div id="levelText"></div>
        <div id="xpOuter"><div id="xpBar"></div></div>
      </div>
      <button id="authBtn" class="login-btn">Login</button>
    </div>
  </div>
</header>

<div id="container">
  <div id="loader">Add objects or upload a model to start</div>
  <canvas id="canvas"></canvas>

  <div id="modeIndicator">
    <span class="mode-badge object" id="modeBadge">Object Mode</span>
  </div>

  <div id="transformStatus">
    <span id="transformText">Move</span>
  </div>

  <div id="axisIndicator">
    <button class="axis-btn" id="axisX">X</button>
    <button class="axis-btn" id="axisY">Y</button>
    <button class="axis-btn" id="axisZ">Z</button>
  </div>

  <div class="panel visible" id="panel">
    <button id="panelToggle">‚Üê</button>

    <div style="padding:0.8rem;background:rgba(30,41,59,0.4);border-radius:8px;margin-bottom:1rem;font-size:0.85rem;line-height:1.4;border:1px solid #334155;">
      <strong style="color:#60a5fa">Controls (Blender-style)</strong>
      <ul style="margin:10px 0 0 0;padding-left:20px;color:#e5e7eb;">
        <li><strong>Tab</strong>: Switch Object/Edit Mode</li>
        <li><strong>G</strong>: Move ‚Ä¢ <strong>R</strong>: Rotate ‚Ä¢ <strong>S</strong>: Scale</li>
        <li><strong>X / Y / Z</strong>: Constrain to axis</li>
        <li><strong>Middle mouse drag</strong>: Orbit view</li>
        <li><strong>Shift + Middle drag</strong>: Pan view</li>
        <li><strong>Scroll / Pinch</strong>: Zoom</li>
        <li><strong>Left click / Tap or Enter</strong>: Confirm ‚Ä¢ <strong>Esc / Right click</strong>: Cancel</li>
        <li><strong>Click / Tap object</strong>: Select ‚Ä¢ <strong>Shift + Click</strong>: Multi-select</li>
      </ul>
      <p style="margin:15px 0 0 0;color:#cbd5e1;font-size:0.8rem;">
        <strong>Mobile:</strong> One finger drag = orbit ‚Ä¢ Two fingers drag = pan ‚Ä¢ Pinch = zoom ‚Ä¢ Tap = select/confirm
      </p>
    </div>

    <h2>Current Mode</h2>
    <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:1rem;">
      <button id="modeObject" class="mode-btn active">Object Mode (Tab)</button>
      <button id="modeEdit" class="mode-btn">Edit Mode (Tab)</button>
    </div>

    <h2 id="sculptingHeader" style="display:none;">Sculpting Tools</h2>
    <div id="sculptingControls">
      <div class="sculpt-row">
        <button id="sculptBrush" class="sculpt-tool-btn active">Brush</button>
        <button id="sculptInflate" class="sculpt-tool-btn">Inflate</button>
        <button id="sculptDeflate" class="sculpt-tool-btn">Deflate</button>
        <button id="sculptSmooth" class="sculpt-tool-btn">Smooth</button>
        <button id="sculptFlatten" class="sculpt-tool-btn">Flatten</button>
      </div>
      <div class="control-group">
        <label for="brushSize">Brush Size: <span id="brushSizeVal">0.5</span></label>
        <input type="range" id="brushSize" min="0.1" max="2" step="0.1" value="0.5">
      </div>
      <div class="control-group">
        <label for="brushStrength">Brush Strength: <span id="brushStrengthVal">0.5</span></label>
        <input type="range" id="brushStrength" min="0.1" max="2" step="0.1" value="0.5">
      </div>
      <div class="hint">Click and drag on mesh to sculpt. Hold Shift to invert.</div>
    </div>

    <h2>Add Objects</h2>
    <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-bottom:1rem;">
      <button id="addBox">Box</button>
      <button id="addSphere">Sphere</button>
      <button id="addCylinder">Cylinder</button>
      <button id="addTorus">Torus</button>
      <button id="addCone">Cone</button>
      <button id="addPlane">Plane</button>
      <button id="addIcosahedron">Icosahedron</button>
      <button id="addDodecahedron">Dodecahedron</button>
      <button id="addOctahedron">Octahedron</button>
      <button id="addTetrahedron">Tetrahedron</button>
      <button id="addRing">Ring</button>
      <button id="addTube">Tube</button>
    </div>

    <h2>Group</h2>
    <button id="createGroup">Create Group from Selected</button>
    <button id="ungroup">Ungroup Selected</button>
    <div class="hint">Hold Shift and click objects to multi-select</div>

    <h2>Model</h2>
    <div class="control-group">
      <label for="uploadModel">Upload GLB/GLTF</label>
      <input type="file" id="uploadModel" accept=".glb,.gltf">
      <div class="hint">Supports GLB/GLTF. Auto-centers model.</div>
    </div>

    <h2>Selected Object(s)</h2>
    <div id="selectedObjectInfo">
      <p style="color:#94a3b8;font-size:0.85rem;">No object selected</p>
    </div>

    <div id="transformControls" style="display:none;">
      <div class="control-group"><label>Position</label><div class="transform-controls">
        <div class="transform-input"><label>X</label><input type="number" id="posX" step="0.1"></div>
        <div class="transform-input"><label>Y</label><input type="number" id="posY" step="0.1"></div>
        <div class="transform-input"><label>Z</label><input type="number" id="posZ" step="0.1"></div>
      </div></div>
      <div class="control-group"><label>Rotation (degrees)</label><div class="transform-controls">
        <div class="transform-input"><label>X</label><input type="number" id="rotX" step="5"></div>
        <div class="transform-input"><label>Y</label><input type="number" id="rotY" step="5"></div>
        <div class="transform-input"><label>Z</label><input type="number" id="rotZ" step="5"></div>
      </div></div>
      <div class="control-group"><label>Scale</label><div class="transform-controls">
        <div class="transform-input"><label>X</label><input type="number" id="scaleX" step="0.1" min="0.01"></div>
        <div class="transform-input"><label>Y</label><input type="number" id="scaleY" step="0.1" min="0.01"></div>
        <div class="transform-input"><label>Z</label><input type="number" id="scaleZ" step="0.1" min="0.01"></div>
      </div></div>
      <button id="duplicateBtn">Duplicate (Shift+D)</button>
      <button id="deleteBtn" style="background:#ef4444;">Delete Selected</button>
    </div>

    <h2>Material (applies to single mesh)</h2>
    <div class="control-group">
      <label for="materialColor">Color</label>
      <input type="color" id="materialColor" value="#60a5fa">
    </div>
    <div class="control-group">
      <label for="metallicSlider">Metallic <span id="metallicVal">0.00</span></label>
      <input type="range" id="metallicSlider" min="0" max="1" step="0.01" value="0">
    </div>
    <div class="control-group">
      <label for="roughnessSlider">Roughness <span id="roughnessVal">0.50</span></label>
      <input type="range" id="roughnessSlider" min="0" max="1" step="0.01" value="0.5">
    </div>

    <h2>Layers / Objects</h2>
    <ol id="layersList"></ol>
    <div id="undoRedoGroup">
      <button id="undoBtn" disabled>Undo (Ctrl+Z)</button>
      <button id="redoBtn" disabled>Redo (Ctrl+Y)</button>
    </div>

    <h2>Lighting</h2>
    <div class="control-group">
      <label for="envPreset">Environment</label>
      <select id="envPreset">
        <option value="neutral">Neutral</option>
        <option value="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r182/examples/textures/equirect/royal_esplanade_1k.hdr">Royal Esplanade</option>
        <option value="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r182/examples/textures/equirect/spruit_sunrise_1k.hdr">Sunrise</option>
        <option value="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r182/examples/textures/equirect/moonless_golf_1k.hdr">Night</option>
      </select>
    </div>

    <h2>Export</h2>
    <button id="exportBtn">Export Scene as GLB</button>
    <div id="exportStatus" style="margin-top:0.5rem;font-size:0.8rem;color:#94a3b8;"></div>
  </div>
</div>

<footer class="site-footer">
  <div class="footer-inner">
    <nav class="footer-nav">
      <a href="about.html">About</a>
      <a href="privacy.html">Privacy</a>
      <a href="terms.html">Terms</a>
      <a href="license.html">License</a>
      <a href="refund.html">Refund</a>
      <a href="rewards.html">Rewards</a>
    </nav>
    <p>¬© BowesProduct</p>
  </div>
</footer>

<div id="mobilePanelToggle"><span>‚ñ≤ Controls</span></div>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
  import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';

  const canvas = document.getElementById('canvas');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, preserveDrawingBuffer: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x020617);

  const gridHelper = new THREE.GridHelper(20, 20, 0x1e293b, 0x0f172a);
  scene.add(gridHelper);

  scene.add(new THREE.AmbientLight(0xffffff, 0.4));
  const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
  dirLight.position.set(5, 10, 7);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.width = 2048;
  dirLight.shadow.mapSize.height = 2048;
  scene.add(dirLight);

  const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(5, 4, 5);

  const controls = new OrbitControls(camera, canvas);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;

  let isMiddleMouseDown = false;
  let isShiftPressed = false;

  canvas.addEventListener('pointerdown', (e) => {
    if (e.button === 1) {
      isMiddleMouseDown = true;
      e.preventDefault();
    }
  });

  canvas.addEventListener('pointerup', (e) => {
    if (e.button === 1) isMiddleMouseDown = false;
  });

  canvas.addEventListener('pointerleave', () => {
    isMiddleMouseDown = false;
  });

  window.addEventListener('keydown', (e) => {
    if (e.key === 'Shift') isShiftPressed = true;
  });

  window.addEventListener('keyup', (e) => {
    if (e.key === 'Shift') isShiftPressed = false;
  });

  const originalPan = controls.pan;
  controls.pan = function(deltaX, deltaY) {
    if (isShiftPressed && isMiddleMouseDown) {
      originalPan.call(this, deltaX, deltaY);
    }
  };

  let currentMode = 'object';
  let transformMode = null;
  let axisConstraint = null;

  function setEditMode(mode) {
    currentMode = mode;
    const modeBadge = document.getElementById('modeBadge');
    const modeIndicator = document.getElementById('modeIndicator');

    if (mode === 'object') {
      modeBadge.textContent = 'Object Mode';
      modeBadge.className = 'mode-badge object';
      document.getElementById('modeObject').classList.add('active');
      document.getElementById('modeEdit').classList.remove('active');
      document.getElementById('sculptingHeader').style.display = 'none';
      document.getElementById('sculptingControls').classList.remove('visible');
    } else {
      modeBadge.textContent = 'Edit Mode';
      modeBadge.className = 'mode-badge edit';
      document.getElementById('modeObject').classList.remove('active');
      document.getElementById('modeEdit').classList.add('active');
      document.getElementById('sculptingHeader').style.display = 'block';
      document.getElementById('sculptingControls').classList.add('visible');
    }

    modeIndicator.classList.add('visible');
    setTimeout(() => modeIndicator.classList.remove('visible'), 1500);
  }

  document.getElementById('modeObject').onclick = () => setEditMode('object');
  document.getElementById('modeEdit').onclick = () => setEditMode('edit');

  let isTransforming = false;
  let initialMouse = new THREE.Vector2();
  let initialTransform = {
    position: new THREE.Vector3(),
    rotation: new THREE.Euler(),
    scale: new THREE.Vector3()
  };

  function enterTransformMode(mode) {
    if (selectedObjects.length === 0) return;

    transformMode = mode;
    axisConstraint = null;
    isTransforming = false;

    const transformStatus = document.getElementById('transformStatus');
    const transformText = document.getElementById('transformText');

    transformText.textContent = mode.charAt(0).toUpperCase() + mode.slice(1);
    transformStatus.classList.add('visible');

    const obj = selectedObjects[0];
    initialTransform.position.copy(obj.position);
    initialTransform.rotation.copy(obj.rotation);
    initialTransform.scale.copy(obj.scale);

    controls.enabled = false;

    ['axisX', 'axisY', 'axisZ'].forEach(id => {
      document.getElementById(id).classList.remove('active');
    });
  }

  function exitTransformMode(confirm = false) {
    if (!transformMode) return;

    const transformStatus = document.getElementById('transformStatus');
    transformStatus.classList.remove('visible');

    ['axisX', 'axisY', 'axisZ'].forEach(id => {
      document.getElementById(id).classList.remove('active');
    });

    if (confirm) {
      saveState();
    } else {
      selectedObjects.forEach(obj => {
        obj.position.copy(initialTransform.position);
        obj.rotation.copy(initialTransform.rotation);
        obj.scale.copy(initialTransform.scale);

        const outline = selectionOutlines.get(obj);
        if (outline) {
          outline.position.copy(obj.position);
          outline.rotation.copy(obj.rotation);
          outline.scale.copy(obj.scale).multiplyScalar(1.02);
        }
      });
      updateSelectedObjectUI();
    }

    transformMode = null;
    axisConstraint = null;
    isTransforming = false;
    controls.enabled = true;
  }

  function setAxisConstraint(axis) {
    axisConstraint = axis;

    ['axisX', 'axisY', 'axisZ'].forEach(id => {
      document.getElementById(id).classList.remove('active');
    });
    document.getElementById(`axis${axis.toUpperCase()}`).classList.add('active');

    const transformText = document.getElementById('transformText');
    const axisName = axis.toUpperCase();
    transformText.textContent = `${transformMode.charAt(0).toUpperCase() + transformMode.slice(1)} [${axisName}]`;
  }

  document.getElementById('axisX').onclick = () => setAxisConstraint('x');
  document.getElementById('axisY').onclick = () => setAxisConstraint('y');
  document.getElementById('axisZ').onclick = () => setAxisConstraint('z');

  const pmremGenerator = new THREE.PMREMGenerator(renderer);
  pmremGenerator.compileEquirectangularShader();
  let currentEnvMap = null;

  function loadEnvironment(url) {
    if (url === 'neutral') {
      scene.environment = null;
      if (currentEnvMap) currentEnvMap.dispose();
      return;
    }
    new RGBELoader().load(url, (tex) => {
      const envMap = pmremGenerator.fromEquirectangular(tex).texture;
      scene.environment = envMap;
      tex.dispose();
      if (currentEnvMap) currentEnvMap.dispose();
      currentEnvMap = envMap;
    });
  }
  loadEnvironment('neutral');

  const rootObjects = [];
  let selectedObjects = [];
  let objectCounter = 0;

  const selectionOutlineMaterial = new THREE.MeshBasicMaterial({
    color: 0x22c55e,
    transparent: true,
    opacity: 0.3,
    side: THREE.DoubleSide,
    depthTest: false,
    depthWrite: false,
    blending: THREE.AdditiveBlending
  });

  const selectionOutlines = new Map();

  function updateSelectionHighlight() {
    selectionOutlines.forEach((outline, obj) => {
      scene.remove(outline);
      outline.geometry.dispose();
      outline.material.dispose();
    });
    selectionOutlines.clear();

    selectedObjects.forEach(obj => {
      if (obj.isMesh) {
        const outline = obj.clone();
        outline.material = selectionOutlineMaterial.clone();
        outline.scale.multiplyScalar(1.02);
        outline.userData.isOutline = true;
        outline.renderOrder = 999;
        scene.add(outline);
        selectionOutlines.set(obj, outline);
      }
    });
  }

  const undoStack = [];
  const redoStack = [];
  const MAX_UNDO = 50;
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');

  function saveState() {
    const state = rootObjects.map(obj => serializeObject(obj));
    undoStack.push(state);
    if (undoStack.length > MAX_UNDO) undoStack.shift();
    redoStack.length = 0;
    undoBtn.disabled = false;
    redoBtn.disabled = true;
  }

  function serializeObject(obj) {
    if (obj.isGroup) {
      return {
        type: 'group',
        name: obj.userData.name,
        visible: obj.visible,
        position: obj.position.toArray(),
        rotation: obj.rotation.toArray(),
        scale: obj.scale.toArray(),
        children: obj.children.map(child => serializeObject(child))
      };
    } else {
      return {
        type: 'mesh',
        name: obj.userData.name,
        geometry: obj.userData.geometryName,
        visible: obj.visible,
        position: obj.position.toArray(),
        rotation: obj.rotation.toArray(),
        scale: obj.scale.toArray(),
        color: obj.material.color.getHex(),
        metallic: obj.material.metalness,
        roughness: obj.material.roughness
      };
    }
  }

  function deserializeObject(data, parent = null) {
    let obj;
    if (data.type === 'group') {
      obj = new THREE.Group();
      obj.userData.isGroup = true;
      data.children.forEach(childData => {
        const child = deserializeObject(childData, obj);
        obj.add(child);
      });
    } else {
      const geometry = createGeometryForName(data.geometry);
      const material = new THREE.MeshStandardMaterial({
        color: data.color,
        metalness: data.metallic,
        roughness: data.roughness,
        flatShading: false
      });
      obj = new THREE.Mesh(geometry, material);
      obj.userData.geometryName = data.geometry;
      obj.castShadow = true;
      obj.receiveShadow = true;
    }
    obj.userData.name = data.name;
    obj.userData.id = objectCounter++;
    obj.visible = data.visible;
    obj.position.fromArray(data.position);
    obj.rotation.fromArray(data.rotation);
    obj.scale.fromArray(data.scale);
    if (parent) parent.add(obj);
    return obj;
  }

  function restoreState(state) {
    rootObjects.forEach(o => scene.remove(o));
    rootObjects.length = 0;
    state.forEach(data => {
      const obj = deserializeObject(data);
      scene.add(obj);
      rootObjects.push(obj);
    });
    selectedObjects = [];
    updateSelectedObjectUI();
    updateLayersList();
    updateSelectionHighlight();
  }

  function undo() {
    if (undoStack.length === 0) return;
    redoStack.push(rootObjects.map(obj => serializeObject(obj)));
    const state = undoStack.pop();
    restoreState(state);
    undoBtn.disabled = undoStack.length === 0;
    redoBtn.disabled = false;
  }

  function redo() {
    if (redoStack.length === 0) return;
    undoStack.push(rootObjects.map(obj => serializeObject(obj)));
    const state = redoStack.pop();
    restoreState(state);
    redoBtn.disabled = redoStack.length === 0;
    undoBtn.disabled = false;
  }

  undoBtn.onclick = undo;
  redoBtn.onclick = redo;

  function createGeometryForName(name) {
    switch(name) {
      case 'Box': return new THREE.BoxGeometry(1, 1, 1, 16, 16, 16);
      case 'Sphere': return new THREE.SphereGeometry(0.5, 64, 64);
      case 'Cylinder': return new THREE.CylinderGeometry(0.5, 0.5, 1, 64);
      case 'Torus': return new THREE.TorusGeometry(0.5, 0.2, 32, 64);
      case 'Cone': return new THREE.ConeGeometry(0.5, 1, 64);
      case 'Plane': return new THREE.PlaneGeometry(1, 1, 32, 32);
      case 'Icosahedron': return new THREE.IcosahedronGeometry(0.6, 2);
      case 'Dodecahedron': return new THREE.DodecahedronGeometry(0.6, 1);
      case 'Octahedron': return new THREE.OctahedronGeometry(0.7, 1);
      case 'Tetrahedron': return new THREE.TetrahedronGeometry(0.7, 1);
      case 'Ring': return new THREE.RingGeometry(0.3, 0.6, 64);
      case 'Tube': return new THREE.TubeGeometry(new THREE.CatmullRomCurve3([
        new THREE.Vector3(-1, 0, 0),
        new THREE.Vector3(-0.5, 1, 0),
        new THREE.Vector3(0.5, -1, 0),
        new THREE.Vector3(1, 0, 0)
      ]), 64, 0.1, 16, false);
      default: return new THREE.BoxGeometry(1, 1, 1, 16, 16, 16);
    }
  }

  function addPrimitive(name) {
    saveState();
    const geometry = createGeometryForName(name);
    const material = new THREE.MeshStandardMaterial({ 
      color: 0x60a5fa, 
      metalness: 0, 
      roughness: 0.5,
      flatShading: false
    });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.y = 0.5;
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    mesh.userData.name = name;
    mesh.userData.geometryName = name;
    mesh.userData.id = objectCounter++;
    scene.add(mesh);
    rootObjects.push(mesh);
    selectObject(mesh, false);
    updateLayersList();
    document.getElementById('loader').style.display = 'none';
  }

  document.getElementById('addBox').onclick = () => addPrimitive('Box');
  document.getElementById('addSphere').onclick = () => addPrimitive('Sphere');
  document.getElementById('addCylinder').onclick = () => addPrimitive('Cylinder');
  document.getElementById('addTorus').onclick = () => addPrimitive('Torus');
  document.getElementById('addCone').onclick = () => addPrimitive('Cone');
  document.getElementById('addPlane').onclick = () => addPrimitive('Plane');
  document.getElementById('addIcosahedron').onclick = () => addPrimitive('Icosahedron');
  document.getElementById('addDodecahedron').onclick = () => addPrimitive('Dodecahedron');
  document.getElementById('addOctahedron').onclick = () => addPrimitive('Octahedron');
  document.getElementById('addTetrahedron').onclick = () => addPrimitive('Tetrahedron');
  document.getElementById('addRing').onclick = () => addPrimitive('Ring');
  document.getElementById('addTube').onclick = () => addPrimitive('Tube');

  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  function selectObject(object, multi = false) {
    if (!multi) selectedObjects = [];
    if (object && !selectedObjects.includes(object)) selectedObjects.push(object);
    updateSelectedObjectUI();
    updateSelectionHighlight();
    updateLayersList();
  }

  canvas.addEventListener('click', (e) => {
    if (transformMode) {
      exitTransformMode(true);
      return;
    }

    const rect = canvas.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const allMeshes = [];
    rootObjects.forEach(obj => obj.traverse(child => { 
      if (child.isMesh && !child.userData.isOutline) allMeshes.push(child); 
    }));
    const intersects = raycaster.intersectObjects(allMeshes, false);
    if (intersects.length > 0) {
      selectObject(intersects[0].object, e.shiftKey);
    } else if (!e.shiftKey) {
      selectedObjects = [];
      updateSelectedObjectUI();
      updateSelectionHighlight();
      updateLayersList();
    }
  });

  canvas.addEventListener('mousedown', (e) => {
    if (transformMode && selectedObjects.length > 0 && e.button === 0) {
      isTransforming = true;
      initialMouse.set(e.clientX, e.clientY);
      e.preventDefault();
    }
  });

  canvas.addEventListener('mousemove', (e) => {
    if (!isTransforming || !transformMode || selectedObjects.length === 0) return;

    const deltaX = e.clientX - initialMouse.x;
    const deltaY = e.clientY - initialMouse.y;

    const sensitivity = 0.01;

    selectedObjects.forEach(obj => {
      switch (transformMode) {
        case 'move':
          const moveVec = new THREE.Vector3(deltaX, -deltaY, 0).multiplyScalar(sensitivity);
          if (axisConstraint === 'x') { moveVec.y = 0; moveVec.z = 0; }
          else if (axisConstraint === 'y') { moveVec.x = 0; moveVec.z = 0; }
          else if (axisConstraint === 'z') { moveVec.x = 0; moveVec.y = 0; }
          obj.position.add(moveVec);
          break;

        case 'rotate':
          const rotVec = new THREE.Vector3(deltaY, deltaX, 0).multiplyScalar(sensitivity);
          if (axisConstraint === 'x') { rotVec.y = 0; rotVec.z = 0; }
          else if (axisConstraint === 'y') { rotVec.x = 0; rotVec.z = 0; }
          else if (axisConstraint === 'z') { rotVec.x = 0; rotVec.y = 0; }
          obj.rotation.x += rotVec.x;
          obj.rotation.y += rotVec.y;
          obj.rotation.z += rotVec.z;
          break;

        case 'scale':
          const scaleVec = new THREE.Vector3(deltaX * sensitivity, deltaY * sensitivity, 0);
          const scaleFactor = Math.exp(scaleVec.x + scaleVec.y);
          if (axisConstraint === 'x') obj.scale.x *= scaleFactor;
          else if (axisConstraint === 'y') obj.scale.y *= scaleFactor;
          else if (axisConstraint === 'z') obj.scale.z *= scaleFactor;
          else obj.scale.multiplyScalar(scaleFactor);
          break;
      }

      const outline = selectionOutlines.get(obj);
      if (outline) {
        outline.position.copy(obj.position);
        outline.rotation.copy(obj.rotation);
        outline.scale.copy(obj.scale).multiplyScalar(1.02);
      }
    });

    initialMouse.set(e.clientX, e.clientY);
    updateSelectedObjectUI();
  });

  canvas.addEventListener('mouseup', (e) => {
    if (transformMode && isTransforming && e.button === 0) {
      isTransforming = false;
    }
  });

  canvas.addEventListener('click', (e) => {
    if (transformMode && !isTransforming) {
      exitTransformMode(true);
    }
  });

  canvas.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    if (transformMode) {
      exitTransformMode(false);
    }
  });

  window.addEventListener('keydown', (e) => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

    if (!transformMode) {
      switch(e.key.toLowerCase()) {
        case 'g': enterTransformMode('move'); break;
        case 'r': enterTransformMode('rotate'); break;
        case 's': enterTransformMode('scale'); break;
        case 'tab': e.preventDefault(); setEditMode(currentMode === 'object' ? 'edit' : 'object'); break;
        case 'delete':
        case 'backspace': document.getElementById('deleteBtn').click(); break;
        case 'd':
          if (e.shiftKey) { e.preventDefault(); document.getElementById('duplicateBtn').click(); }
          break;
        case 'z':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            if (e.shiftKey) redo(); else undo();
          }
          break;
        case 'y':
          if (e.ctrlKey || e.metaKey) { e.preventDefault(); redo(); }
          break;
      }
    } else {
      if (e.key === 'Enter') exitTransformMode(true);
      else if (e.key === 'Escape') exitTransformMode(false);
      else if (e.key.toLowerCase() === 'x') setAxisConstraint('x');
      else if (e.key.toLowerCase() === 'y') setAxisConstraint('y');
      else if (e.key.toLowerCase() === 'z') setAxisConstraint('z');
    }
  });

  function updateSelectedObjectUI() {
    const infoDiv = document.getElementById('selectedObjectInfo');
    const transformDiv = document.getElementById('transformControls');
    if (selectedObjects.length === 0) {
      infoDiv.innerHTML = '<p style="color:#94a3b8;font-size:0.85rem;">No object selected</p>';
      transformDiv.style.display = 'none';
      return;
    }
    let html = `<div class="object-info"><h3>${selectedObjects.length} object${selectedObjects.length > 1 ? 's' : ''} selected</h3>`;
    if (selectedObjects.length === 1) {
      const obj = selectedObjects[0];
      html += `<p>Type: ${obj.userData.name || 'Mesh'}</p><p>ID: ${obj.userData.id}</p>`;
      document.getElementById('materialColor').value = '#' + obj.material.color.getHexString();
      document.getElementById('metallicSlider').value = obj.material.metalness;
      document.getElementById('metallicVal').textContent = obj.material.metalness.toFixed(2);
      document.getElementById('roughnessSlider').value = obj.material.roughness;
      document.getElementById('roughnessVal').textContent = obj.material.roughness.toFixed(2);
    } else {
      html += `<p>Multi-selection active</p>`;
    }
    html += `</div>`;
    infoDiv.innerHTML = html;
    transformDiv.style.display = 'block';
    updateTransformInputs();
  }

  function updateTransformInputs() {
    if (selectedObjects.length === 0) return;
    const obj = selectedObjects[0];
    document.getElementById('posX').value = obj.position.x.toFixed(2);
    document.getElementById('posY').value = obj.position.y.toFixed(2);
    document.getElementById('posZ').value = obj.position.z.toFixed(2);
    document.getElementById('rotX').value = THREE.MathUtils.radToDeg(obj.rotation.x).toFixed(1);
    document.getElementById('rotY').value = THREE.MathUtils.radToDeg(obj.rotation.y).toFixed(1);
    document.getElementById('rotZ').value = THREE.MathUtils.radToDeg(obj.rotation.z).toFixed(1);
    document.getElementById('scaleX').value = obj.scale.x.toFixed(2);
    document.getElementById('scaleY').value = obj.scale.y.toFixed(2);
    document.getElementById('scaleZ').value = obj.scale.z.toFixed(2);
  }

  function applyTransformToAll() {
    const pos = new THREE.Vector3(
      parseFloat(document.getElementById('posX').value) || 0,
      parseFloat(document.getElementById('posY').value) || 0,
      parseFloat(document.getElementById('posZ').value) || 0
    );
    const rot = new THREE.Euler(
      THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotX').value) || 0),
      THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotY').value) || 0),
      THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotZ').value) || 0)
    );
    const scale = new THREE.Vector3(
      parseFloat(document.getElementById('scaleX').value) || 1,
      parseFloat(document.getElementById('scaleY').value) || 1,
      parseFloat(document.getElementById('scaleZ').value) || 1
    );
    selectedObjects.forEach(obj => {
      obj.position.copy(pos);
      obj.rotation.copy(rot);
      obj.scale.copy(scale);
      const outline = selectionOutlines.get(obj);
      if (outline) {
        outline.position.copy(pos);
        outline.rotation.copy(rot);
        outline.scale.copy(scale).multiplyScalar(1.02);
      }
    });
  }

  ['posX','posY','posZ','rotX','rotY','rotZ','scaleX','scaleY','scaleZ'].forEach(id => {
    document.getElementById(id).addEventListener('change', () => {
      saveState();
      applyTransformToAll();
    });
  });

  document.getElementById('materialColor').addEventListener('input', (e) => {
    if (selectedObjects.length === 1 && selectedObjects[0].isMesh) {
      selectedObjects[0].material.color.set(e.target.value);
      saveState();
    }
  });

  document.getElementById('metallicSlider').addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    document.getElementById('metallicVal').textContent = v.toFixed(2);
    if (selectedObjects.length === 1 && selectedObjects[0].isMesh) {
      selectedObjects[0].material.metalness = v;
      saveState();
    }
  });

  document.getElementById('roughnessSlider').addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    document.getElementById('roughnessVal').textContent = v.toFixed(2);
    if (selectedObjects.length === 1 && selectedObjects[0].isMesh) {
      selectedObjects[0].material.roughness = v;
      saveState();
    }
  });

  document.getElementById('duplicateBtn').onclick = () => {
    if (selectedObjects.length === 0) return;
    saveState();
    const clones = [];
    selectedObjects.forEach(obj => {
      const clone = obj.clone();
      if (obj.isMesh) clone.material = obj.material.clone();
      clone.position.x += 1;
      clone.userData.id = objectCounter++;
      scene.add(clone);
      rootObjects.push(clone);
      clones.push(clone);
    });
    selectedObjects = clones;
    updateSelectionHighlight();
    updateLayersList();
    updateSelectedObjectUI();
  };

  document.getElementById('deleteBtn').onclick = () => {
    if (selectedObjects.length === 0) return;
    saveState();
    selectedObjects.forEach(obj => {
      const outline = selectionOutlines.get(obj);
      if (outline) {
        scene.remove(outline);
        outline.geometry.dispose();
        outline.material.dispose();
        selectionOutlines.delete(obj);
      }

      if (obj.parent && obj.parent.isGroup) {
        obj.parent.remove(obj);
      } else {
        scene.remove(obj);
        const idx = rootObjects.indexOf(obj);
        if (idx > -1) rootObjects.splice(idx, 1);
      }
    });
    selectedObjects = [];
    updateLayersList();
    updateSelectedObjectUI();
  };

  document.getElementById('createGroup').onclick = () => {
    if (selectedObjects.length < 2) return;
    saveState();
    const group = new THREE.Group();
    group.userData.isGroup = true;
    group.userData.name = `Group ${rootObjects.filter(o => o.userData.isGroup).length + 1}`;
    group.userData.id = objectCounter++;

    selectedObjects.forEach(obj => {
      const worldPos = new THREE.Vector3();
      obj.getWorldPosition(worldPos);
      obj.parent.remove(obj);
      group.add(obj);
      obj.position.copy(worldPos).sub(group.position);
    });

    scene.add(group);
    rootObjects.push(group);
    selectedObjects = [group];
    updateSelectionHighlight();
    updateLayersList();
    updateSelectedObjectUI();
  };

  document.getElementById('ungroup').onclick = () => {
    const groupsToUngroup = selectedObjects.filter(o => o.isGroup);
    if (groupsToUngroup.length === 0) return;
    saveState();
    groupsToUngroup.forEach(group => {
      const children = [...group.children];
      children.forEach(child => {
        const worldPos = new THREE.Vector3();
        child.getWorldPosition(worldPos);
        group.remove(child);
        scene.add(child);
        child.position.copy(worldPos);
        rootObjects.push(child);
      });
      scene.remove(group);
      const idx = rootObjects.indexOf(group);
      if (idx > -1) rootObjects.splice(idx, 1);
    });
    selectedObjects = [];
    updateSelectionHighlight();
    updateLayersList();
    updateSelectedObjectUI();
  };

  function updateLayersList() {
    const list = document.getElementById('layersList');
    list.innerHTML = '';
    rootObjects.slice().reverse().forEach(obj => addLayerItem(obj, list));
  }

  function addLayerItem(obj, parentList) {
    const li = document.createElement('li');
    li.className = 'layer-item' + (selectedObjects.includes(obj) ? ' active' : '') + (obj.userData.isGroup ? ' group' : '');
    li.innerHTML = `
      <span class="layer-toggle">${obj.userData.isGroup ? '‚ñº' : ''}</span>
      <span class="layer-visibility">${obj.visible ? 'üëÅ' : 'üëÅ‚Äçüó®'}</span>
      <span class="layer-name">${obj.userData.name || 'Object'}</span>
      <span class="layer-delete">√ó</span>
    `;
    parentList.appendChild(li);

    li.querySelector('.layer-visibility').onclick = (e) => {
      e.stopPropagation();
      obj.visible = !obj.visible;
      li.querySelector('.layer-visibility').textContent = obj.visible ? 'üëÅ' : 'üëÅ‚Äçüó®';
      obj.traverse(child => child.visible = obj.visible);
      const outline = selectionOutlines.get(obj);
      if (outline) outline.visible = obj.visible;
      saveState();
    };

    li.querySelector('.layer-delete').onclick = (e) => {
      e.stopPropagation();
      saveState();
      const outline = selectionOutlines.get(obj);
      if (outline) {
        scene.remove(outline);
        outline.geometry.dispose();
        outline.material.dispose();
        selectionOutlines.delete(obj);
      }
      scene.remove(obj);
      const idx = rootObjects.indexOf(obj);
      if (idx > -1) rootObjects.splice(idx, 1);
      selectedObjects = selectedObjects.filter(o => o !== obj);
      updateSelectionHighlight();
      updateLayersList();
      updateSelectedObjectUI();
    };

    li.onclick = (e) => {
      if (e.target.classList.contains('layer-delete') || e.target.classList.contains('layer-visibility') || e.target.classList.contains('layer-toggle')) return;
      selectObject(obj, e.ctrlKey || e.metaKey);
    };

    if (obj.userData.isGroup) {
      const childList = document.createElement('ol');
      childList.style.marginLeft = '20px';
      childList.style.display = 'block';
      obj.children.forEach(child => addLayerItem(child, childList));
      li.appendChild(childList);
      li.querySelector('.layer-toggle').onclick = (e) => {
        e.stopPropagation();
        childList.style.display = childList.style.display === 'none' ? 'block' : 'none';
        li.querySelector('.layer-toggle').textContent = childList.style.display === 'none' ? '‚ñ∂' : '‚ñº';
      };
    }
  }

  document.getElementById('envPreset').addEventListener('change', (e) => loadEnvironment(e.target.value));

  const exportStatus = document.getElementById('exportStatus');
  document.getElementById('exportBtn').onclick = () => {
    if (rootObjects.length === 0) {
      exportStatus.textContent = 'No objects to export';
      exportStatus.style.color = '#ef4444';
      return;
    }
    selectionOutlines.forEach((outline, obj) => {
      scene.remove(outline);
    });

    exportStatus.textContent = 'Exporting...';
    exportStatus.style.color = '#60a5fa';
    const exporter = new GLTFExporter();
    exporter.parse(scene, (result) => {
      const blob = new Blob([result], { type: 'application/octet-stream' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = 'scene.glb';
      link.click();
      exportStatus.textContent = 'Exported!';
      exportStatus.style.color = '#4ade80';

      selectionOutlines.forEach((outline, obj) => {
        scene.add(outline);
      });
    }, { binary: true });
  };

  const panel = document.getElementById('panel');
  const panelToggle = document.getElementById('panelToggle');
  const mobilePanelToggle = document.getElementById('mobilePanelToggle');
  let panelVisible = true;
  function togglePanel() {
    panelVisible = !panelVisible;
    panel.classList.toggle('hidden', !panelVisible);
    panel.classList.toggle('visible', panelVisible);
    panelToggle.textContent = panelVisible ? '‚Üê' : '‚Üí';
    const span = mobilePanelToggle.querySelector('span');
    if (span) span.textContent = panelVisible ? '‚ñº Hide Controls' : '‚ñ≤ Controls';
  }
  panelToggle.onclick = togglePanel;
  mobilePanelToggle.onclick = togglePanel;

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  let currentSculptTool = 'brush';
  let brushSize = 0.5;
  let brushStrength = 0.5;
  let isSculpting = false;
  let lastSculptPosition = null;

  const sculptTools = ['brush', 'inflate', 'deflate', 'smooth', 'flatten'];

  sculptTools.forEach(tool => {
    const btn = document.getElementById(`sculpt${tool.charAt(0).toUpperCase() + tool.slice(1)}`);
    if (btn) {
      btn.onclick = () => {
        currentSculptTool = tool;
        sculptTools.forEach(t => {
          const b = document.getElementById(`sculpt${t.charAt(0).toUpperCase() + t.slice(1)}`);
          if (b) b.classList.remove('active');
        });
        btn.classList.add('active');
      };
    }
  });

  document.getElementById('brushSize').addEventListener('input', (e) => {
    brushSize = parseFloat(e.target.value);
    document.getElementById('brushSizeVal').textContent = brushSize.toFixed(1);
  });

  document.getElementById('brushStrength').addEventListener('input', (e) => {
    brushStrength = parseFloat(e.target.value);
    document.getElementById('brushStrengthVal').textContent = brushStrength.toFixed(1);
  });

  canvas.addEventListener('pointerdown', (e) => {
    if (currentMode !== 'edit') return;
    if (selectedObjects.length === 0 || !selectedObjects[0].isMesh) return;

    isSculpting = true;
    lastSculptPosition = getIntersectionPoint(e);
    saveState();
  });

  canvas.addEventListener('pointermove', (e) => {
    if (!isSculpting || currentMode !== 'edit') return;
    if (selectedObjects.length === 0 || !selectedObjects[0].isMesh) return;

    const currentPos = getIntersectionPoint(e);
    if (!currentPos || !lastSculptPosition) return;

    const mesh = selectedObjects[0];
    applySculpt(mesh, lastSculptPosition, currentPos);

    lastSculptPosition = currentPos;

    const outline = selectionOutlines.get(mesh);
    if (outline) {
      outline.geometry.dispose();
      outline.geometry = mesh.geometry.clone();
    }
  });

  canvas.addEventListener('pointerup', () => {
    isSculpting = false;
    lastSculptPosition = null;
  });

  canvas.addEventListener('pointerleave', () => {
    isSculpting = false;
    lastSculptPosition = null;
  });

  function getIntersectionPoint(e) {
    const rect = canvas.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);

    if (selectedObjects.length > 0 && selectedObjects[0].isMesh) {
      const intersects = raycaster.intersectObject(selectedObjects[0], false);
      if (intersects.length > 0) {
        return intersects[0];
      }
    }
    return null;
  }

  function applySculpt(mesh, lastPoint, currentPoint) {
    const geometry = mesh.geometry;
    const positionAttribute = geometry.attributes.position;
    const vertexCount = positionAttribute.count;

    const positions = positionAttribute.array;
    const normalAttribute = geometry.attributes.normal;
    const normals = normalAttribute.array;

    const localLastPoint = mesh.worldToLocal(lastPoint.point.clone());
    const brushRadius = brushSize / mesh.scale.x;
    const strength = brushStrength * 0.01;

    const vertex = new THREE.Vector3();
    const tempVertex = new THREE.Vector3();
    const center = new THREE.Vector3();

    for (let i = 0; i < vertexCount; i++) {
      vertex.fromArray(positions, i * 3);

      const distance = vertex.distanceTo(localLastPoint);
      if (distance < brushRadius) {
        const falloff = Math.pow(1 - (distance / brushRadius), 2);
        let displacement = 0;

        const normal = new THREE.Vector3(normals[i * 3], normals[i * 3 + 1], normals[i * 3 + 2]);

        switch (currentSculptTool) {
          case 'brush':
          case 'inflate':
            displacement = falloff * strength;
            tempVertex.copy(normal).multiplyScalar(displacement);
            vertex.add(tempVertex);
            break;

          case 'deflate':
            displacement = falloff * strength;
            tempVertex.copy(normal).multiplyScalar(-displacement);
            vertex.add(tempVertex);
            break;

          case 'smooth':
            center.set(0, 0, 0);
            let count = 0;
            for (let j = 0; j < vertexCount; j++) {
              if (i === j) continue;
              tempVertex.fromArray(positions, j * 3);
              const d = vertex.distanceTo(tempVertex);
              if (d < brushRadius * 0.5) {
                center.add(tempVertex);
                count++;
              }
            }
            if (count > 0) {
              center.divideScalar(count);
              tempVertex.subVectors(center, vertex).multiplyScalar(falloff * strength);
              vertex.add(tempVertex);
            }
            break;

          case 'flatten':
            const planeHeight = localLastPoint.y;
            const diff = planeHeight - vertex.y;
            vertex.y += diff * falloff * strength;
            break;
        }

        positions[i * 3] = vertex.x;
        positions[i * 3 + 1] = vertex.y;
        positions[i * 3 + 2] = vertex.z;
      }
    }

    positionAttribute.needsUpdate = true;
    geometry.computeVertexNormals();
    geometry.attributes.normal.needsUpdate = true;
  }

  window.addEventListener('dragover', e => e.preventDefault());
  window.addEventListener('drop', e => {
    e.preventDefault();
    const file = e.dataTransfer.files[0];
    if (file && (file.name.endsWith('.glb') || file.name.endsWith('.gltf'))) {
      alert("Drag & drop import not fully implemented ‚Äì use the upload button.");
    }
  });

  document.getElementById('uploadModel').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const url = URL.createObjectURL(file);
    new GLTFLoader().load(url, (gltf) => {
      saveState();
      const model = gltf.scene;
      model.traverse(child => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });
      const box = new THREE.Box3().setFromObject(model);
      const center = box.getCenter(new THREE.Vector3());
      model.position.sub(center);
      model.position.y -= box.min.y;
      scene.add(model);
      rootObjects.push(model);
      document.getElementById('loader').style.display = 'none';
      URL.revokeObjectURL(url);
    });
  });

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();
</script>
</body>
</html>
