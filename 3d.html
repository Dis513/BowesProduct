
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Modeler Pro \u2013 BowesProduct</title>
  <script async src="https://unpkg.com/es-module-shims@1.8.2/dist/es-module-shims.js"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
    }
  }
  </script>
  <style>
  *, *::before, *::after { box-sizing: border-box; }
  html, body { margin: 0; height: 100%; background: #020617; color: white; font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif; overflow: hidden; -webkit-font-smoothing: antialiased; }
  .site-header {
  position: sticky; top: 0; z-index: 1000; background: rgba(2,6,23,0.95); border-bottom: 1px solid #1e293b; backdrop-filter: blur(10px);
  }
  .header-inner { max-width: 1200px; margin: 0 auto; padding: 0.6rem 1rem; display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 0.5rem; }
  .header-left { display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; }
  .logo a { font-size: 1.3rem; font-weight: 700; color: white; text-decoration: none; white-space: nowrap; }
  .main-nav { display: flex; gap: 1rem; flex-wrap: wrap; }
  .main-nav a { color: #e5e7eb; text-decoration: none; font-size: 0.9rem; white-space: nowrap; }
  .main-nav a:hover, .main-nav a.active { color: #60a5fa; }
  .header-right { display: flex; align-items: center; gap: 0.8rem; min-height: 44px; flex-wrap: wrap; }
  #profilePic { width: 32px; height: 32px; border-radius: 50%; border: 2px solid #60a5fa; object-fit: cover; display: none; }
  .login-btn { padding: 0.45rem 1.1rem; border-radius: 999px; border: 1.5px solid #60a5fa; background: transparent; color: #60a5fa; font-size: 0.95rem; cursor: pointer; }
  #levelInfo { display: none; font-size: 0.8rem; color: #cbd5e1; }
  #levelText { white-space: nowrap; font-size: 0.75rem; }
  #xpOuter { width: 100px; height: 5px; background: #1e293b; border-radius: 3px; margin-top: 4px; }
  #xpBar { height: 100%; width: 0%; background: #60a5fa; border-radius: 3px; transition: width 0.35s ease; }
  @media (max-width: 900px) {
  .header-inner { padding: 0.5rem; }
  .header-left { width: 100%; justify-content: space-between; }
  .main-nav { gap: 0.8rem; order: 3; width: 100%; }
  .main-nav a { font-size: 0.85rem; }
  .header-right { width: 100%; justify-content: space-between; }
  #levelInfo { flex: 1; }
  #xpOuter { width: 100%; }
  }
  #container { position: relative; width: 100%; height: 100%; padding-top: 70px; padding-bottom: 80px; }
  #canvas { display: block; width: 100%; height: 100%; touch-action: none; outline: none; }
  .panel {
  position: absolute;
  top: 90px;
  right: 20px;
  width: 380px;
  max-height: calc(100vh - 220px);
  background: rgba(2, 6, 23, 0.95);
  border: 1px solid #1e293b;
  border-radius: 12px;
  padding: 1.5rem;
  overflow-y: auto;
  z-index: 20;
  backdrop-filter: blur(10px);
  transition: transform 0.3s ease;
  box-shadow: 0 10px 25px rgba(0,0,0,0.3);
  }
  .panel.hidden { transform: translateX(420px); }
  .panel::-webkit-scrollbar { width: 6px; }
  .panel::-webkit-scrollbar-track { background: #0f172a; }
  .panel::-webkit-scrollbar-thumb { background: #334155; border-radius: 3px; }
  #panelToggle {
  position: absolute;
  left: -60px;
  top: 50%;
  transform: translateY(-50%);
  width: 60px;
  height: 110px;
  background: rgba(2, 6, 23, 0.98);
  border: 1px solid #1e293b;
  border-right: none;
  border-radius: 20px 0 0 20px;
  color: #60a5fa;
  font-size: 2.4rem;
  font-weight: bold;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 21;
  backdrop-filter: blur(12px);
  box-shadow: 0 6px 30px rgba(0,0,0,0.5);
  transition: all 0.3s ease;
  }
  #panelToggle:hover { background: rgba(30, 41, 59, 0.98); color: white; transform: translateY(-50%) translateX(-4px); }
  @media (max-width: 900px) {
  .panel {
  position: absolute;
  top: auto;
  right: 0;
  left: 0;
  bottom: 0;
  width: 100%;
  height: 85vh;
  max-height: none;
  border-radius: 20px 20px 0 0;
  transform: translateY(calc(100% - 60px));
  transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1);
  padding-top: 20px;
  padding-bottom: 120px;
  z-index: 1100;
  overflow-y: auto;
  background: rgba(2, 6, 23, 0.95);
  border: 1px solid #1e293b;
  border-bottom: none;
  box-shadow: 0 -5px 25px rgba(0,0,0,0.5);
  }
  .panel.visible { transform: translateY(0); }
  #panelToggle { display: none; }
  }
  #mobilePanelToggle {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 140px;
  height: 44px;
  background: rgba(2, 6, 23, 0.9);
  border: 1px solid #60a5fa;
  border-radius: 22px;
  color: #60a5fa;
  font-size: 0.85rem;
  font-weight: 700;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 1200;
  backdrop-filter: blur(12px);
  box-shadow: 0 4px 20px rgba(0,0,0,0.6);
  transition: background 0.2s, transform 0.1s;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  }
  #mobilePanelToggle:active { transform: scale(0.96); }
  #mobilePanelToggle::before {
  content: '';
  position: absolute;
  top: -6px;
  left: 50%;
  transform: translateX(-50%);
  width: 40px;
  height: 4px;
  background: #94a3b8;
  border-radius: 2px;
  opacity: 0.5;
  }
  @media (min-width: 901px) { #mobilePanelToggle { display: none; } }
  @media (max-width: 900px) { #mobilePanelToggle { display: flex; } }
  #floatingControls {
  position: fixed;
  bottom: 20px;
  left: 20px;
  display: flex;
  gap: 10px;
  z-index: 1150;
  pointer-events: none;
  }
  .floater {
  pointer-events: auto;
  width: 44px;
  height: 44px;
  border-radius: 50%;
  border: 1px solid #475569;
  background: rgba(30, 41, 59, 0.9);
  backdrop-filter: blur(8px);
  color: #94a3b8;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  transition: all 0.2s;
  font-size: 1.2rem;
  }
  .floater:hover { background: rgba(51, 65, 85, 1); color: white; transform: translateY(-2px); }
  .floater.active { color: #60a5fa; border-color: #60a5fa; background: rgba(2, 6, 23, 1); }
  @media (min-width: 901px) { #floatingControls { display: flex !important; } }
  @media (max-width: 900px) {
    .panel.visible ~ #floatingControls { display: none !important; }
    .panel.hidden ~ #floatingControls { display: flex !important; }
  }
  .panel h2 { color: #60a5fa; margin: 1.5rem 0 1rem; font-size: 1.1rem; border-bottom: 1px solid #1e293b; padding-bottom: 0.5rem; }
  .control-group { margin-bottom: 1.2rem; }
  label { display: block; font-size: 0.9rem; color: #e5e7eb; margin-bottom: 0.4rem; }
  input, select, button { width: 100%; padding: 0.5rem; border-radius: 0.375rem; border: 1px solid #1f2937; background: #020617; color: #e5e7eb; font: inherit; }
  input[type="range"] { padding: 0.3rem 0; accent-color: #60a5fa; }
  input[type="color"] { height: 44px; padding: 0.2rem; }
  button { background: #60a5fa; border: none; color: white; cursor: pointer; margin-top: 0.8rem; font-weight: 600; transition: background 0.2s; }
  button:hover { background: #3b82f6; }
  button:disabled { background: #475569; cursor: not-allowed; }
  #layersList { list-style: none; padding: 0; margin: 0 0 1rem; }
  .layer-item {
  display: flex; align-items: center; gap: 8px; padding: 10px; background: #0f172a; border-radius: 8px; margin-bottom: 8px; cursor: pointer; border: 1px solid transparent;
  }
  .layer-item.active { background: #1e293b; border-color: #60a5fa; }
  .layer-item.group { background: #162032; }
  .layer-item.group > .layer-name::before { content: "\ud83d\udcc1 "; }
  .layer-visibility { font-size: 1.3rem; cursor: pointer; width: 24px; text-align: center; }
  .layer-name { flex: 1; font-size: 0.95rem; }
  .layer-delete { color: #ef4444; cursor: pointer; font-size: 1.2rem; width: 24px; text-align: center; }
  .layer-toggle { cursor: pointer; font-size: 1rem; width: 20px; }
  .hint { font-size: 0.75rem; color: #94a3b8; margin-top: 0.25rem; }
  #loader {
  position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
  color: #60a5fa; font-size: 1.5rem; font-weight: bold; pointer-events: none; z-index: 0;
  text-shadow: 0 2px 10px rgba(0,0,0,0.5);
  }
  .transform-controls { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 1rem; }
  .transform-input label { font-size: 0.75rem; color: #94a3b8; margin: 0; }
  .object-info { background: #0f172a; padding: 10px; border-radius: 8px; margin-bottom: 1rem; border: 1px solid #1e293b; }
  .object-info h3 { margin: 0 0 8px; font-size: 0.95rem; color: #60a5fa; }
  .site-footer { position: fixed; bottom: 0; left: 0; right: 0; background: rgba(2,6,23,0.95); border-top: 1px solid #1e293b; padding: 1rem; z-index: 1000; backdrop-filter: blur(10px); }
  .footer-inner { max-width: 1200px; margin: 0 auto; display: flex; justify-content: space-between; flex-wrap: wrap; gap: 1.5rem; font-size: 0.85rem; }
  .footer-nav a { color: #cbd5e1; text-decoration: none; }
  .footer-nav a:hover { color: #60a5fa; }
  </style>
</head>
<body>
<header class="site-header">
  <div class="header-inner">
  <div class="header-left">
  <div class="logo"><a href="index.html">BowesProduct</a></div>
  <nav class="main-nav">
  <a href="index.html">Home</a>
  <a href="models.html">Models</a>
  <a href="retexture.html">Retexture</a>
    <a href="editor.html">Editor</a>
    <a href="3d.html" class="active">3D</a>
  </nav>
  </div>
  <div class="header-right">
  <img id="profilePic" alt="Profile">
  <div id="levelInfo">
  <div id="levelText"></div>
  <div id="xpOuter"><div id="xpBar"></div></div>
  </div>
  <button id="authBtn" class="login-btn">Login</button>
  </div>
  </div>
</header>
<div id="container">
  <div id="loader">Add objects or upload a model to start</div>
  <canvas id="canvas"></canvas>
  <div id="floatingControls">
    <div class="floater" id="floaterSelect" title="Select Mode">\ud83d\udc46</div>
    <div class="floater" id="floaterMove" title="Move (G)">\u2725</div>
    <div class="floater" id="floaterRotate" title="Rotate (R)">\u21bb</div>
    <div class="floater" id="floaterScale" title="Scale (S)">\u2922</div>
  </div>
  <div class="panel visible" id="panel">
  <button id="panelToggle">\u2190</button>
 
<div style="padding:0.8rem;background:rgba(30,41,59,0.4);border-radius:8px;margin-bottom:1rem;font-size:0.85rem;line-height:1.4;border:1px solid #334155;">
  <strong style="color:#60a5fa">Controls:</strong><br><br>
  • Left click + drag: Rotate view<br>
  • Right click + drag: Pan<br>
  • Scroll: Zoom<br>
  • Click object: Select • Ctrl/Cmd + click: Multi-select<br>
  • G/R/S: Move/Rotate/Scale<br>
  • Delete: Delete • Ctrl+D: Duplicate • Ctrl+Z/Y: Undo/Redo
</div>
  <h2>Add Objects</h2>
  <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-bottom:1rem;">
  <button id="addBox">Box</button>
  <button id="addSphere">Sphere</button>
  <button id="addCylinder">Cylinder</button>
  <button id="addTorus">Torus</button>
  <button id="addCone">Cone</button>
  <button id="addPlane">Plane</button>
  <button id="addIcosahedron">Icosahedron</button>
  <button id="addDodecahedron">Dodecahedron</button>
  <button id="addOctahedron">Octahedron</button>
  <button id="addTetrahedron">Tetrahedron</button>
  <button id="addRing">Ring</button>
  <button id="addTube">Tube</button>
  </div>
  <h2>Group</h2>
  <button id="createGroup">Create Group from Selected</button>
  <button id="ungroup">Ungroup Selected</button>
  <div class="hint">Hold Ctrl/Cmd and click objects to multi-select</div>

  <h2>Model</h2>
  <div class="control-group">
  <label for="uploadModel">Upload GLB/GLTF</label>
  <input type="file" id="uploadModel" accept=".glb,.gltf">
  <div class="hint">Supports GLB/GLTF. Auto-centers model.</div>
  </div>

  <h2>Selected Object(s)</h2>
  <div id="selectedObjectInfo">
  <p style="color:#94a3b8;font-size:0.85rem;">No object selected</p>
  </div>

  <div id="transformControls" style="display:none;">
  <div class="control-group"><label>Position</label><div class="transform-controls">
  <div class="transform-input"><label>X</label><input type="number" id="posX" step="0.1"></div>
  <div class="transform-input"><label>Y</label><input type="number" id="posY" step="0.1"></div>
  <div class="transform-input"><label>Z</label><input type="number" id="posZ" step="0.1"></div>
  </div></div>
  <div class="control-group"><label>Rotation (degrees)</label><div class="transform-controls">
  <div class="transform-input"><label>X</label><input type="number" id="rotX" step="5"></div>
  <div class="transform-input"><label>Y</label><input type="number" id="rotY" step="5"></div>
  <div class="transform-input"><label>Z</label><input type="number" id="rotZ" step="5"></div>
  </div></div>
  <div class="control-group"><label>Scale</label><div class="transform-controls">
  <div class="transform-input"><label>X</label><input type="number" id="scaleX" step="0.1" min="0.01"></div>
  <div class="transform-input"><label>Y</label><input type="number" id="scaleY" step="0.1" min="0.01"></div>
  <div class="transform-input"><label>Z</label><input type="number" id="scaleZ" step="0.1" min="0.01"></div>
  </div></div>
  <button id="duplicateBtn">Duplicate (Ctrl+D)</button>
  <button id="deleteBtn" style="background:#ef4444;">Delete Selected</button>
  </div>

  <h2>Material (applies to single mesh)</h2>
  <div class="control-group">
  <label for="materialColor">Color</label>
  <input type="color" id="materialColor" value="#60a5fa">
  </div>
  <div class="control-group">
  <label for="metallicSlider">Metallic <span id="metallicVal">0.00</span></label>
  <input type="range" id="metallicSlider" min="0" max="1" step="0.01" value="0">
  </div>
  <div class="control-group">
  <label for="roughnessSlider">Roughness <span id="roughnessVal">0.50</span></label>
  <input type="range" id="roughnessSlider" min="0" max="1" step="0.01" value="0.5">
  </div>

  <h2>Layers / Objects</h2>
  <ol id="layersList"></ol>
  <div id="undoRedoGroup">
  <button id="undoBtn" disabled>Undo (Ctrl+Z)</button>
  <button id="redoBtn" disabled>Redo (Ctrl+Y)</button>
  </div>

  <h2>Lighting</h2>
  <div class="control-group">
  <label for="envPreset">Environment</label>
  <select id="envPreset">
  <option value="neutral">Neutral</option>
  <option value="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r182/examples/textures/equirect/royal_esplanade_1k.hdr">Royal Esplanade</option>
  <option value="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r182/examples/textures/equirect/spruit_sunrise_1k.hdr">Sunrise</option>
  <option value="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r182/examples/textures/equirect/moonless_golf_1k.hdr">Night</option>
  </select>
  </div>

  <h2>Export</h2>
  <button id="exportBtn">Export Scene as GLB</button>
  <div id="exportStatus" style="margin-top:0.5rem;font-size:0.8rem;color:#94a3b8;"></div>
  </div>
</div>
<footer class="site-footer">
  <div class="footer-inner">
  <nav class="footer-nav">
  <a href="about.html">About</a>
  <a href="privacy.html">Privacy</a>
  <a href="terms.html">Terms</a>
  <a href="license.html">License</a>
  <a href="refund.html">Refund</a>
  <a href="rewards.html">Rewards</a>
  </nav>
  <p>\u00a9 2026 BowesProduct</p>
  </div>
</footer>
<div id="mobilePanelToggle"><span>\u25b2 Controls</span></div>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
  import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
  import { TransformControls } from 'three/addons/controls/TransformControls.js';

  const canvas = document.getElementById('canvas');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, preserveDrawingBuffer: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x020617);

  const gridHelper = new THREE.GridHelper(20, 20, 0x1e293b, 0x0f172a);
  scene.add(gridHelper);

  scene.add(new THREE.AmbientLight(0xffffff, 0.4));
  const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
  dirLight.position.set(5, 10, 7);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.width = 2048;
  dirLight.shadow.mapSize.height = 2048;
  scene.add(dirLight);

  const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(5, 4, 5);

  const controls = new OrbitControls(camera, canvas);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;

  const transformControl = new TransformControls(camera, renderer.domElement);
  transformControl.addEventListener('dragging-changed', (event) => controls.enabled = !event.value);
  transformControl.addEventListener('change', updateTransformInputs);
  scene.add(transformControl);

  const pmremGenerator = new THREE.PMREMGenerator(renderer);
  pmremGenerator.compileEquirectangularShader();
  let currentEnvMap = null;

  function loadEnvironment(url) {
    if (url === 'neutral') {
      scene.environment = null;
      if (currentEnvMap) currentEnvMap.dispose();
      return;
    }
    new RGBELoader().load(url, (tex) => {
      const envMap = pmremGenerator.fromEquirectangular(tex).texture;
      scene.environment = envMap;
      tex.dispose();
      if (currentEnvMap) currentEnvMap.dispose();
      currentEnvMap = envMap;
    });
  }
  loadEnvironment('neutral');

  // Object & Group Management
  const rootObjects = [];
  let selectedObjects = [];
  let objectCounter = 0;

  // Undo/Redo
  const undoStack = [];
  const redoStack = [];
  const MAX_UNDO = 50;
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');

  function saveState() {
    const state = rootObjects.map(obj => serializeObject(obj));
    undoStack.push(state);
    if (undoStack.length > MAX_UNDO) undoStack.shift();
    redoStack.length = 0;
    undoBtn.disabled = false;
    redoBtn.disabled = true;
    addXP(1);
  }

  function serializeObject(obj) {
    if (obj.isGroup) {
      return {
        type: 'group',
        name: obj.userData.name,
        visible: obj.visible,
        position: obj.position.toArray(),
        rotation: obj.rotation.toArray(),
        scale: obj.scale.toArray(),
        children: obj.children.map(child => serializeObject(child))
      };
    } else if (obj.isMesh) {
      return {
        type: 'mesh',
        name: obj.userData.name,
        geometry: obj.userData.geometryName,
        visible: obj.visible,
        position: obj.position.toArray(),
        rotation: obj.rotation.toArray(),
        scale: obj.scale.toArray(),
        color: obj.material.color.getHex(),
        metallic: obj.material.metalness,
        roughness: obj.material.roughness
      };
    }
    return null;
  }

  function deserializeObject(data, parent = null) {
    let obj;
    if (data.type === 'group') {
      obj = new THREE.Group();
      obj.userData.isGroup = true;
      data.children.forEach(childData => {
        const child = deserializeObject(childData, obj);
        if (child) obj.add(child);
      });
    } else if (data.type === 'mesh') {
      const geometry = createGeometryForName(data.geometry);
      if (!geometry) return null;
      const material = new THREE.MeshStandardMaterial({
        color: data.color,
        metalness: data.metallic,
        roughness: data.roughness
      });
      obj = new THREE.Mesh(geometry, material);
      obj.userData.geometryName = data.geometry;
      obj.castShadow = true;
      obj.receiveShadow = true;
    }
    
    if (obj) {
      obj.userData.name = data.name;
      obj.userData.id = objectCounter++;
      obj.visible = data.visible;
      obj.position.fromArray(data.position);
      obj.rotation.fromArray(data.rotation);
      obj.scale.fromArray(data.scale);
      if (parent) parent.add(obj);
    }
    return obj;
  }

  function restoreState(state) {
    rootObjects.forEach(o => scene.remove(o));
    rootObjects.length = 0;
    state.forEach(data => {
      const obj = deserializeObject(data);
      if (obj) {
        scene.add(obj);
        rootObjects.push(obj);
      }
    });
    selectedObjects = [];
    transformControl.detach();
    updateSelectedObjectUI();
    updateLayersList();
  }

  function undo() {
    if (undoStack.length === 0) return;
    redoStack.push(rootObjects.map(obj => serializeObject(obj)).filter(s => s !== null));
    const state = undoStack.pop();
    restoreState(state);
    undoBtn.disabled = undoStack.length === 0;
    redoBtn.disabled = false;
  }

  function redo() {
    if (redoStack.length === 0) return;
    undoStack.push(rootObjects.map(obj => serializeObject(obj)).filter(s => s !== null));
    const state = redoStack.pop();
    restoreState(state);
    redoBtn.disabled = redoStack.length === 0;
    undoBtn.disabled = false;
  }

  undoBtn.onclick = undo;
  redoBtn.onclick = redo;

  window.addEventListener('keydown', e => {
    if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
    if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); }
    if (e.key === 'g' || e.key === 'G') {
      e.preventDefault();
      transformControl.setMode('translate');
      updateFloaterActiveState();
    }
    if (e.key === 'r' || e.key === 'R') {
      e.preventDefault();
      transformControl.setMode('rotate');
      updateFloaterActiveState();
    }
    if (e.key === 's' || e.key === 'S') {
      if (!(e.ctrlKey || e.metaKey)) {
        e.preventDefault();
        transformControl.setMode('scale');
        updateFloaterActiveState();
      }
    }
    if (e.key === 'Delete' || e.key === 'Backspace') {
      if (document.activeElement.tagName !== 'INPUT') {
        e.preventDefault();
        deleteSelected();
      }
    }
    if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
      e.preventDefault();
      duplicateSelected();
    }
  });

  function createGeometryForName(name) {
    switch(name) {
      case 'Box': return new THREE.BoxGeometry(1, 1, 1);
      case 'Sphere': return new THREE.SphereGeometry(0.5, 32, 32);
      case 'Cylinder': return new THREE.CylinderGeometry(0.5, 0.5, 1, 32);
      case 'Torus': return new THREE.TorusGeometry(0.5, 0.2, 16, 48);
      case 'Cone': return new THREE.ConeGeometry(0.5, 1, 32);
      case 'Plane': return new THREE.PlaneGeometry(1, 1);
      case 'Icosahedron': return new THREE.IcosahedronGeometry(0.6);
      case 'Dodecahedron': return new THREE.DodecahedronGeometry(0.6);
      case 'Octahedron': return new THREE.OctahedronGeometry(0.7);
      case 'Tetrahedron': return new THREE.TetrahedronGeometry(0.7);
      case 'Ring': return new THREE.RingGeometry(0.3, 0.6, 32);
      case 'Tube': return new THREE.TubeGeometry(new THREE.CatmullRomCurve3([
        new THREE.Vector3(-1, 0, 0),
        new THREE.Vector3(-0.5, 1, 0),
        new THREE.Vector3(0.5, -1, 0),
        new THREE.Vector3(1, 0, 0)
      ]), 64, 0.1, 8, false);
      default: return new THREE.BoxGeometry(1, 1, 1);
    }
  }

  function addPrimitive(name) {
    saveState();
    const geometry = createGeometryForName(name);
    const material = new THREE.MeshStandardMaterial({ color: 0x60a5fa, metalness: 0, roughness: 0.5 });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.y = 0.5;
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    mesh.userData.name = name;
    mesh.userData.geometryName = name;
    mesh.userData.id = objectCounter++;
    scene.add(mesh);
    rootObjects.push(mesh);
    selectObject(mesh, false);
    updateLayersList();
    document.getElementById('loader').style.display = 'none';
    addXP(5);
  }

  // Primitive buttons
  document.getElementById('addBox').onclick = () => addPrimitive('Box');
  document.getElementById('addSphere').onclick = () => addPrimitive('Sphere');
  document.getElementById('addCylinder').onclick = () => addPrimitive('Cylinder');
  document.getElementById('addTorus').onclick = () => addPrimitive('Torus');
  document.getElementById('addCone').onclick = () => addPrimitive('Cone');
  document.getElementById('addPlane').onclick = () => addPrimitive('Plane');
  document.getElementById('addIcosahedron').onclick = () => addPrimitive('Icosahedron');
  document.getElementById('addDodecahedron').onclick = () => addPrimitive('Dodecahedron');
  document.getElementById('addOctahedron').onclick = () => addPrimitive('Octahedron');
  document.getElementById('addTetrahedron').onclick = () => addPrimitive('Tetrahedron');
  document.getElementById('addRing').onclick = () => addPrimitive('Ring');
  document.getElementById('addTube').onclick = () => addPrimitive('Tube');

  // Selection
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  function selectObject(object, multi = false) {
    if (!multi) selectedObjects = [];
    if (object) {
      if (!selectedObjects.includes(object)) selectedObjects.push(object);
    }
    updateSelectedObjectUI();
    updateFloaterActiveState();
    updateLayersList();

    if (selectedObjects.length === 1) {
      transformControl.attach(selectedObjects[0]);
    } else {
      transformControl.detach();
    }
  }

  canvas.addEventListener('pointerdown', (e) => {
    if (transformControl.dragging) return;
    const rect = canvas.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const allMeshes = [];
    rootObjects.forEach(obj => obj.traverse(child => { if (child.isMesh) allMeshes.push(child); }));
    const intersects = raycaster.intersectObjects(allMeshes, false);
    if (intersects.length > 0) {
      selectObject(intersects[0].object, e.ctrlKey || e.metaKey);
    } else if (!e.ctrlKey && !e.metaKey) {
      selectedObjects = [];
      transformControl.detach();
      updateSelectedObjectUI();
      updateLayersList();
    }
  });

  function updateSelectedObjectUI() {
    const infoDiv = document.getElementById('selectedObjectInfo');
    const transformDiv = document.getElementById('transformControls');
    if (selectedObjects.length === 0) {
      infoDiv.innerHTML = '<p style="color:#94a3b8;font-size:0.85rem;">No object selected</p>';
      transformDiv.style.display = 'none';
      return;
    }
    let html = `<div class="object-info"><h3>${selectedObjects.length} object${selectedObjects.length > 1 ? 's' : ''} selected</h3>`;
    if (selectedObjects.length === 1) {
      const obj = selectedObjects[0];
      html += `<p>Type: ${obj.userData.name || 'Mesh'}</p><p>ID: ${obj.userData.id}</p>`;
      if (obj.material && obj.material.color) {
        document.getElementById('materialColor').value = '#' + obj.material.color.getHexString();
      }
      if (obj.material) {
        document.getElementById('metallicSlider').value = obj.material.metalness || 0;
        document.getElementById('metallicVal').textContent = (obj.material.metalness || 0).toFixed(2);
        document.getElementById('roughnessSlider').value = obj.material.roughness || 0.5;
        document.getElementById('roughnessVal').textContent = (obj.material.roughness || 0.5).toFixed(2);
      }
    } else {
      html += `<p>Multi-selection active</p>`;
    }
    html += `</div>`;
    infoDiv.innerHTML = html;
    transformDiv.style.display = 'block';
    updateTransformInputs();
  }

  function updateTransformInputs() {
    if (selectedObjects.length === 0) return;
    const obj = selectedObjects[0];
    document.getElementById('posX').value = obj.position.x.toFixed(2);
    document.getElementById('posY').value = obj.position.y.toFixed(2);
    document.getElementById('posZ').value = obj.position.z.toFixed(2);
    document.getElementById('rotX').value = THREE.MathUtils.radToDeg(obj.rotation.x).toFixed(1);
    document.getElementById('rotY').value = THREE.MathUtils.radToDeg(obj.rotation.y).toFixed(1);
    document.getElementById('rotZ').value = THREE.MathUtils.radToDeg(obj.rotation.z).toFixed(1);
    document.getElementById('scaleX').value = obj.scale.x.toFixed(2);
    document.getElementById('scaleY').value = obj.scale.y.toFixed(2);
    document.getElementById('scaleZ').value = obj.scale.z.toFixed(2);
  }

  function applyTransformToAll() {
    const pos = new THREE.Vector3(
      parseFloat(document.getElementById('posX').value) || 0,
      parseFloat(document.getElementById('posY').value) || 0,
      parseFloat(document.getElementById('posZ').value) || 0
    );
    const rot = new THREE.Euler(
      THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotX').value) || 0),
      THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotY').value) || 0),
      THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotZ').value) || 0)
    );
    const scale = new THREE.Vector3(
      parseFloat(document.getElementById('scaleX').value) || 1,
      parseFloat(document.getElementById('scaleY').value) || 1,
      parseFloat(document.getElementById('scaleZ').value) || 1
    );
    selectedObjects.forEach(obj => {
      obj.position.copy(pos);
      obj.rotation.copy(rot);
      obj.scale.copy(scale);
    });
  }

  ['posX','posY','posZ','rotX','rotY','rotZ','scaleX','scaleY','scaleZ'].forEach(id => {
    document.getElementById(id).addEventListener('change', () => {
      saveState();
      applyTransformToAll();
    });
  });

  document.getElementById('materialColor').addEventListener('input', (e) => {
    if (selectedObjects.length === 1 && selectedObjects[0].isMesh && selectedObjects[0].material) {
      selectedObjects[0].material.color.set(e.target.value);
      addXP(1);
    }
  });

  document.getElementById('metallicSlider').addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    document.getElementById('metallicVal').textContent = v.toFixed(2);
    if (selectedObjects.length === 1 && selectedObjects[0].isMesh && selectedObjects[0].material) {
      selectedObjects[0].material.metalness = v;
      addXP(1);
    }
  });

  document.getElementById('roughnessSlider').addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    document.getElementById('roughnessVal').textContent = v.toFixed(2);
    if (selectedObjects.length === 1 && selectedObjects[0].isMesh && selectedObjects[0].material) {
      selectedObjects[0].material.roughness = v;
      addXP(1);
    }
  });

  function duplicateSelected() {
    if (selectedObjects.length === 0) return;
    saveState();
    const clones = [];
    selectedObjects.forEach(obj => {
      const clone = obj.clone();
      if (obj.isMesh && obj.material) clone.material = obj.material.clone();
      clone.position.x += 1;
      clone.userData.id = objectCounter++;
      clone.userData.name = obj.userData.name + ' (copy)';
      scene.add(clone);
      rootObjects.push(clone);
      clones.push(clone);
    });
    selectedObjects = clones;
    transformControl.attach(selectedObjects[0]);
    updateLayersList();
    updateSelectedObjectUI();
    addXP(3);
  }

  function deleteSelected() {
    if (selectedObjects.length === 0) return;
    saveState();
    
    // Get all selected objects to delete
    const objectsToDelete = [...selectedObjects];
    
    objectsToDelete.forEach(obj => {
      // Find if object is in a group
      let parent = obj.parent;
      if (parent && parent.isGroup) {
        parent.remove(obj);
        // If group is now empty, remove it
        if (parent.children.length === 0) {
          scene.remove(parent);
          const idx = rootObjects.indexOf(parent);
          if (idx > -1) rootObjects.splice(idx, 1);
        }
      } else {
        scene.remove(obj);
        const idx = rootObjects.indexOf(obj);
        if (idx > -1) rootObjects.splice(idx, 1);
      }
    });
    
    selectedObjects = [];
    transformControl.detach();
    updateLayersList();
    updateSelectedObjectUI();
    addXP(2);
  }

  document.getElementById('duplicateBtn').onclick = duplicateSelected;
  document.getElementById('deleteBtn').onclick = deleteSelected;

  // Grouping
  document.getElementById('createGroup').onclick = () => {
    if (selectedObjects.length < 2) return;
    saveState();
    const group = new THREE.Group();
    group.userData.isGroup = true;
    group.userData.name = `Group ${rootObjects.filter(o => o.userData.isGroup).length + 1}`;
    group.userData.id = objectCounter++;

    // Calculate center of selected objects
    const center = new THREE.Vector3();
    selectedObjects.forEach(obj => center.add(obj.position));
    center.divideScalar(selectedObjects.length);

    selectedObjects.forEach(obj => {
      const worldPos = new THREE.Vector3();
      obj.getWorldPosition(worldPos);
      obj.parent.remove(obj);
      group.add(obj);
      obj.position.copy(worldPos).sub(center);
    });

    group.position.copy(center);
    scene.add(group);
    rootObjects.push(group);
    
    // Remove individual objects from rootObjects
    selectedObjects.forEach(obj => {
      const idx = rootObjects.indexOf(obj);
      if (idx > -1) rootObjects.splice(idx, 1);
    });
    
    selectedObjects = [group];
    transformControl.attach(group);
    updateLayersList();
    updateSelectedObjectUI();
    addXP(5);
  };

  document.getElementById('ungroup').onclick = () => {
    const groupsToUngroup = selectedObjects.filter(o => o.isGroup);
    if (groupsToUngroup.length === 0) return;
    saveState();
    
    groupsToUngroup.forEach(group => {
      const children = [...group.children];
      children.forEach(child => {
        const worldPos = new THREE.Vector3();
        child.getWorldPosition(worldPos);
        group.remove(child);
        scene.add(child);
        child.position.copy(worldPos);
        rootObjects.push(child);
      });
      scene.remove(group);
      const idx = rootObjects.indexOf(group);
      if (idx > -1) rootObjects.splice(idx, 1);
    });
    selectedObjects = [];
    transformControl.detach();
    updateLayersList();
    updateSelectedObjectUI();
    addXP(3);
  };

  // Layers List
  function updateLayersList() {
    const list = document.getElementById('layersList');
    list.innerHTML = '';
    rootObjects.slice().reverse().forEach(obj => {
      if (obj) addLayerItem(obj, list);
    });
  }

  function addLayerItem(obj, parentList) {
    const li = document.createElement('li');
    li.className = 'layer-item' + (selectedObjects.includes(obj) ? ' active' : '') + (obj.userData.isGroup ? ' group' : '');
    li.innerHTML = `
      <span class="layer-toggle">${obj.userData.isGroup ? '\u25bc' : ''}</span>
      <span class="layer-visibility">${obj.visible ? '\ud83d\udc41' : '\ud83d\udeab'}</span>
      <span class="layer-name">${obj.userData.name || 'Object'}</span>
      <span class="layer-delete">\u00d7</span>
    `;
    parentList.appendChild(li);

    li.querySelector('.layer-visibility').onclick = (e) => {
      e.stopPropagation();
      obj.visible = !obj.visible;
      li.querySelector('.layer-visibility').textContent = obj.visible ? '\ud83d\udc41' : '\ud83d\udeab';
      obj.traverse(child => child.visible = obj.visible);
      saveState();
    };

    li.querySelector('.layer-delete').onclick = (e) => {
      e.stopPropagation();
      saveState();
      
      if (obj.parent && obj.parent.isGroup) {
        obj.parent.remove(obj);
      } else {
        scene.remove(obj);
        const idx = rootObjects.indexOf(obj);
        if (idx > -1) rootObjects.splice(idx, 1);
      }
      
      selectedObjects = selectedObjects.filter(o => o !== obj);
      transformControl.detach();
      updateLayersList();
      updateSelectedObjectUI();
      addXP(2);
    };

    li.onclick = (e) => {
      if (e.target.classList.contains('layer-delete') || e.target.classList.contains('layer-visibility') || e.target.classList.contains('layer-toggle')) return;
      selectObject(obj, e.ctrlKey || e.metaKey);
    };

    if (obj.userData.isGroup) {
      const childList = document.createElement('ol');
      childList.style.marginLeft = '20px';
      childList.style.display = 'block';
      obj.children.forEach(child => addLayerItem(child, childList));
      li.appendChild(childList);
      li.querySelector('.layer-toggle').onclick = (e) => {
        e.stopPropagation();
        childList.style.display = childList.style.display === 'none' ? 'block' : 'none';
        li.querySelector('.layer-toggle').textContent = childList.style.display === 'none' ? '\u25b6' : '\u25bc';
      };
    }
  }

  // Model Import
  const gltfLoader = new GLTFLoader();
  
  document.getElementById('uploadModel').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const url = URL.createObjectURL(file);
    loadModel(url);
  });

  function loadModel(url) {
    document.getElementById('loader').style.display = 'block';
    document.getElementById('loader').textContent = 'Loading model...';
    
    gltfLoader.load(url, (gltf) => {
      const model = gltf.scene;
      
      // Auto-center model
      const box = new THREE.Box3().setFromObject(model);
      const center = box.getCenter(new THREE.Vector3());
      model.position.sub(center);
      
      // Enable shadows for all meshes
      model.traverse((child) => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
          child.userData.name = child.name || 'Imported Model';
          child.userData.id = objectCounter++;
        }
      });
      
      model.userData.name = 'Imported Model';
      model.userData.id = objectCounter++;
      
      scene.add(model);
      rootObjects.push(model);
      selectObject(model, false);
      updateLayersList();
      
      document.getElementById('loader').style.display = 'none';
      saveState();
      addXP(10);
    }, 
    (progress) => {
      const percent = (progress.loaded / progress.total * 100).toFixed(0);
      document.getElementById('loader').textContent = `Loading... ${percent}%`;
    },
    (error) => {
      console.error('Error loading model:', error);
      document.getElementById('loader').textContent = 'Error loading model';
      setTimeout(() => {
        document.getElementById('loader').style.display = 'none';
      }, 2000);
    });
  }

  // Drag & drop import
  window.addEventListener('dragover', e => e.preventDefault());
  window.addEventListener('drop', e => {
    e.preventDefault();
    const file = e.dataTransfer.files[0];
    if (file && (file.name.endsWith('.glb') || file.name.endsWith('.gltf'))) {
      const url = URL.createObjectURL(file);
      loadModel(url);
    }
  });

  // Environment
  document.getElementById('envPreset').addEventListener('change', (e) => {
    loadEnvironment(e.target.value);
    addXP(1);
  });

  // Export
  const exportStatus = document.getElementById('exportStatus');
  document.getElementById('exportBtn').onclick = () => {
    if (rootObjects.length === 0) {
      exportStatus.textContent = 'No objects to export';
      exportStatus.style.color = '#ef4444';
      return;
    }
    exportStatus.textContent = 'Exporting...';
    exportStatus.style.color = '#60a5fa';
    
    const exporter = new GLTFExporter();
    const exportScene = new THREE.Scene();
    
    // Add only our objects (not helpers, lights, etc.)
    rootObjects.forEach(obj => {
      exportScene.add(obj.clone());
    });
    
    exporter.parse(exportScene, (result) => {
      const blob = new Blob([result], { type: 'application/octet-stream' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = 'scene.glb';
      link.click();
      exportStatus.textContent = 'Exported!';
      exportStatus.style.color = '#4ade80';
      addXP(5);
    }, { binary: true });
  };

  // Floating controls
  const floaterSelect = document.getElementById('floaterSelect');
  const floaterMove = document.getElementById('floaterMove');
  const floaterRotate = document.getElementById('floaterRotate');
  const floaterScale = document.getElementById('floaterScale');

  function updateFloaterActiveState() {
    floaterSelect.classList.remove('active');
    floaterMove.classList.remove('active');
    floaterRotate.classList.remove('active');
    floaterScale.classList.remove('active');
    
    const mode = transformControl.getMode();
    if (mode === 'translate') floaterMove.classList.add('active');
    else if (mode === 'rotate') floaterRotate.classList.add('active');
    else if (mode === 'scale') floaterScale.classList.add('active');
    else floaterSelect.classList.add('active');
  }

  floaterSelect.onclick = () => {
    transformControl.detach();
    updateFloaterActiveState();
  };

  floaterMove.onclick = () => {
    if (selectedObjects.length === 1) {
      transformControl.attach(selectedObjects[0]);
      transformControl.setMode('translate');
      updateFloaterActiveState();
    }
  };

  floaterRotate.onclick = () => {
    if (selectedObjects.length === 1) {
      transformControl.attach(selectedObjects[0]);
      transformControl.setMode('rotate');
      updateFloaterActiveState();
    }
  };

  floaterScale.onclick = () => {
    if (selectedObjects.length === 1) {
      transformControl.attach(selectedObjects[0]);
      transformControl.setMode('scale');
      updateFloaterActiveState();
    }
  };

  // Panel toggle
  const panel = document.getElementById('panel');
  const panelToggle = document.getElementById('panelToggle');
  const mobilePanelToggle = document.getElementById('mobilePanelToggle');
  let panelVisible = true;
  
  function togglePanel() {
    panelVisible = !panelVisible;
    panel.classList.toggle('hidden', !panelVisible);
    panel.classList.toggle('visible', panelVisible);
    panelToggle.textContent = panelVisible ? '\u2190' : '\u2192';
    const span = mobilePanelToggle.querySelector('span');
    if (span) span.textContent = panelVisible ? '\u25bc Hide Controls' : '\u25b2 Controls';
  }
  
  panelToggle.onclick = togglePanel;
  mobilePanelToggle.onclick = togglePanel;

  // Window resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Animation loop
  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  // ============================================
  // XP / Level / Login System (No Firebase)
  // ============================================
  
  const authBtn = document.getElementById('authBtn');
  const profilePic = document.getElementById('profilePic');
  const levelInfo = document.getElementById('levelInfo');
  const levelText = document.getElementById('levelText');
  const xpBar = document.getElementById('xpBar');
  
  let user = null;
  let xp = 0;
  let level = 1;
  const xpPerLevel = 100;
  
  // Load from localStorage
  function loadUserData() {
    const savedUser = localStorage.getItem('modelerPro_user');
    const savedXP = localStorage.getItem('modelerPro_xp');
    const savedLevel = localStorage.getItem('modelerPro_level');
    
    if (savedUser) {
      user = JSON.parse(savedUser);
      xp = parseInt(savedXP) || 0;
      level = parseInt(savedLevel) || 1;
      updateAuthUI();
    }
  }
  
  function saveUserData() {
    localStorage.setItem('modelerPro_user', JSON.stringify(user));
    localStorage.setItem('modelerPro_xp', xp.toString());
    localStorage.setItem('modelerPro_level', level.toString());
  }
  
  function addXP(amount) {
    if (!user) return;
    
    xp += amount;
    const newLevel = Math.floor(xp / xpPerLevel) + 1;
    
    if (newLevel > level) {
      level = newLevel;
      showLevelUpNotification();
    }
    
    updateXPBar();
    saveUserData();
  }
  
  function updateXPBar() {
    const xpInCurrentLevel = xp % xpPerLevel;
    const percentage = (xpInCurrentLevel / xpPerLevel) * 100;
    xpBar.style.width = percentage + '%';
    levelText.textContent = `Level ${level} - ${xpInCurrentLevel}/${xpPerLevel} XP`;
  }
  
  function showLevelUpNotification() {
    const notification = document.createElement('div');
    notification.style.cssText = `
      position: fixed;
      top: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #60a5fa, #3b82f6);
      color: white;
      padding: 1rem 2rem;
      border-radius: 12px;
      font-weight: bold;
      font-size: 1.2rem;
      z-index: 9999;
      animation: levelUp 2s ease-out forwards;
      box-shadow: 0 10px 30px rgba(96, 165, 250, 0.4);
    `;
    notification.textContent = `\ud83c\udf89 Level Up! You are now Level ${level}!`;
    document.body.appendChild(notification);
    
    setTimeout(() => {
      notification.remove();
    }, 2000);
  }
  
  // Add animation keyframes
  const style = document.createElement('style');
  style.textContent = `
    @keyframes levelUp {
      0% { opacity: 0; transform: translateX(-50%) translateY(20px); }
      15% { opacity: 1; transform: translateX(-50%) translateY(0); }
      85% { opacity: 1; transform: translateX(-50%) translateY(0); }
      100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
    }
  `;
  document.head.appendChild(style);
  
  function updateAuthUI() {
    if (user) {
      authBtn.textContent = 'Logout';
      profilePic.style.display = 'block';
      profilePic.src = user.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(user.displayName)}&background=60a5fa&color=fff`;
      levelInfo.style.display = 'block';
      updateXPBar();
    } else {
      authBtn.textContent = 'Login';
      profilePic.style.display = 'none';
      levelInfo.style.display = 'none';
    }
  }
  
  function handleLogin() {
    if (user) {
      // Logout
      user = null;
      xp = 0;
      level = 1;
      localStorage.removeItem('modelerPro_user');
      localStorage.removeItem('modelerPro_xp');
      localStorage.removeItem('modelerPro_level');
      updateAuthUI();
    } else {
      // Simple demo login (in production, use OAuth providers)
      const displayName = prompt('Enter your name:', 'Creator');
      if (displayName) {
        user = {
          displayName: displayName,
          photoURL: null,
          email: `${displayName.toLowerCase().replace(/\s/g, '')}@example.com`
        };
        xp = 0;
        level = 1;
        saveUserData();
        updateAuthUI();
        addXP(10); // Bonus XP for logging in
      }
    }
  }
  
  authBtn.onclick = handleLogin;
  
  // Initialize
  loadUserData();
  updateFloaterActiveState();
</script>
</body>
</html>

