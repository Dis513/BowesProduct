<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Modeler Pro ‚Äì BowesProduct</title>
  <script async src="https://unpkg.com/es-module-shims@1.8.2/dist/es-module-shims.js"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
    }
  }
  </script>
  <style>
  *, *::before, *::after { box-sizing: border-box; }
  html, body { margin: 0; height: 100%; background: #020617; color: white; font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif; overflow: hidden; -webkit-font-smoothing: antialiased; }
  .site-header {
  position: sticky; top: 0; z-index: 1000; background: rgba(2,6,23,0.95); border-bottom: 1px solid #1e293b; backdrop-filter: blur(10px);
  }
  .header-inner { max-width: 1200px; margin: 0 auto; padding: 0.6rem 1rem; display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 0.5rem; }
  .header-left { display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; }
  .logo a { font-size: 1.3rem; font-weight: 700; color: white; text-decoration: none; white-space: nowrap; }
  .main-nav { display: flex; gap: 1rem; flex-wrap: wrap; }
  .main-nav a { color: #e5e7eb; text-decoration: none; font-size: 0.9rem; white-space: nowrap; }
  .main-nav a:hover, .main-nav a.active { color: #60a5fa; }
  .header-right { display: flex; align-items: center; gap: 0.8rem; min-height: 44px; flex-wrap: wrap; }
  #profilePic { width: 32px; height: 32px; border-radius: 50%; border: 2px solid #60a5fa; object-fit: cover; display: none; }
  .login-btn { padding: 0.45rem 1.1rem; border-radius: 999px; border: 1.5px solid #60a5fa; background: transparent; color: #60a5fa; font-size: 0.95rem; cursor: pointer; }
  #levelInfo { display: none; font-size: 0.8rem; color: #cbd5e1; }
  #levelText { white-space: nowrap; font-size: 0.75rem; }
  #xpOuter { width: 100px; height: 5px; background: #1e293b; border-radius: 3px; margin-top: 4px; }
  #xpBar { height: 100%; width: 0%; background: #60a5fa; border-radius: 3px; transition: width 0.35s ease; }
  @media (max-width: 900px) {
  .header-inner { padding: 0.5rem; }
  .header-left { width: 100%; justify-content: space-between; }
  .main-nav { gap: 0.8rem; order: 3; width: 100%; }
  .main-nav a { font-size: 0.85rem; }
  .header-right { width: 100%; justify-content: space-between; }
  #levelInfo { flex: 1; }
  #xpOuter { width: 100%; }
  }
  #container { position: relative; width: 100%; height: 100%; padding-top: 70px; padding-bottom: 80px; }
  #canvas { display: block; width: 100%; height: 100%; touch-action: none; outline: none; }
  .panel {
  position: absolute;
  top: 90px;
  right: 20px;
  width: 420px;
  max-height: calc(100vh - 220px);
  background: rgba(2, 6, 23, 0.95);
  border: 1px solid #1e293b;
  border-radius: 12px;
  padding: 1.5rem;
  overflow-y: auto;
  z-index: 20;
  backdrop-filter: blur(10px);
  transition: transform 0.3s ease;
  box-shadow: 0 10px 25px rgba(0,0,0,0.3);
  }
  .panel.hidden { transform: translateX(460px); }
  .panel::-webkit-scrollbar { width: 6px; }
  .panel::-webkit-scrollbar-track { background: #0f172a; }
  .panel::-webkit-scrollbar-thumb { background: #334155; border-radius: 3px; }
  #panelToggle {
  position: absolute;
  left: -60px;
  top: 50%;
  transform: translateY(-50%);
  width: 60px;
  height: 110px;
  background: rgba(2, 6, 23, 0.98);
  border: 1px solid #1e293b;
  border-right: none;
  border-radius: 20px 0 0 20px;
  color: #60a5fa;
  font-size: 2.4rem;
  font-weight: bold;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 21;
  backdrop-filter: blur(12px);
  box-shadow: 0 6px 30px rgba(0,0,0,0.5);
  transition: all 0.3s ease;
  }
  #panelToggle:hover { background: rgba(30, 41, 59, 0.98); color: white; transform: translateY(-50%) translateX(-4px); }
  @media (max-width: 900px) {
  .panel {
  position: absolute;
  top: auto;
  right: 0;
  left: 0;
  bottom: 0;
  width: 100%;
  height: 85vh;
  max-height: none;
  border-radius: 20px 20px 0 0;
  transform: translateY(calc(100% - 60px));
  transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1);
  padding-top: 20px;
  padding-bottom: 120px;
  z-index: 1100;
  overflow-y: auto;
  background: rgba(2, 6, 23, 0.95);
  border: 1px solid #1e293b;
  border-bottom: none;
  box-shadow: 0 -5px 25px rgba(0,0,0,0.5);
  }
  .panel.visible { transform: translateY(0); }
  #panelToggle { display: none; }
  }
  #mobilePanelToggle {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 140px;
  height: 44px;
  background: rgba(2, 6, 23, 0.9);
  border: 1px solid #60a5fa;
  border-radius: 22px;
  color: #60a5fa;
  font-size: 0.85rem;
  font-weight: 700;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 1200;
  backdrop-filter: blur(12px);
  box-shadow: 0 4px 20px rgba(0,0,0,0.6);
  transition: background 0.2s, transform 0.1s;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  }
  #mobilePanelToggle:active { transform: scale(0.96); }
  #mobilePanelToggle::before {
  content: '';
  position: absolute;
  top: -6px;
  left: 50%;
  transform: translateX(-50%);
  width: 40px;
  height: 4px;
  background: #94a3b8;
  border-radius: 2px;
  opacity: 0.5;
  }
  @media (min-width: 901px) { #mobilePanelToggle { display: none; } }
  @media (max-width: 900px) { #mobilePanelToggle { display: flex; } }
  #floatingControls {
  position: fixed;
  bottom: 20px;
  left: 20px;
  display: flex;
  gap: 10px;
  z-index: 1150;
  pointer-events: none;
  }
  .floater {
  pointer-events: auto;
  width: 44px;
  height: 44px;
  border-radius: 50%;
  border: 1px solid #475569;
  background: rgba(30, 41, 59, 0.9);
  backdrop-filter: blur(8px);
  color: #94a3b8;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  transition: all 0.2s;
  font-size: 1.2rem;
  }
  .floater:hover { background: rgba(51, 65, 85, 1); color: white; transform: translateY(-2px); }
  .floater.active { color: #60a5fa; border-color: #60a5fa; background: rgba(2, 6, 23, 1); }
  @media (min-width: 901px) { #floatingControls { display: flex !important; } }
  @media (max-width: 900px) {
    .panel.visible ~ #floatingControls { display: none !important; }
    .panel.hidden ~ #floatingControls { display: flex !important; }
  }
  .panel h2 { color: #60a5fa; margin: 1.5rem 0 1rem; font-size: 1.1rem; border-bottom: 1px solid #1e293b; padding-bottom: 0.5rem; }
  .control-group { margin-bottom: 1.2rem; }
  label { display: block; font-size: 0.9rem; color: #e5e7eb; margin-bottom: 0.4rem; }
  input, select, button { width: 100%; padding: 0.5rem; border-radius: 0.375rem; border: 1px solid #1f2937; background: #020617; color: #e5e7eb; font: inherit; }
  input[type="range"] { padding: 0.3rem 0; accent-color: #60a5fa; }
  input[type="color"] { height: 44px; padding: 0.2rem; }
  button { background: #60a5fa; border: none; color: white; cursor: pointer; margin-top: 0.8rem; font-weight: 600; transition: background 0.2s; }
  button:hover { background: #3b82f6; }
  button:disabled { background: #475569; cursor: not-allowed; }
  button.mode-btn { margin-top: 0.2rem; padding: 0.4rem 0.6rem; font-size: 0.85rem; }
  button.mode-btn.active { background: #22c55e; border-color: #22c55e; }
  button.mode-btn.sculpt-active { background: #f59e0b; border-color: #f59e0b; }
  #layersList { list-style: none; padding: 0; margin: 0 0 1rem; }
  .layer-item {
  display: flex; align-items: center; gap: 8px; padding: 10px; background: #0f172a; border-radius: 8px; margin-bottom: 8px; cursor: pointer; border: 1px solid transparent;
  }
  .layer-item.active { background: #1e293b; border-color: #60a5fa; }
  .layer-item.group { background: #162032; }
  .layer-item.group > .layer-name::before { content: "üìÅ "; }
  .layer-visibility { font-size: 1.3rem; cursor: pointer; width: 24px; text-align: center; }
  .layer-name { flex: 1; font-size: 0.95rem; }
  .layer-delete { color: #ef4444; cursor: pointer; font-size: 1.2rem; width: 24px; text-align: center; }
  .layer-toggle { cursor: pointer; font-size: 1rem; width: 20px; }
  .hint { font-size: 0.75rem; color: #94a3b8; margin-top: 0.25rem; }
  #loader {
  position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
  color: #60a5fa; font-size: 1.5rem; font-weight: bold; pointer-events: none; z-index: 0;
  text-shadow: 0 2px 10px rgba(0,0,0,0.5);
  }
  .transform-controls { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 1rem; }
  .transform-input label { font-size: 0.75rem; color: #94a3b8; margin: 0; }
  .object-info { background: #0f172a; padding: 10px; border-radius: 8px; margin-bottom: 1rem; border: 1px solid #1e293b; }
  .object-info h3 { margin: 0 0 8px; font-size: 0.95rem; color: #60a5fa; }
  .site-footer { position: fixed; bottom: 0; left: 0; right: 0; background: rgba(2,6,23,0.95); border-top: 1px solid #1e293b; padding: 1rem; z-index: 1000; backdrop-filter: blur(10px); }
  .footer-inner { max-width: 1200px; margin: 0 auto; display: flex; justify-content: space-between; flex-wrap: wrap; gap: 1.5rem; font-size: 0.85rem; }
  .footer-nav a { color: #cbd5e1; text-decoration: none; }
  .footer-nav a:hover { color: #60a5fa; }
  #sculptingControls { display: none; }
  #sculptingControls.visible { display: block; }
  .sculpt-tool-btn { width: auto; display: inline-block; margin: 2px; font-size: 0.8rem; }
  .sculpt-row { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 0.8rem; }
  . sculpt-row button { flex: 1; min-width: 60px; }
  </style>
  <script src="https://sites.super.myninja.ai/_assets/ninja-daytona-script.js"></script>
</head>
<body>
<header class="site-header">
  <div class="header-inner">
  <div class="header-left">
  <div class="logo"><a href="index.html">BowesProduct</a></div>
  <nav class="main-nav">
  <a href="index.html">Home</a>
  <a href="models.html">Models</a>
  <a href="retexture.html">Retexture</a>
    <a href="editor.html">Editor</a>
    <a href="3d.html" class="active">3D</a>
  </nav>
  </div>
  <div class="header-right">
  <img id="profilePic" alt="Profile">
  <div id="levelInfo">
  <div id="levelText"></div>
  <div id="xpOuter"><div id="xpBar"></div></div>
  </div>
  <button id="authBtn" class="login-btn">Login</button>
  </div>
  </div>
</header>
<div id="container">
  <div id="loader">Add objects or upload a model to start</div>
  <canvas id="canvas"></canvas>
  <div id="floatingControls">
    <div class="floater" id="floaterSelect" title="Select Mode (Q)">üëÜ</div>
    <div class="floater" id="floaterMove" title="Move (G)">‚ú•</div>
    <div class="floater" id="floaterRotate" title="Rotate (R)">‚Üª</div>
    <div class="floater" id="floaterScale" title="Scale (S)">‚§¢</div>
    <div class="floater" id="floaterSculpt" title="Sculpt Mode (E)">üé®</div>
  </div>
  <div class="panel visible" id="panel">
  <button id="panelToggle">‚Üê</button>
 
  <div style="padding:0.8rem;background:rgba(30,41,59,0.4);border-radius:8px;margin-bottom:1rem;font-size:0.85rem;line-height:1.4;border:1px solid #334155;">
  <strong style="color:#60a5fa">Controls:</strong><br>
  ‚Ä¢ Q: Select Mode ‚Ä¢ G: Move ‚Ä¢ R: Rotate ‚Ä¢ S: Scale ‚Ä¢ E: Sculpt<br>
  ‚Ä¢ Left click + drag: Rotate view<br>
  ‚Ä¢ Right click + drag: Pan<br>
  ‚Ä¢ Scroll: Zoom<br>
  ‚Ä¢ Click object: Select ‚Ä¢ Ctrl/Cmd + click: Multi-select<br>
  ‚Ä¢ Delete: Delete ‚Ä¢ Ctrl+D: Duplicate ‚Ä¢ Ctrl+Z/Y: Undo/Redo
  </div>
  <h2>Mode</h2>
  <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:6px;margin-bottom:1rem;">
    <button id="modeSelect" class="mode-btn active">Select (Q)</button>
    <button id="modeMove" class="mode-btn">Move (G)</button>
    <button id="modeRotate" class="mode-btn">Rotate (R)</button>
    <button id="modeScale" class="mode-btn">Scale (S)</button>
    <button id="modeSculpt" class="mode-btn">Sculpt (E)</button>
  </div>

  <h2 id="sculptingHeader" style="display:none;">Sculpting Tools</h2>
  <div id="sculptingControls">
    <div class="sculpt-row">
      <button id="sculptBrush" class="sculpt-tool-btn active">Brush</button>
      <button id="sculptInflate" class="sculpt-tool-btn">Inflate</button>
      <button id="sculptDeflate" class="sculpt-tool-btn">Deflate</button>
      <button id="sculptSmooth" class="sculpt-tool-btn">Smooth</button>
      <button id="sculptFlatten" class="sculpt-tool-btn">Flatten</button>
    </div>
    <div class="control-group">
      <label for="brushSize">Brush Size: <span id="brushSizeVal">0.5</span></label>
      <input type="range" id="brushSize" min="0.1" max="2" step="0.1" value="0.5">
    </div>
    <div class="control-group">
      <label for="brushStrength">Brush Strength: <span id="brushStrengthVal">0.5</span></label>
      <input type="range" id="brushStrength" min="0.1" max="2" step="0.1" value="0.5">
    </div>
    <div class="hint">Click and drag on mesh to sculpt. Hold Shift to invert.</div>
  </div>

  <h2>Add Objects</h2>
  <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-bottom:1rem;">
  <button id="addBox">Box</button>
  <button id="addSphere">Sphere</button>
  <button id="addCylinder">Cylinder</button>
  <button id="addTorus">Torus</button>
  <button id="addCone">Cone</button>
  <button id="addPlane">Plane</button>
  <button id="addIcosahedron">Icosahedron</button>
  <button id="addDodecahedron">Dodecahedron</button>
  <button id="addOctahedron">Octahedron</button>
  <button id="addTetrahedron">Tetrahedron</button>
  <button id="addRing">Ring</button>
  <button id="addTube">Tube</button>
  </div>
  <h2>Group</h2>
  <button id="createGroup">Create Group from Selected</button>
  <button id="ungroup">Ungroup Selected</button>
  <div class="hint">Hold Ctrl/Cmd and click objects to multi-select</div>

  <h2>Model</h2>
  <div class="control-group">
  <label for="uploadModel">Upload GLB/GLTF</label>
  <input type="file" id="uploadModel" accept=".glb,.gltf">
  <div class="hint">Supports GLB/GLTF. Auto-centers model.</div>
  </div>

  <h2>Selected Object(s)</h2>
  <div id="selectedObjectInfo">
  <p style="color:#94a3b8;font-size:0.85rem;">No object selected</p>
  </div>

  <div id="transformControls" style="display:none;">
  <div class="control-group"><label>Position</label><div class="transform-controls">
  <div class="transform-input"><label>X</label><input type="number" id="posX" step="0.1"></div>
  <div class="transform-input"><label>Y</label><input type="number" id="posY" step="0.1"></div>
  <div class="transform-input"><label>Z</label><input type="number" id="posZ" step="0.1"></div>
  </div></div>
  <div class="control-group"><label>Rotation (degrees)</label><div class="transform-controls">
  <div class="transform-input"><label>X</label><input type="number" id="rotX" step="5"></div>
  <div class="transform-input"><label>Y</label><input type="number" id="rotY" step="5"></div>
  <div class="transform-input"><label>Z</label><input type="number" id="rotZ" step="5"></div>
  </div></div>
  <div class="control-group"><label>Scale</label><div class="transform-controls">
  <div class="transform-input"><label>X</label><input type="number" id="scaleX" step="0.1" min="0.01"></div>
  <div class="transform-input"><label>Y</label><input type="number" id="scaleY" step="0.1" min="0.01"></div>
  <div class="transform-input"><label>Z</label><input type="number" id="scaleZ" step="0.1" min="0.01"></div>
  </div></div>
  <button id="duplicateBtn">Duplicate (Ctrl+D)</button>
  <button id="deleteBtn" style="background:#ef4444;">Delete Selected</button>
  </div>

  <h2>Material (applies to single mesh)</h2>
  <div class="control-group">
  <label for="materialColor">Color</label>
  <input type="color" id="materialColor" value="#60a5fa">
  </div>
  <div class="control-group">
  <label for="metallicSlider">Metallic <span id="metallicVal">0.00</span></label>
  <input type="range" id="metallicSlider" min="0" max="1" step="0.01" value="0">
  </div>
  <div class="control-group">
  <label for="roughnessSlider">Roughness <span id="roughnessVal">0.50</span></label>
  <input type="range" id="roughnessSlider" min="0" max="1" step="0.01" value="0.5">
  </div>

  <h2>Layers / Objects</h2>
  <ol id="layersList"></ol>
  <div id="undoRedoGroup">
  <button id="undoBtn" disabled>Undo (Ctrl+Z)</button>
  <button id="redoBtn" disabled>Redo (Ctrl+Y)</button>
  </div>

  <h2>Lighting</h2>
  <div class="control-group">
  <label for="envPreset">Environment</label>
  <select id="envPreset">
  <option value="neutral">Neutral</option>
  <option value="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r182/examples/textures/equirect/royal_esplanade_1k.hdr">Royal Esplanade</option>
  <option value="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r182/examples/textures/equirect/spruit_sunrise_1k.hdr">Sunrise</option>
  <option value="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r182/examples/textures/equirect/moonless_golf_1k.hdr">Night</option>
  </select>
  </div>

  <h2>Export</h2>
  <button id="exportBtn">Export Scene as GLB</button>
  <div id="exportStatus" style="margin-top:0.5rem;font-size:0.8rem;color:#94a3b8;"></div>
  </div>
</div>
<footer class="site-footer">
  <div class="footer-inner">
  <nav class="footer-nav">
  <a href="about.html">About</a>
  <a href="privacy.html">Privacy</a>
  <a href="terms.html">Terms</a>
  <a href="license.html">License</a>
  <a href="refund.html">Refund</a>
  <a href="rewards.html">Rewards</a>
  </nav>
  <p>¬© 2026 BowesProduct</p>
  </div>
</footer>
<div id="mobilePanelToggle"><span>‚ñ≤ Controls</span></div>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
  import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
  import { TransformControls } from 'three/addons/controls/TransformControls.js';

  const canvas = document.getElementById('canvas');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, preserveDrawingBuffer: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x020617);

  const gridHelper = new THREE.GridHelper(20, 20, 0x1e293b, 0x0f172a);
  scene.add(gridHelper);

  scene.add(new THREE.AmbientLight(0xffffff, 0.4));
  const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
  dirLight.position.set(5, 10, 7);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.width = 2048;
  dirLight.shadow.mapSize.height = 2048;
  scene.add(dirLight);

  const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(5, 4, 5);

  const controls = new OrbitControls(camera, canvas);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;

  // Transform controls - properly initialized
  const transformControl = new TransformControls(camera, renderer.domElement);
  transformControl.addEventListener('dragging-changed', (event) => {
    controls.enabled = !event.value;
  });
  transformControl.addEventListener('change', updateTransformInputs);
  scene.add(transformControl);

  const pmremGenerator = new THREE.PMREMGenerator(renderer);
  pmremGenerator.compileEquirectangularShader();
  let currentEnvMap = null;

  function loadEnvironment(url) {
    if (url === 'neutral') {
      scene.environment = null;
      if (currentEnvMap) currentEnvMap.dispose();
      return;
    }
    new RGBELoader().load(url, (tex) => {
      const envMap = pmremGenerator.fromEquirectangular(tex).texture;
      scene.environment = envMap;
      tex.dispose();
      if (currentEnvMap) currentEnvMap.dispose();
      currentEnvMap = envMap;
    });
  }
  loadEnvironment('neutral');

  // Mode management
  let currentMode = 'select'; // select, move, rotate, scale, sculpt
  const modes = ['select', 'move', 'rotate', 'scale', 'sculpt'];

  function setMode(mode) {
    currentMode = mode;
    
    // Update UI buttons
    modes.forEach(m => {
      const btn = document.getElementById(`mode${m.charAt(0).toUpperCase() + m.slice(1)}`);
      if (btn) btn.classList.remove('active', 'sculpt-active');
    });
    const activeBtn = document.getElementById(`mode${mode.charAt(0).toUpperCase() + mode.slice(1)}`);
    if (activeBtn) {
      activeBtn.classList.add('active');
      if (mode === 'sculpt') activeBtn.classList.add('sculpt-active');
    }

    // Update floater buttons
    const floaters = {
      'floaterSelect': 'select',
      'floaterMove': 'move',
      'floaterRotate': 'rotate',
      'floaterScale': 'scale',
      'floaterSculpt': 'sculpt'
    };
    Object.entries(floaters).forEach(([id, m]) => {
      const el = document.getElementById(id);
      el.classList.toggle('active', m === mode);
    });

    // Update transform controls
    if (selectedObjects.length > 0) {
      if (mode === 'select') {
        transformControl.detach();
      } else if (mode === 'move') {
        transformControl.setMode('translate');
        transformControl.attach(selectedObjects[0]);
      } else if (mode === 'rotate') {
        transformControl.setMode('rotate');
        transformControl.attach(selectedObjects[0]);
      } else if (mode === 'scale') {
        transformControl.setMode('scale');
        transformControl.attach(selectedObjects[0]);
      } else if (mode === 'sculpt') {
        transformControl.detach();
      }
    }

    // Show/hide sculpting controls
    const sculptingControls = document.getElementById('sculptingControls');
    const sculptingHeader = document.getElementById('sculptingHeader');
    if (mode === 'sculpt') {
      sculptingControls.classList.add('visible');
      sculptingHeader.style.display = 'block';
    } else {
      sculptingControls.classList.remove('visible');
      sculptingHeader.style.display = 'none';
    }
  }

  // Mode buttons
  modes.forEach(mode => {
    const btn = document.getElementById(`mode${mode.charAt(0).toUpperCase() + mode.slice(1)}`);
    if (btn) {
      btn.onclick = () => setMode(mode);
    }
  });

  // Floater buttons
  document.getElementById('floaterSelect').onclick = () => setMode('select');
  document.getElementById('floaterMove').onclick = () => setMode('move');
  document.getElementById('floaterRotate').onclick = () => setMode('rotate');
  document.getElementById('floaterScale').onclick = () => setMode('scale');
  document.getElementById('floaterSculpt').onclick = () => setMode('sculpt');

  // Keyboard shortcuts for modes
  window.addEventListener('keydown', (e) => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    switch(e.key.toLowerCase()) {
      case 'q': setMode('select'); break;
      case 'g': setMode('move'); break;
      case 'r': setMode('rotate'); break;
      case 's': setMode('scale'); break;
      case 'e': setMode('sculpt'); break;
      case 'delete':
      case 'backspace':
        document.getElementById('deleteBtn').click();
        break;
      case 'd':
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          document.getElementById('duplicateBtn').click();
        }
        break;
      case 'z':
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          if (e.shiftKey) {
            redo();
          } else {
            undo();
          }
        }
        break;
      case 'y':
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          redo();
        }
        break;
    }
  });

  function updateFloaterActiveState() {
    const floaters = {
      'floaterSelect': 'select',
      'floaterMove': 'move',
      'floaterRotate': 'rotate',
      'floaterScale': 'scale',
      'floaterSculpt': 'sculpt'
    };
    Object.entries(floaters).forEach(([id, m]) => {
      const el = document.getElementById(id);
      el.classList.toggle('active', m === currentMode);
    });
  }

  // Object & Group Management
  const rootObjects = [];
  let selectedObjects = [];
  let objectCounter = 0;

  // Selection highlight - green emissive glow
  const selectionOutlineMaterial = new THREE.MeshBasicMaterial({
    color: 0x22c55e,
    transparent: true,
    opacity: 0.3,
    side: THREE.DoubleSide,
    depthTest: false,
    depthWrite: false,
    blending: THREE.AdditiveBlending
  });

  const selectionOutlines = new Map();

  function updateSelectionHighlight() {
    // Remove old outlines
    selectionOutlines.forEach((outline, obj) => {
      scene.remove(outline);
      outline.geometry.dispose();
      outline.material.dispose();
    });
    selectionOutlines.clear();

    // Add new outlines
    selectedObjects.forEach(obj => {
      if (obj.isMesh) {
        const outline = obj.clone();
        outline.material = selectionOutlineMaterial.clone();
        outline.scale.multiplyScalar(1.02);
        outline.userData.isOutline = true;
        outline.renderOrder = 999;
        scene.add(outline);
        selectionOutlines.set(obj, outline);
      }
    });
  }

  // Undo/Redo
  const undoStack = [];
  const redoStack = [];
  const MAX_UNDO = 50;
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');

  function saveState() {
    const state = rootObjects.map(obj => serializeObject(obj));
    undoStack.push(state);
    if (undoStack.length > MAX_UNDO) undoStack.shift();
    redoStack.length = 0;
    undoBtn.disabled = false;
    redoBtn.disabled = true;
  }

  function serializeObject(obj) {
    if (obj.isGroup) {
      return {
        type: 'group',
        name: obj.userData.name,
        visible: obj.visible,
        position: obj.position.toArray(),
        rotation: obj.rotation.toArray(),
        scale: obj.scale.toArray(),
        children: obj.children.map(child => serializeObject(child))
      };
    } else {
      return {
        type: 'mesh',
        name: obj.userData.name,
        geometry: obj.userData.geometryName,
        visible: obj.visible,
        position: obj.position.toArray(),
        rotation: obj.rotation.toArray(),
        scale: obj.scale.toArray(),
        color: obj.material.color.getHex(),
        metallic: obj.material.metalness,
        roughness: obj.material.roughness
      };
    }
  }

  function deserializeObject(data, parent = null) {
    let obj;
    if (data.type === 'group') {
      obj = new THREE.Group();
      obj.userData.isGroup = true;
      data.children.forEach(childData => {
        const child = deserializeObject(childData, obj);
        obj.add(child);
      });
    } else {
      const geometry = createGeometryForName(data.geometry);
      const material = new THREE.MeshStandardMaterial({
        color: data.color,
        metalness: data.metallic,
        roughness: data.roughness,
        flatShading: false
      });
      obj = new THREE.Mesh(geometry, material);
      obj.userData.geometryName = data.geometry;
      obj.castShadow = true;
      obj.receiveShadow = true;
    }
    obj.userData.name = data.name;
    obj.userData.id = objectCounter++;
    obj.visible = data.visible;
    obj.position.fromArray(data.position);
    obj.rotation.fromArray(data.rotation);
    obj.scale.fromArray(data.scale);
    if (parent) parent.add(obj);
    return obj;
  }

  function restoreState(state) {
    rootObjects.forEach(o => scene.remove(o));
    rootObjects.length = 0;
    state.forEach(data => {
      const obj = deserializeObject(data);
      scene.add(obj);
      rootObjects.push(obj);
    });
    selectedObjects = [];
    updateSelectedObjectUI();
    updateLayersList();
    updateSelectionHighlight();
  }

  function undo() {
    if (undoStack.length === 0) return;
    redoStack.push(rootObjects.map(obj => serializeObject(obj)));
    const state = undoStack.pop();
    restoreState(state);
    undoBtn.disabled = undoStack.length === 0;
    redoBtn.disabled = false;
  }

  function redo() {
    if (redoStack.length === 0) return;
    undoStack.push(rootObjects.map(obj => serializeObject(obj)));
    const state = redoStack.pop();
    restoreState(state);
    redoStack.disabled = redoStack.length === 0;
    undoBtn.disabled = false;
  }

  undoBtn.onclick = undo;
  redoBtn.onclick = redo;

  function createGeometryForName(name) {
    switch(name) {
      case 'Box': return new THREE.BoxGeometry(1, 1, 1, 16, 16, 16);
      case 'Sphere': return new THREE.SphereGeometry(0.5, 64, 64);
      case 'Cylinder': return new THREE.CylinderGeometry(0.5, 0.5, 1, 64);
      case 'Torus': return new THREE.TorusGeometry(0.5, 0.2, 32, 64);
      case 'Cone': return new THREE.ConeGeometry(0.5, 1, 64);
      case 'Plane': return new THREE.PlaneGeometry(1, 1, 32, 32);
      case 'Icosahedron': return new THREE.IcosahedronGeometry(0.6, 2);
      case 'Dodecahedron': return new THREE.DodecahedronGeometry(0.6, 1);
      case 'Octahedron': return new THREE.OctahedronGeometry(0.7, 1);
      case 'Tetrahedron': return new THREE.TetrahedronGeometry(0.7, 1);
      case 'Ring': return new THREE.RingGeometry(0.3, 0.6, 64);
      case 'Tube': return new THREE.TubeGeometry(new THREE.CatmullRomCurve3([
        new THREE.Vector3(-1, 0, 0),
        new THREE.Vector3(-0.5, 1, 0),
        new THREE.Vector3(0.5, -1, 0),
        new THREE.Vector3(1, 0, 0)
      ]), 64, 0.1, 16, false);
      default: return new THREE.BoxGeometry(1, 1, 1, 16, 16, 16);
    }
  }

  function addPrimitive(name) {
    saveState();
    const geometry = createGeometryForName(name);
    const material = new THREE.MeshStandardMaterial({ 
      color: 0x60a5fa, 
      metalness: 0, 
      roughness: 0.5,
      flatShading: false
    });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.y = 0.5;
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    mesh.userData.name = name;
    mesh.userData.geometryName = name;
    mesh.userData.id = objectCounter++;
    scene.add(mesh);
    rootObjects.push(mesh);
    selectObject(mesh, false);
    updateLayersList();
    document.getElementById('loader').style.display = 'none';
  }

  // Primitive buttons
  document.getElementById('addBox').onclick = () => addPrimitive('Box');
  document.getElementById('addSphere').onclick = () => addPrimitive('Sphere');
  document.getElementById('addCylinder').onclick = () => addPrimitive('Cylinder');
  document.getElementById('addTorus').onclick = () => addPrimitive('Torus');
  document.getElementById('addCone').onclick = () => addPrimitive('Cone');
  document.getElementById('addPlane').onclick = () => addPrimitive('Plane');
  document.getElementById('addIcosahedron').onclick = () => addPrimitive('Icosahedron');
  document.getElementById('addDodecahedron').onclick = () => addPrimitive('Dodecahedron');
  document.getElementById('addOctahedron').onclick = () => addPrimitive('Octahedron');
  document.getElementById('addTetrahedron').onclick = () => addPrimitive('Tetrahedron');
  document.getElementById('addRing').onclick = () => addPrimitive('Ring');
  document.getElementById('addTube').onclick = () => addPrimitive('Tube');

  // Selection
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  function selectObject(object, multi = false) {
    if (!multi) selectedObjects = [];
    if (object) {
      if (!selectedObjects.includes(object)) selectedObjects.push(object);
    }
    updateSelectedObjectUI();
    updateSelectionHighlight();
    updateLayersList();

    // Update transform control based on mode
    if (selectedObjects.length === 1) {
      if (currentMode === 'move') {
        transformControl.setMode('translate');
        transformControl.attach(selectedObjects[0]);
      } else if (currentMode === 'rotate') {
        transformControl.setMode('rotate');
        transformControl.attach(selectedObjects[0]);
      } else if (currentMode === 'scale') {
        transformControl.setMode('scale');
        transformControl.attach(selectedObjects[0]);
      } else {
        transformControl.detach();
      }
    } else {
      transformControl.detach();
    }
  }

  canvas.addEventListener('pointerdown', (e) => {
    // Skip if in sculpting mode
    if (currentMode === 'sculpt') return;

    if (transformControl.dragging) return;
    const rect = canvas.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const allMeshes = [];
    rootObjects.forEach(obj => obj.traverse(child => { 
      if (child.isMesh && !child.userData.isOutline) allMeshes.push(child); 
    }));
    const intersects = raycaster.intersectObjects(allMeshes, false);
    if (intersects.length > 0) {
      selectObject(intersects[0].object, e.ctrlKey || e.metaKey);
    } else if (!e.ctrlKey && !e.metaKey) {
      selectedObjects = [];
      transformControl.detach();
      updateSelectedObjectUI();
      updateSelectionHighlight();
      updateLayersList();
    }
  });

  function updateSelectedObjectUI() {
    const infoDiv = document.getElementById('selectedObjectInfo');
    const transformDiv = document.getElementById('transformControls');
    if (selectedObjects.length === 0) {
      infoDiv.innerHTML = '<p style="color:#94a3b8;font-size:0.85rem;">No object selected</p>';
      transformDiv.style.display = 'none';
      return;
    }
    let html = `<div class="object-info"><h3>${selectedObjects.length} object${selectedObjects.length > 1 ? 's' : ''} selected</h3>`;
    if (selectedObjects.length === 1) {
      const obj = selectedObjects[0];
      html += `<p>Type: ${obj.userData.name || 'Mesh'}</p><p>ID: ${obj.userData.id}</p>`;
      document.getElementById('materialColor').value = '#' + obj.material.color.getHexString();
      document.getElementById('metallicSlider').value = obj.material.metalness;
      document.getElementById('metallicVal').textContent = obj.material.metalness.toFixed(2);
      document.getElementById('roughnessSlider').value = obj.material.roughness;
      document.getElementById('roughnessVal').textContent = obj.material.roughness.toFixed(2);
    } else {
      html += `<p>Multi-selection active</p>`;
    }
    html += `</div>`;
    infoDiv.innerHTML = html;
    transformDiv.style.display = 'block';
    updateTransformInputs();
  }

  function updateTransformInputs() {
    if (selectedObjects.length === 0) return;
    const obj = selectedObjects[0];
    document.getElementById('posX').value = obj.position.x.toFixed(2);
    document.getElementById('posY').value = obj.position.y.toFixed(2);
    document.getElementById('posZ').value = obj.position.z.toFixed(2);
    document.getElementById('rotX').value = THREE.MathUtils.radToDeg(obj.rotation.x).toFixed(1);
    document.getElementById('rotY').value = THREE.MathUtils.radToDeg(obj.rotation.y).toFixed(1);
    document.getElementById('rotZ').value = THREE.MathUtils.radToDeg(obj.rotation.z).toFixed(1);
    document.getElementById('scaleX').value = obj.scale.x.toFixed(2);
    document.getElementById('scaleY').value = obj.scale.y.toFixed(2);
    document.getElementById('scaleZ').value = obj.scale.z.toFixed(2);
  }

  function applyTransformToAll() {
    const pos = new THREE.Vector3(
      parseFloat(document.getElementById('posX').value) || 0,
      parseFloat(document.getElementById('posY').value) || 0,
      parseFloat(document.getElementById('posZ').value) || 0
    );
    const rot = new THREE.Euler(
      THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotX').value) || 0),
      THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotY').value) || 0),
      THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotZ').value) || 0)
    );
    const scale = new THREE.Vector3(
      parseFloat(document.getElementById('scaleX').value) || 1,
      parseFloat(document.getElementById('scaleY').value) || 1,
      parseFloat(document.getElementById('scaleZ').value) || 1
    );
    selectedObjects.forEach(obj => {
      obj.position.copy(pos);
      obj.rotation.copy(rot);
      obj.scale.copy(scale);
      // Update outline if exists
      const outline = selectionOutlines.get(obj);
      if (outline) {
        outline.position.copy(pos);
        outline.rotation.copy(rot);
        outline.scale.copy(scale).multiplyScalar(1.02);
      }
    });
  }

  ['posX','posY','posZ','rotX','rotY','rotZ','scaleX','scaleY','scaleZ'].forEach(id => {
    document.getElementById(id).addEventListener('change', () => {
      saveState();
      applyTransformToAll();
    });
  });

  document.getElementById('materialColor').addEventListener('input', (e) => {
    if (selectedObjects.length === 1 && selectedObjects[0].isMesh) {
      selectedObjects[0].material.color.set(e.target.value);
      saveState();
    }
  });

  document.getElementById('metallicSlider').addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    document.getElementById('metallicVal').textContent = v.toFixed(2);
    if (selectedObjects.length === 1 && selectedObjects[0].isMesh) {
      selectedObjects[0].material.metalness = v;
      saveState();
    }
  });

  document.getElementById('roughnessSlider').addEventListener('input', (e) => {
    const v = parseFloat(e.target.value);
    document.getElementById('roughnessVal').textContent = v.toFixed(2);
    if (selectedObjects.length === 1 && selectedObjects[0].isMesh) {
      selectedObjects[0].material.roughness = v;
      saveState();
    }
  });

  document.getElementById('duplicateBtn').onclick = () => {
    if (selectedObjects.length === 0) return;
    saveState();
    const clones = [];
    selectedObjects.forEach(obj => {
      const clone = obj.clone();
      if (obj.isMesh) clone.material = obj.material.clone();
      clone.position.x += 1;
      clone.userData.id = objectCounter++;
      scene.add(clone);
      rootObjects.push(clone);
      clones.push(clone);
    });
    selectedObjects = clones;
    updateSelectionHighlight();
    updateLayersList();
    updateSelectedObjectUI();
  };

  document.getElementById('deleteBtn').onclick = () => {
    if (selectedObjects.length === 0) return;
    saveState();
    selectedObjects.forEach(obj => {
      // Remove outline
      const outline = selectionOutlines.get(obj);
      if (outline) {
        scene.remove(outline);
        outline.geometry.dispose();
        outline.material.dispose();
        selectionOutlines.delete(obj);
      }
      
      if (obj.parent && obj.parent.isGroup) {
        obj.parent.remove(obj);
      } else {
        scene.remove(obj);
        const idx = rootObjects.indexOf(obj);
        if (idx > -1) rootObjects.splice(idx, 1);
      }
    });
    selectedObjects = [];
    transformControl.detach();
    updateLayersList();
    updateSelectedObjectUI();
  };

  // Grouping
  document.getElementById('createGroup').onclick = () => {
    if (selectedObjects.length < 2) return;
    saveState();
    const group = new THREE.Group();
    group.userData.isGroup = true;
    group.userData.name = `Group ${rootObjects.filter(o => o.userData.isGroup).length + 1}`;
    group.userData.id = objectCounter++;

    selectedObjects.forEach(obj => {
      const worldPos = new THREE.Vector3();
      obj.getWorldPosition(worldPos);
      obj.parent.remove(obj);
      group.add(obj);
      obj.position.copy(worldPos).sub(group.position);
    });

    scene.add(group);
    rootObjects.push(group);
    selectedObjects = [group];
    updateSelectionHighlight();
    updateLayersList();
    updateSelectedObjectUI();
  };

  document.getElementById('ungroup').onclick = () => {
    const groupsToUngroup = selectedObjects.filter(o => o.isGroup);
    if (groupsToUngroup.length === 0) return;
    saveState();
    groupsToUngroup.forEach(group => {
      const children = [...group.children];
      children.forEach(child => {
        const worldPos = new THREE.Vector3();
        child.getWorldPosition(worldPos);
        group.remove(child);
        scene.add(child);
        child.position.copy(worldPos);
        rootObjects.push(child);
      });
      scene.remove(group);
      const idx = rootObjects.indexOf(group);
      if (idx > -1) rootObjects.splice(idx, 1);
    });
    selectedObjects = [];
    updateSelectionHighlight();
    updateLayersList();
    updateSelectedObjectUI();
  };

  // Layers List
  function updateLayersList() {
    const list = document.getElementById('layersList');
    list.innerHTML = '';
    rootObjects.slice().reverse().forEach(obj => addLayerItem(obj, list));
  }

  function addLayerItem(obj, parentList) {
    const li = document.createElement('li');
    li.className = 'layer-item' + (selectedObjects.includes(obj) ? ' active' : '') + (obj.userData.isGroup ? ' group' : '');
    li.innerHTML = `
      <span class="layer-toggle">${obj.userData.isGroup ? '‚ñº' : ''}</span>
      <span class="layer-visibility">${obj.visible ? 'üëÅ' : 'üö´'}</span>
      <span class="layer-name">${obj.userData.name || 'Object'}</span>
      <span class="layer-delete">√ó</span>
    `;
    parentList.appendChild(li);

    li.querySelector('.layer-visibility').onclick = (e) => {
      e.stopPropagation();
      obj.visible = !obj.visible;
      li.querySelector('.layer-visibility').textContent = obj.visible ? 'üëÅ' : 'üö´';
      obj.traverse(child => child.visible = obj.visible);
      // Update outline visibility
      const outline = selectionOutlines.get(obj);
      if (outline) outline.visible = obj.visible;
      saveState();
    };

    li.querySelector('.layer-delete').onclick = (e) => {
      e.stopPropagation();
      saveState();
      // Remove outline
      const outline = selectionOutlines.get(obj);
      if (outline) {
        scene.remove(outline);
        outline.geometry.dispose();
        outline.material.dispose();
        selectionOutlines.delete(obj);
      }
      scene.remove(obj);
      const idx = rootObjects.indexOf(obj);
      if (idx > -1) rootObjects.splice(idx, 1);
      selectedObjects = selectedObjects.filter(o => o !== obj);
      updateSelectionHighlight();
      updateLayersList();
      updateSelectedObjectUI();
    };

    li.onclick = (e) => {
      if (e.target.classList.contains('layer-delete') || e.target.classList.contains('layer-visibility') || e.target.classList.contains('layer-toggle')) return;
      selectObject(obj, e.ctrlKey || e.metaKey);
    };

    if (obj.userData.isGroup) {
      const childList = document.createElement('ol');
      childList.style.marginLeft = '20px';
      childList.style.display = 'block';
      obj.children.forEach(child => addLayerItem(child, childList));
      li.appendChild(childList);
      li.querySelector('.layer-toggle').onclick = (e) => {
        e.stopPropagation();
        childList.style.display = childList.style.display === 'none' ? 'block' : 'none';
        li.querySelector('.layer-toggle').textContent = childList.style.display === 'none' ? '‚ñ∂' : '‚ñº';
      };
    }
  }

  document.getElementById('envPreset').addEventListener('change', (e) => loadEnvironment(e.target.value));

  const exportStatus = document.getElementById('exportStatus');
  document.getElementById('exportBtn').onclick = () => {
    if (rootObjects.length === 0) {
      exportStatus.textContent = 'No objects to export';
      exportStatus.style.color = '#ef4444';
      return;
    }
    // Temporarily remove selection outlines before export
    selectionOutlines.forEach((outline, obj) => {
      scene.remove(outline);
    });
    
    exportStatus.textContent = 'Exporting...';
    exportStatus.style.color = '#60a5fa';
    const exporter = new GLTFExporter();
    exporter.parse(scene, (result) => {
      const blob = new Blob([result], { type: 'application/octet-stream' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = 'scene.glb';
      link.click();
      exportStatus.textContent = 'Exported!';
      exportStatus.style.color = '#4ade80';
      
      // Add outlines back
      selectionOutlines.forEach((outline, obj) => {
        scene.add(outline);
      });
    }, { binary: true });
  };

  // Panel toggle
  const panel = document.getElementById('panel');
  const panelToggle = document.getElementById('panelToggle');
  const mobilePanelToggle = document.getElementById('mobilePanelToggle');
  let panelVisible = true;
  function togglePanel() {
    panelVisible = !panelVisible;
    panel.classList.toggle('hidden', !panelVisible);
    panel.classList.toggle('visible', panelVisible);
    panelToggle.textContent = panelVisible ? '‚Üê' : '‚Üí';
    const span = mobilePanelToggle.querySelector('span');
    if (span) span.textContent = panelVisible ? '‚ñº Hide Controls' : '‚ñ≤ Controls';
  }
  panelToggle.onclick = togglePanel;
  mobilePanelToggle.onclick = togglePanel;

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // ============ SCULPTING SYSTEM ============
  let currentSculptTool = 'brush';
  let brushSize = 0.5;
  let brushStrength = 0.5;
  let isSculpting = false;
  let lastSculptPosition = null;

  const sculptTools = ['brush', 'inflate', 'deflate', 'smooth', 'flatten'];

  sculptTools.forEach(tool => {
    const btn = document.getElementById(`sculpt${tool.charAt(0).toUpperCase() + tool.slice(1)}`);
    if (btn) {
      btn.onclick = () => {
        currentSculptTool = tool;
        sculptTools.forEach(t => {
          const b = document.getElementById(`sculpt${t.charAt(0).toUpperCase() + t.slice(1)}`);
          if (b) b.classList.remove('active');
        });
        btn.classList.add('active');
      };
    }
  });

  document.getElementById('brushSize').addEventListener('input', (e) => {
    brushSize = parseFloat(e.target.value);
    document.getElementById('brushSizeVal').textContent = brushSize.toFixed(1);
  });

  document.getElementById('brushStrength').addEventListener('input', (e) => {
    brushStrength = parseFloat(e.target.value);
    document.getElementById('brushStrengthVal').textContent = brushStrength.toFixed(1);
  });

  // Sculpting interaction
  canvas.addEventListener('pointerdown', (e) => {
    if (currentMode !== 'sculpt') return;
    if (selectedObjects.length === 0 || !selectedObjects[0].isMesh) return;

    isSculpting = true;
    lastSculptPosition = getIntersectionPoint(e);
    saveState();
  });

  canvas.addEventListener('pointermove', (e) => {
    if (!isSculpting || currentMode !== 'sculpt') return;
    if (selectedObjects.length === 0 || !selectedObjects[0].isMesh) return;

    const currentPos = getIntersectionPoint(e);
    if (!currentPos || !lastSculptPosition) return;

    const mesh = selectedObjects[0];
    applySculpt(mesh, lastSculptPosition, currentPos);
    
    lastSculptPosition = currentPos;
    
    // Update selection outline
    const outline = selectionOutlines.get(mesh);
    if (outline) {
      outline.geometry.dispose();
      outline.geometry = mesh.geometry.clone();
    }
  });

  canvas.addEventListener('pointerup', () => {
    isSculpting = false;
    lastSculptPosition = null;
  });

  canvas.addEventListener('pointerleave', () => {
    isSculpting = false;
    lastSculptPosition = null;
  });

  function getIntersectionPoint(e) {
    const rect = canvas.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    
    if (selectedObjects.length > 0 && selectedObjects[0].isMesh) {
      const intersects = raycaster.intersectObject(selectedObjects[0], false);
      if (intersects.length > 0) {
        return intersects[0];
      }
    }
    return null;
  }

  function applySculpt(mesh, lastPoint, currentPoint) {
    const geometry = mesh.geometry;
    const positionAttribute = geometry.attributes.position;
    const vertexCount = positionAttribute.count;
    
    // Convert to non-indexed if indexed for sculpting
    if (geometry.index) {
      geometry.toNonIndexed();
      geometry.computeVertexNormals();
      return;
    }

    const positions = positionAttribute.array;
    const normalAttribute = geometry.attributes.normal;
    const normals = normalAttribute.array;

    const localLastPoint = mesh.worldToLocal(lastPoint.point.clone());
    const localCurrentPoint = mesh.worldToLocal(currentPoint.point.clone());
    const brushRadius = brushSize / mesh.scale.x;
    const strength = brushStrength * 0.01;

    const vertex = new THREE.Vector3();
    const tempVertex = new THREE.Vector3();
    const center = new THREE.Vector3();

    // Calculate brush direction
    const brushDirection = new THREE.Vector3().subVectors(currentPoint.point, lastPoint.point);
    const isShiftHeld = false; // Could add shift key detection for inverse

    for (let i = 0; i < vertexCount; i++) {
      vertex.fromArray(positions, i * 3);
      
      const distance = vertex.distanceTo(localLastPoint);
      if (distance < brushRadius) {
        const falloff = Math.pow(1 - (distance / brushRadius), 2);
        let displacement = 0;

        const normal = new THREE.Vector3(normals[i * 3], normals[i * 3 + 1], normals[i * 3 + 2]);

        switch (currentSculptTool) {
          case 'brush':
            displacement = falloff * strength;
            tempVertex.copy(normal).multiplyScalar(displacement);
            vertex.add(tempVertex);
            break;

          case 'inflate':
            displacement = falloff * strength;
            tempVertex.copy(normal).multiplyScalar(displacement);
            vertex.add(tempVertex);
            break;

          case 'deflate':
            displacement = falloff * strength;
            tempVertex.copy(normal).multiplyScalar(-displacement);
            vertex.add(tempVertex);
            break;

          case 'smooth':
            // Average with nearby vertices
            center.set(0, 0, 0);
            let count = 0;
            for (let j = 0; j < vertexCount; j++) {
              if (i === j) continue;
              tempVertex.fromArray(positions, j * 3);
              const d = vertex.distanceTo(tempVertex);
              if (d < brushRadius * 0.5) {
                center.add(tempVertex);
                count++;
              }
            }
            if (count > 0) {
              center.divideScalar(count);
              tempVertex.subVectors(center, vertex).multiplyScalar(falloff * strength);
              vertex.add(tempVertex);
            }
            break;

          case 'flatten':
            // Push towards a plane
            const planeHeight = localLastPoint.y;
            const diff = planeHeight - vertex.y;
            vertex.y += diff * falloff * strength;
            break;
        }

        positions[i * 3] = vertex.x;
        positions[i * 3 + 1] = vertex.y;
        positions[i * 3 + 2] = vertex.z;
      }
    }

    positionAttribute.needsUpdate = true;
    geometry.computeVertexNormals();
    geometry.attributes.normal.needsUpdate = true;
  }

  // Drag & drop import
  window.addEventListener('dragover', e => e.preventDefault());
  window.addEventListener('drop', e => {
    e.preventDefault();
    const file = e.dataTransfer.files[0];
    if (file && (file.name.endsWith('.glb') || file.name.endsWith('.gltf'))) {
      const url = URL.createObjectURL(file);
      alert("Drag & drop import not fully implemented in this version ‚Äì use the upload button.");
    }
  });

  // Animation loop
  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();
</script>
</body>
</html>
