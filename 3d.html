<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Modeler Pro ‚Äì 3D Editor</title>
<!-- ES Module Shims for import maps -->
  <script async src="https://unpkg.com/es-module-shims@1.8.2/dist/es-module-shims.js"></script>

  <!-- Three.js Import Map (updated to stable version) -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
    }
  }
  </script>
  <style>
  *, *::before, *::after { box-sizing: border-box; }
  html, body { margin: 0; height: 100%; background: #020617; color: white; font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif; overflow: hidden; -webkit-font-smoothing: antialiased; }
  .site-header {
  position: fixed; top: 0; left: 0; right: 0; z-index: 1000; background: rgba(2,6,23,0.95); border-bottom: 1px solid #1e293b; backdrop-filter: blur(10px);
  }
  .header-inner { max-width: 1200px; margin: 0 auto; padding: 0.6rem 1rem; display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 0.5rem; }
  .header-left { display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; }
  .logo a { font-size: 1.3rem; font-weight: 700; color: white; text-decoration: none; white-space: nowrap; }
  .main-nav { display: flex; gap: 1rem; flex-wrap: wrap; }
  .main-nav a { color: #e5e7eb; text-decoration: none; font-size: 0.9rem; white-space: nowrap; }
  .main-nav a:hover, .main-nav a.active { color: #60a5fa; }
  .header-right { display: flex; align-items: center; gap: 0.8rem; min-height: 44px; flex-wrap: wrap; }
  #profilePic { width: 32px; height: 32px; border-radius: 50%; border: 2px solid #60a5fa; object-fit: cover; display: none; }
  .login-btn { padding: 0.45rem 1.1rem; border-radius: 999px; border: 1.5px solid #60a5fa; background: transparent; color: #60a5fa; font-size: 0.95rem; cursor: pointer; }
  #levelInfo { display: none; font-size: 0.8rem; color: #cbd5e1; }
  #levelText { white-space: nowrap; font-size: 0.75rem; }
  #xpOuter { width: 100px; height: 5px; background: #1e293b; border-radius: 3px; margin-top: 4px; }
  #xpBar { height: 100%; width: 0%; background: #60a5fa; border-radius: 3px; transition: width 0.35s ease; }
  @media (max-width: 900px) {
  .header-inner { padding: 0.5rem; }
  .header-left { width: 100%; justify-content: space-between; }
  .main-nav { gap: 0.8rem; order: 3; width: 100%; }
  .main-nav a { font-size: 0.85rem; }
  .header-right { width: 100%; justify-content: space-between; }
  #levelInfo { flex: 1; }
  #xpOuter { width: 100%; }
  }
#container { 
  position: relative; 
  width: 100%; 
  height: calc(100vh - 70px); /* Adjust if your header/footer height changes */
  overflow: hidden;
}
#canvas { 
  display: block; 
  width: 100%; 
  height: 100%; 
  touch-action: none; 
  outline: none; 
  position: absolute;
  top: 0;
  left: 0;
  z-index: 1;
}
  .panel.hidden { transform: translateX(420px); }
  .panel::-webkit-scrollbar { width: 6px; }
  .panel::-webkit-scrollbar-track { background: #0f172a; }
  .panel::-webkit-scrollbar-thumb { background: #334155; border-radius: 3px; }
  #panelToggle {
  position: absolute;
  left: -60px;
  top: 50%;
  transform: translateY(-50%);
  width: 60px;
  height: 110px;
  background: rgba(2, 6, 23, 0.98);
  border: 1px solid #1e293b;
  border-right: none;
  border-radius: 20px 0 0 20px;
  color: #60a5fa;
  font-size: 2.4rem;
  font-weight: bold;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 21;
  backdrop-filter: blur(12px);
  box-shadow: 0 6px 30px rgba(0,0,0,0.5);
  transition: all 0.3s ease;
  }
  #panelToggle:hover { background: rgba(30, 41, 59, 0.98); color: white; transform: translateY(-50%) translateX(-4px); }
  @media (max-width: 900px) {
  .panel {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  top: auto;
  height: 70vh;
  max-height: none;
  border-radius: 20px 20px 0 0;
  transform: translateY(100%);
  transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1);
  padding-top: 20px;
  padding-bottom: 120px;
  z-index: 1100;
  overflow-y: auto;
  background: rgba(2, 6, 23, 0.98);
  border: 1px solid #1e293b;
  border-bottom: none;
  box-shadow: 0 -5px 25px rgba(0,0,0,0.5);
  }
  .panel.visible { transform: translateY(0); }
  #panelToggle { display: none; }
  }
  #mobilePanelToggle {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 140px;
  height: 44px;
  background: rgba(2, 6, 23, 0.9);
  border: 1px solid #60a5fa;
  border-radius: 22px;
  color: #60a5fa;
  font-size: 0.85rem;
  font-weight: 700;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 1200;
  backdrop-filter: blur(12px);
  box-shadow: 0 4px 20px rgba(0,0,0,0.6);
  transition: background 0.2s, transform 0.1s;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  }
  #mobilePanelToggle:active { transform: scale(0.96); }
  #mobilePanelToggle::before {
  content: '';
  position: absolute;
  top: -6px;
  left: 50%;
  transform: translateX(-50%);
  width: 40px;
  height: 4px;
  background: #94a3b8;
  border-radius: 2px;
  opacity: 0.5;
  }
  @media (min-width: 901px) { #mobilePanelToggle { display: none; } }
  @media (max-width: 900px) { #mobilePanelToggle { display: flex; } }
  #floatingControls {
  position: fixed;
  bottom: 20px;
  left: 20px;
  display: flex;
  gap: 10px;
  z-index: 1150;
  pointer-events: none;
  flex-direction: column;
  }
  .floater {
  pointer-events: auto;
  width: 44px;
  height: 44px;
  border-radius: 50%;
  border: 1px solid #475569;
  background: rgba(30, 41, 59, 0.9);
  backdrop-filter: blur(8px);
  color: #94a3b8;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  transition: all 0.2s;
  font-size: 1.2rem;
  }
  .floater:hover { background: rgba(51, 65, 85, 1); color: white; transform: translateY(-2px); }
  .floater.active { color: #60a5fa; border-color: #60a5fa; background: rgba(2, 6, 23, 1); }
  @media (min-width: 901px) { #floatingControls { display: flex !important; } }
  @media (max-width: 900px) {
    .panel.visible ~ #floatingControls { display: none !important; }
    .panel.hidden ~ #floatingControls { display: flex !important; }
  }
  .panel h2 { color: #60a5fa; margin: 1.5rem 0 1rem; font-size: 1.1rem; border-bottom: 1px solid #1e293b; padding-bottom: 0.5rem; }
  .control-group { margin-bottom: 1.2rem; }
  label { display: block; font-size: 0.9rem; color: #e5e7eb; margin-bottom: 0.4rem; }
  input, select, button { width: 100%; padding: 0.5rem; border-radius: 0.375rem; border: 1px solid #1f2937; background: #020617; color: #e5e7eb; font: inherit; }
  input[type="range"] { padding: 0.3rem 0; accent-color: #60a5fa; }
  input[type="color"] { height: 44px; padding: 0.2rem; }
  button { background: #60a5fa; border: none; color: white; cursor: pointer; margin-top: 0.8rem; font-weight: 600; transition: background 0.2s; }
  button:hover { background: #3b82f6; }
  button:disabled { background: #475569; cursor: not-allowed; }
  button.secondary { background: #475569; }
  button.secondary:hover { background: #64748b; }
  button.danger { background: #ef4444; }
  button.danger:hover { background: #dc2626; }
  button.success { background: #10b981; }
  button.success:hover { background: #059669; }
  #layersList { list-style: none; padding: 0; margin: 0 0 1rem; }
  .layer-item {
  display: flex; align-items: center; gap: 8px; padding: 10px; background: #0f172a; border-radius: 8px; margin-bottom: 8px; cursor: pointer; border: 1px solid transparent;
  }
  .layer-item.active { background: #1e293b; border-color: #60a5fa; }
  .layer-item.group { background: #162032; }
  .layer-item.locked { opacity: 0.5; }
  .layer-visibility { font-size: 1.3rem; cursor: pointer; width: 24px; text-align: center; }
  .layer-lock { font-size: 1.1rem; cursor: pointer; width: 24px; text-align: center; }
  .layer-name { flex: 1; font-size: 0.95rem; }
  .layer-name input { width: 100%; background: transparent; border: 1px solid transparent; padding: 2px 6px; }
  .layer-name input:focus { border-color: #60a5fa; outline: none; }
  .layer-name input.editing { background: #1e293b; }
  .layer-delete { color: #ef4444; cursor: pointer; font-size: 1.2rem; width: 24px; text-align: center; }
  .layer-toggle { cursor: pointer; font-size: 1rem; width: 20px; }
  .layer-color { width: 16px; height: 16px; border-radius: 4px; border: 1px solid #334155; }
  .hint { font-size: 0.75rem; color: #94a3b8; margin-top: 0.25rem; }
  ##loader {
  position: absolute; 
  top: 50%; 
  left: 50%; 
  transform: translate(-50%, -50%);
  color: #60a5fa; 
  font-size: 1.5rem; 
  font-weight: bold; 
  pointer-events: none; 
  z-index: 10;
}
  .transform-controls { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 1rem; }
  .transform-input label { font-size: 0.75rem; color: #94a3b8; margin: 0; }
  .object-info { background: #0f172a; padding: 10px; border-radius: 8px; margin-bottom: 1rem; border: 1px solid #1e293b; }
  .object-info h3 { margin: 0 0 8px; font-size: 0.95rem; color: #60a5fa; }
  .site-footer { position: fixed; bottom: 0; left: 0; right: 0; background: rgba(2,6,23,0.95); border-top: 1px solid #1e293b; padding: 1rem; z-index: 1000; backdrop-filter: blur(10px); }
  .footer-inner { max-width: 1200px; margin: 0 auto; display: flex; justify-content: space-between; flex-wrap: wrap; gap: 1.5rem; font-size: 0.85rem; }
  .footer-nav a { color: #cbd5e1; text-decoration: none; }
  .footer-nav a:hover { color: #60a5fa; }
  
  /* Toast notifications */
  #toastContainer {
  position: fixed;
  top: 80px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 2000;
  display: flex;
  flex-direction: column;
  gap: 8px;
  pointer-events: none;
  }
  .toast {
  background: rgba(30, 41, 59, 0.95);
  border: 1px solid #334155;
  border-radius: 8px;
  padding: 12px 20px;
  color: #e5e7eb;
  font-size: 0.9rem;
  backdrop-filter: blur(10px);
  box-shadow: 0 4px 20px rgba(0,0,0,0.4);
  animation: slideDown 0.3s ease;
  }
  @keyframes slideDown {
  from { transform: translateY(-20px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
  }
  
  /* Modal styles */
  .modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.8);
  z-index: 1500;
  display: flex;
  align-items: center;
  justify-content: center;
  }
  .modal {
  background: rgba(2, 6, 23, 0.98);
  border: 1px solid #1e293b;
  border-radius: 12px;
  padding: 2rem;
  max-width: 600px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
  backdrop-filter: blur(12px);
  box-shadow: 0 20px 60px rgba(0,0,0,0.6);
  position: relative;
  }
  .modal h2 { color: #60a5fa; margin-top: 0; }
  .modal-close {
  position: absolute;
  top: 1rem;
  right: 1rem;
  background: none;
  border: none;
  color: #94a3b8;
  font-size: 1.5rem;
  cursor: pointer;
  width: auto;
  padding: 0;
  margin: 0;
  }
  .modal-close:hover { color: white; }
  .modal-body { margin: 1.5rem 0; }
  
  /* Keyboard shortcuts overlay */
  #shortcutsOverlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.9);
  z-index: 1800;
  display: none;
  align-items: center;
  justify-content: center;
  backdrop-filter: blur(8px);
  }
  #shortcutsOverlay.visible { display: flex; }
  .shortcuts-content {
  background: rgba(2, 6, 23, 0.98);
  border: 1px solid #1e293b;
  border-radius: 12px;
  padding: 2rem;
  max-width: 700px;
  max-height: 80vh;
  overflow-y: auto;
  }
  .shortcuts-content h2 { color: #60a5fa; margin-top: 0; text-align: center; }
  .shortcut-section { margin-bottom: 1.5rem; }
  .shortcut-section h3 { color: #e5e7eb; font-size: 1rem; margin-bottom: 0.8rem; border-bottom: 1px solid #334155; padding-bottom: 0.4rem; }
  .shortcut-item { display: flex; justify-content: space-between; padding: 0.5rem 0; color: #cbd5e1; }
  .shortcut-key { 
  background: #1e293b; 
  padding: 0.2rem 0.6rem; 
  border-radius: 4px; 
  font-family: monospace; 
  font-size: 0.85rem;
  border: 1px solid #334155;
  }
  
  /* Search input */
  #layerSearch {
  width: 100%;
  padding: 0.5rem;
  border-radius: 6px;
  border: 1px solid #1e293b;
  background: #0f172a;
  color: #e5e7eb;
  margin-bottom: 1rem;
  font-size: 0.85rem;
  }
  #layerSearch:focus { outline: none; border-color: #60a5fa; }
  
  /* Scene list */
  #sceneList {
  max-height: 300px;
  overflow-y: auto;
  border: 1px solid #1e293b;
  border-radius: 8px;
  margin-bottom: 1rem;
  }
  .scene-item {
  padding: 12px;
  border-bottom: 1px solid #1e293b;
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
  }
  .scene-item:hover { background: rgba(96, 165, 250, 0.1); }
  .scene-item:last-child { border-bottom: none; }
  .scene-name { flex: 1; }
  .scene-actions { display: flex; gap: 8px; }
  .scene-btn {
  padding: 4px 8px;
  font-size: 0.75rem;
  width: auto;
  margin: 0;
  }
  
  /* Camera presets */
  .camera-presets { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 1rem; }
  
  /* Animation timeline */
  #animationPanel {
  display: none;
  margin-top: 1rem;
  padding: 1rem;
  background: #0f172a;
  border-radius: 8px;
  border: 1px solid #1e293b;
  }
  #animationPanel.visible { display: block; }
  .timeline-track {
  height: 60px;
  background: #1e293b;
  border-radius: 4px;
  margin-bottom: 0.5rem;
  position: relative;
  overflow: hidden;
  }
  .keyframe {
  position: absolute;
  width: 12px;
  height: 12px;
  background: #60a5fa;
  border-radius: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  cursor: pointer;
  border: 2px solid white;
  }
  
  /* Boolean operations panel */
  #booleanPanel {
  display: none;
  margin-top: 1rem;
  padding: 1rem;
  background: #0f172a;
  border-radius: 8px;
  border: 1px solid #1e293b;
  }
  #booleanPanel.visible { display: block; }
  
  /* Snapping controls */
  .snap-controls { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
  
  /* Axis indicator */
  #axisIndicator {
  position: fixed;
  bottom: 20px;
  left: 80px;
  width: 80px;
  height: 80px;
  z-index: 1150;
  pointer-events: none;
  }
  
  /* Auto-save indicator */
  #autoSaveIndicator {
  position: fixed;
  top: 80px;
  right: 20px;
  background: rgba(16, 185, 129, 0.9);
  color: white;
  padding: 8px 16px;
  border-radius: 20px;
  font-size: 0.8rem;
  z-index: 950;
  display: none;
  backdrop-filter: blur(8px);
  }
  #autoSaveIndicator.visible { display: block; }
  </style>
<script src="https://sites.super.myninja.ai/_assets/ninja-daytona-script.js"></script>
</head>
<body>
<header class="site-header">
  <div class="header-inner">
  <div class="header-left">
  <div class="logo"><a href="#" onclick="event.preventDefault();">Modeler Pro</a></div>
  <nav class="main-nav">
  <a href="#" onclick="event.preventDefault();">Home</a>
  <a href="#" onclick="event.preventDefault();">Models</a>
  <a href="#" onclick="event.preventDefault();">Retexture</a>
    <a href="#" onclick="event.preventDefault();">Editor</a>
    <a href="#" class="active">3D Editor</a>
  </nav>
  </div>
  <div class="header-right">
  <img id="profilePic" alt="Profile">
  <div id="levelInfo">
  <div id="levelText"></div>
  <div id="xpOuter"><div id="xpBar"></div></div>
  </div>
  <button id="authBtn" class="login-btn">Login</button>
  </div>
  </div>
</header>
<div id="container">
  <div id="loader">Add objects or upload a model to start</div>
  <canvas id="canvas"></canvas>
  <div id="floatingControls">
    <div class="floater" id="floaterSelect" title="Select Mode (V)">üëÜ</div>
    <div class="floater" id="floaterMove" title="Move (G)">‚ú•</div>
    <div class="floater" id="floaterRotate" title="Rotate (R)">‚Üª</div>
    <div class="floater" id="floaterScale" title="Scale (S)">‚§¢</div>
    <div class="floater" id="floaterFocus" title="Focus on Selected (F)">üéØ</div>
  </div>
  <div class="panel" id="panel">
  <button id="panelToggle">‚Üê</button>
 
  <div style="padding:0.8rem;background:rgba(30,41,59,0.4);border-radius:8px;margin-bottom:1rem;font-size:0.85rem;line-height:1.4;border:1px solid #334155;">
  <strong style="color:#60a5fa">Controls:</strong><br>
  ‚Ä¢ Left click + drag: Rotate view<br>
  ‚Ä¢ Right click + drag: Pan<br>
  ‚Ä¢ Scroll: Zoom<br>
  ‚Ä¢ Click object: Select ‚Ä¢ Ctrl/Cmd + click: Multi-select<br>
  ‚Ä¢ G/R/S/V: Move/Rotate/Scale/Select<br>
  ‚Ä¢ Delete: Delete ‚Ä¢ Ctrl+D: Duplicate ‚Ä¢ Ctrl+Z/Y: Undo/Redo<br>
  ‚Ä¢ F: Focus ‚Ä¢ ?: Shortcuts ‚Ä¢ Alt+Drag: Duplicate
  </div>
  
  <h2>Scene Management</h2>
  <button id="saveLocalBtn" class="secondary">üíæ Save Local</button>
  <button id="loadLocalBtn" class="secondary">üìÇ Load Local</button>
  <div id="autoSaveIndicator">Auto-saved ‚úì</div>

  <h2>Add Objects</h2>
  <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-bottom:1rem;">
  <button id="addBox">Box</button>
  <button id="addSphere">Sphere</button>
  <button id="addCylinder">Cylinder</button>
  <button id="addTorus">Torus</button>
  <button id="addCone">Cone</button>
  <button id="addPlane">Plane</button>
  <button id="addIcosahedron">Icosahedron</button>
  <button id="addDodecahedron">Dodecahedron</button>
  <button id="addOctahedron">Octahedron</button>
  <button id="addTetrahedron">Tetrahedron</button>
  <button id="addRing">Ring</button>
  <button id="addTube">Tube</button>
  <button id="addText" class="secondary">Text 3D</button>
  <button id="addLathe" class="secondary">Lathe</button>
  <button id="addExtrude" class="secondary">Extrude</button>
  </div>
  
  <h2>Templates</h2>
  <select id="templateSelect">
  <option value="">Select Template...</option>
  <option value="furniture">Furniture Set</option>
  <option value="vehicle">Vehicle Base</option>
  <option value="architecture">Architecture Kit</option>
  <option value="character">Character Base</option>
  </select>
  <button id="loadTemplateBtn">Load Template</button>
  
  <h2>Group & Boolean</h2>
  <button id="createGroup">Create Group</button>
  <button id="ungroup">Ungroup</button>
  <div id="booleanPanel">
  <label>Boolean Operations</label>
  <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;">
  <button id="boolUnion" class="secondary">Union</button>
  <button id="boolSubtract" class="danger">Subtract</button>
  <button id="boolIntersect" class="secondary">Intersect</button>
  </div>
  </div>
  <button id="toggleBoolean" class="secondary">Toggle Boolean Panel</button>
  <div class="hint">Select 2 objects for boolean operations</div>

  <h2>Model Import</h2>
  <div class="control-group">
  <label for="uploadModel">Upload Model</label>
  <input type="file" id="uploadModel" accept=".glb,.gltf,.obj,.fbx">
  <div class="hint">Supports GLB/GLTF/OBJ/FBX. Auto-centers model.</div>
  </div>

  <h2>Selected Object(s)</h2>
  <div id="selectedObjectInfo">
  <p style="color:#94a3b8;font-size:0.85rem;">No object selected</p>
  </div>

  <div id="transformControls" style="display:none;">
  <div class="control-group"><label>Transform Mode</label>
  <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;">
  <button id="transformLocal" class="secondary">Local</button>
  <button id="transformWorld" class="active">World</button>
  </div></div>
  <div class="control-group"><label>Position</label><div class="transform-controls">
  <div class="transform-input"><label>X</label><input type="number" id="posX" step="0.1"></div>
  <div class="transform-input"><label>Y</label><input type="number" id="posY" step="0.1"></div>
  <div class="transform-input"><label>Z</label><input type="number" id="posZ" step="0.1"></div>
  </div></div>
  <div class="control-group"><label>Rotation (degrees)</label><div class="transform-controls">
  <div class="transform-input"><label>X</label><input type="number" id="rotX" step="5"></div>
  <div class="transform-input"><label>Y</label><input type="number" id="rotY" step="5"></div>
  <div class="transform-input"><label>Z</label><input type="number" id="rotZ" step="5"></div>
  </div></div>
  <div class="control-group"><label>Scale</label><div class="transform-controls">
  <div class="transform-input"><label>X</label><input type="number" id="scaleX" step="0.1" min="0.01"></div>
  <div class="transform-input"><label>Y</label><input type="number" id="scaleY" step="0.1" min="0.01"></div>
  <div class="transform-input"><label>Z</label><input type="number" id="scaleZ" step="0.1" min="0.01"></div>
  </div></div>
  <button id="duplicateBtn">Duplicate (Ctrl+D)</button>
  <button id="deleteBtn" class="danger">Delete Selected</button>
  </div>

  <h2>Material</h2>
  <div class="control-group">
  <label for="materialColor">Color</label>
  <input type="color" id="materialColor" value="#60a5fa">
  </div>
  <div class="control-group">
  <label for="metallicSlider">Metallic <span id="metallicVal">0.00</span></label>
  <input type="range" id="metallicSlider" min="0" max="1" step="0.01" value="0">
  </div>
  <div class="control-group">
  <label for="roughnessSlider">Roughness <span id="roughnessVal">0.50</span></label>
  <input type="range" id="roughnessSlider" min="0" max="1" step="0.01" value="0.5">
  </div>
  <div class="control-group">
  <label for="textureUpload">Texture</label>
  <input type="file" id="textureUpload" accept="image/*">
  <div class="hint">Drag image or upload to apply texture</div>
  </div>

  <h2>Snapping & Grid</h2>
  <div class="snap-controls">
  <button id="toggleSnap" class="secondary">Snap: Off</button>
  <button id="snapToSurface" class="secondary">Snap to Surface</button>
  </div>
  <div class="control-group">
  <label for="snapIncrement">Snap Increment</label>
  <input type="number" id="snapIncrement" value="0.5" step="0.1" min="0.01">
  </div>

  <h2>Camera Presets</h2>
  <div class="camera-presets">
  <button id="camTop" class="secondary">Top</button>
  <button id="camFront" class="secondary">Front</button>
  <button id="camRight" class="secondary">Right</button>
  <button id="camPerspective" class="active">Persp</button>
  <button id="camReset" class="secondary">Reset</button>
  </div>

  <h2>Layers / Objects</h2>
  <input type="text" id="layerSearch" placeholder="üîç Search objects...">
  <ol id="layersList"></ol>
  
  <h2>Animation</h2>
  <button id="toggleAnimation" class="secondary">Toggle Animation Panel</button>
  <div id="animationPanel">
  <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:1rem;">
  <button id="addKeyframe" class="secondary">Add Keyframe</button>
  <button id="playAnimation" class="secondary">‚ñ∂ Play</button>
  </div>
  <div class="timeline-track" id="timelineTrack"></div>
  <label>Timeline</label>
  <input type="range" id="timelineSlider" min="0" max="100" value="0">
  </div>

  <div id="undoRedoGroup">
  <button id="undoBtn" disabled>Undo (Ctrl+Z)</button>
  <button id="redoBtn" disabled>Redo (Ctrl+Y)</button>
  </div>

  <h2>Lighting</h2>
  <div class="control-group">
  <label for="envPreset">Environment</label>
  <select id="envPreset">
  <option value="neutral">Neutral</option>
  <option value="https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/2k/royal_esplanade_1k.hdr">Royal Esplanade</option>
  <option value="https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/2k/spruit_sunrise_1k.hdr">Sunrise</option>
  <option value="https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/2k/moonless_golf_1k.hdr">Night</option>
  </select>
  </div>

  <h2>Export</h2>
  <button id="exportGLB">Export GLB</button>
  <button id="exportOBJ" class="secondary">Export OBJ</button>
  <button id="exportSTL" class="secondary">Export STL (3D Print)</button>
  <button id="exportPNG" class="secondary">üì∑ Screenshot</button>
  <div class="control-group">
  <label>
  <input type="checkbox" id="transparentBG"> Transparent Background
  </label>
  </div>
  <div id="exportStatus" style="margin-top:0.5rem;font-size:0.8rem;color:#94a3b8;"></div>
  </div>
</div>
<footer class="site-footer">
  <div class="footer-inner">
  <nav class="footer-nav">
  <a href="#" onclick="event.preventDefault();">About</a>
  <a href="#" onclick="event.preventDefault();">Privacy</a>
  <a href="#" onclick="event.preventDefault();">Terms</a>
  <a href="#" onclick="event.preventDefault();">License</a>
  <a href="#" onclick="event.preventDefault();">Refund</a>
  <a href="#" onclick="event.preventDefault();">Rewards</a>
  </nav>
  <p>¬© 2026 Modeler Pro</p>
  </div>
</footer>
<div id="mobilePanelToggle"><span>‚ñ≤ Controls</span></div>

<!-- Toast container -->
<div id="toastContainer"></div>

<!-- Keyboard shortcuts overlay -->
<div id="shortcutsOverlay">
  <div class="shortcuts-content">
  <h2>‚å®Ô∏è Keyboard Shortcuts</h2>
  <div class="shortcut-section">
  <h3>Transform</h3>
  <div class="shortcut-item"><span>Select Mode</span><span class="shortcut-key">V</span></div>
  <div class="shortcut-item"><span>Move</span><span class="shortcut-key">G</span></div>
  <div class="shortcut-item"><span>Rotate</span><span class="shortcut-key">R</span></div>
  <div class="shortcut-item"><span>Scale</span><span class="shortcut-key">S</span></div>
  <div class="shortcut-item"><span>Focus on Selected</span><span class="shortcut-key">F</span></div>
  <div class="shortcut-item"><span>Duplicate</span><span class="shortcut-key">Ctrl + D</span></div>
  <div class="shortcut-item"><span>Delete</span><span class="shortcut-key">Delete</span></div>
  </div>
  <div class="shortcut-section">
  <h3>Camera</h3>
  <div class="shortcut-item"><span>Top View</span><span class="shortcut-key">Numpad 7</span></div>
  <div class="shortcut-item"><span>Front View</span><span class="shortcut-key">Numpad 1</span></div>
  <div class="shortcut-item"><span>Right View</span><span class="shortcut-key">Numpad 3</span></div>
  <div class="shortcut-item"><span>Perspective</span><span class="shortcut-key">Numpad 5</span></div>
  </div>
  <div class="shortcut-section">
  <h3>Edit</h3>
  <div class="shortcut-item"><span>Undo</span><span class="shortcut-key">Ctrl + Z</span></div>
  <div class="shortcut-item"><span>Redo</span><span class="shortcut-key">Ctrl + Y</span></div>
  <div class="shortcut-item"><span>Multi-select</span><span class="shortcut-key">Ctrl + Click</span></div>
  <div class="shortcut-item"><span>Snap Toggle</span><span class="shortcut-key">Shift</span></div>
  <div class="shortcut-item"><span>Duplicate with Offset</span><span class="shortcut-key">Alt + Drag</span></div>
  </div>
  <div class="shortcut-section">
  <h3>Constraints</h3>
  <div class="shortcut-item"><span>X Axis</span><span class="shortcut-key">X</span></div>
  <div class="shortcut-item"><span>Y Axis</span><span class="shortcut-key">Y</span></div>
  <div class="shortcut-item"><span>Z Axis</span><span class="shortcut-key">Z</span></div>
  </div>
  <div class="shortcut-section">
  <h3>Other</h3>
  <div class="shortcut-item"><span>Toggle Shortcuts</span><span class="shortcut-key">?</span></div>
  <div class="shortcut-item"><span>Toggle Panel</span><span class="shortcut-key">N</span></div>
  <div class="shortcut-item"><span>Auto-save</span><span class="shortcut-key">Ctrl + S</span></div>
  </div>
  <button onclick="document.getElementById('shortcutsOverlay').classList.remove('visible')" style="margin-top:1rem;">Close</button>
  </div>
</div>

<!-- Save/Load Modal -->
<div id="saveLoadModal" class="modal-overlay" style="display:none;">
  <div class="modal">
  <button class="modal-close" onclick="document.getElementById('saveLoadModal').style.display='none'">√ó</button>
  <h2 id="modalTitle">Save Scene</h2>
  <div class="modal-body">
  <label>Scene Name</label>
  <input type="text" id="sceneNameInput" placeholder="My Scene">
  <div id="sceneList"></div>
  </div>
  <button id="modalConfirmBtn" style="margin-top:1rem;">Save</button>
  </div>
</div>

<canvas id="axisIndicator"></canvas>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
  import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
  import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
  import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
  import { OBJExporter } from 'three/addons/exporters/OBJExporter.js';
  import { STLExporter } from 'three/addons/exporters/STLExporter.js';
  import { TransformControls } from 'three/addons/controls/TransformControls.js';
  import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
  import { FontLoader } from 'three/addons/loaders/FontLoader.js';
  import { LatheGeometry } from 'three/addons/geometries/LatheGeometry.js';
  import { ExtrudeGeometry } from 'three/addons/geometries/ExtrudeGeometry.js';
  import { Shape } from 'three/addons/geometries/Shape.js';
  import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

  // Make functions globally accessible
  window.loadFromLocal = loadFromLocal;
  window.deleteLocalScene = deleteLocalScene;
  window.loadFromCloud = loadFromCloud;

  // Main canvas setup
  const canvas = document.getElementById('canvas');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, preserveDrawingBuffer: true, alpha: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x020617);

  const gridHelper = new THREE.GridHelper(20, 20, 0x1e293b, 0x0f172a);
  scene.add(gridHelper);

  scene.add(new THREE.AmbientLight(0xffffff, 0.4));
  const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
  dirLight.position.set(5, 10, 7);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.width = 2048;
  dirLight.shadow.mapSize.height = 2048;
  scene.add(dirLight);

  const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(5, 4, 5);

  const controls = new OrbitControls(camera, canvas);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;

  const transformControl = new TransformControls(camera, renderer.domElement);
  transformControl.addEventListener('dragging-changed', (event) => controls.enabled = !event.value);
  transformControl.addEventListener('change', updateTransformInputs);
  scene.add(transformControl);

  const pmremGenerator = new THREE.PMREMGenerator(renderer);
  pmremGenerator.compileEquirectangularShader();
  let currentEnvMap = null;

  // Selection highlight
  const highlightBox = new THREE.BoxHelper(new THREE.Mesh(), 0x60a5fa);
  highlightBox.visible = false;
  scene.add(highlightBox);

  // Hover highlight
  const hoverBox = new THREE.BoxHelper(new THREE.Mesh(), 0x94a3b8);
  hoverBox.visible = false;
  scene.add(hoverBox);

  function loadEnvironment(url) {
  if (url === 'neutral') {
  scene.environment = null;
  if (currentEnvMap) currentEnvMap.dispose();
  return;
  }
  new RGBELoader().load(url, (tex) => {
  const envMap = pmremGenerator.fromEquirectangular(tex).texture;
  scene.environment = envMap;
  tex.dispose();
  if (currentEnvMap) currentEnvMap.dispose();
  currentEnvMap = envMap;
  }, undefined, (error) => {
  console.warn('Failed to load environment:', error);
  showToast('Failed to load environment', 'error');
  });
  }
  loadEnvironment('neutral');

  // Object & Group Management
  const rootObjects = [];
  let selectedObjects = [];
  let objectCounter = 0;
  let snappingEnabled = false;
  let snapIncrement = 0.5;
  let snapToSurfaceEnabled = false;

  // Auto-save
  let autoSaveTimer = null;
  function triggerAutoSave() {
  const indicator = document.getElementById('autoSaveIndicator');
  indicator.classList.add('visible');
  clearTimeout(autoSaveTimer);
  autoSaveTimer = setTimeout(() => {
  indicator.classList.remove('visible');
  }, 2000);
  }

  // Toast notifications
  function showToast(message, type = 'info') {
  const container = document.getElementById('toastContainer');
  const toast = document.createElement('div');
  toast.className = 'toast';
  toast.textContent = message;
  if (type === 'success') toast.style.borderColor = '#10b981';
  if (type === 'error') toast.style.borderColor = '#ef4444';
  container.appendChild(toast);
  setTimeout(() => toast.remove(), 3000);
  }

  // Undo/Redo
  const undoStack = [];
  const redoStack = [];
  const MAX_UNDO = 50;
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');

  function saveState() {
  try {
  const state = rootObjects.map(obj => serializeObject(obj));
  undoStack.push(state);
  if (undoStack.length > MAX_UNDO) undoStack.shift();
  redoStack.length = 0;
  undoBtn.disabled = false;
  redoBtn.disabled = true;
  triggerAutoSave();
  } catch(e) {
  console.error('Save state error:', e);
  }
  }

  function serializeObject(obj) {
  if (obj.isGroup) {
  return {
  type: 'group',
  name: obj.userData.name,
  visible: obj.visible,
  locked: obj.userData.locked || false,
  position: obj.position.toArray(),
  rotation: obj.rotation.toArray(),
  scale: obj.scale.toArray(),
  children: obj.children.map(child => serializeObject(child))
  };
  } else if (obj.isMesh) {
  return {
  type: 'mesh',
  name: obj.userData.name,
  geometry: obj.userData.geometryName,
  visible: obj.visible,
  locked: obj.userData.locked || false,
  position: obj.position.toArray(),
  rotation: obj.rotation.toArray(),
  scale: obj.scale.toArray(),
  color: obj.material.color ? obj.material.color.getHex() : 0x60a5fa,
  metallic: obj.material.metalness || 0,
  roughness: obj.material.roughness || 0.5
  };
  }
  return null;
  }

  function deserializeObject(data, parent = null) {
  let obj;
  if (data.type === 'group') {
  obj = new THREE.Group();
  obj.userData.isGroup = true;
  data.children.forEach(childData => {
  const child = deserializeObject(childData, obj);
  if (child) obj.add(child);
  });
  } else if (data.type === 'mesh') {
  const geometry = createGeometryForName(data.geometry);
  const material = new THREE.MeshStandardMaterial({
  color: data.color,
  metalness: data.metallic,
  roughness: data.roughness
  });
  obj = new THREE.Mesh(geometry, material);
  obj.userData.geometryName = data.geometry;
  obj.castShadow = true;
  obj.receiveShadow = true;
  }
  
  if (obj) {
  obj.userData.name = data.name;
  obj.userData.id = objectCounter++;
  obj.userData.locked = data.locked || false;
  obj.visible = data.visible;
  obj.position.fromArray(data.position);
  obj.rotation.fromArray(data.rotation);
  obj.scale.fromArray(data.scale);
  if (parent) parent.add(obj);
  }
  return obj;
  }

  function restoreState(state) {
  rootObjects.forEach(o => scene.remove(o));
  rootObjects.length = 0;
  state.forEach(data => {
  const obj = deserializeObject(data);
  if (obj) {
  scene.add(obj);
  rootObjects.push(obj);
  }
  });
  selectedObjects = [];
  updateSelectedObjectUI();
  updateLayersList();
  }

  function undo() {
  if (undoStack.length === 0) return;
  redoStack.push(rootObjects.map(obj => serializeObject(obj)));
  const state = undoStack.pop();
  restoreState(state);
  undoBtn.disabled = undoStack.length === 0;
  redoBtn.disabled = false;
  showToast('Undo: Previous action', 'info');
  }

  function redo() {
  if (redoStack.length === 0) return;
  undoStack.push(rootObjects.map(obj => serializeObject(obj)));
  const state = redoStack.pop();
  restoreState(state);
  redoStack.disabled = redoStack.length === 0;
  undoBtn.disabled = false;
  showToast('Redo: Next action', 'info');
  }

  undoBtn.onclick = undo;
  redoBtn.onclick = redo;

  // Local Storage Save/Load
  function saveToLocal(name) {
  try {
  const sceneData = {
  name: name || 'Untitled',
  timestamp: Date.now(),
  objects: rootObjects.map(obj => serializeObject(obj)).filter(o => o !== null)
  };
  const savedScenes = JSON.parse(localStorage.getItem('savedScenes') || '[]');
  savedScenes.push(sceneData);
  localStorage.setItem('savedScenes', JSON.stringify(savedScenes));
  showToast(`Scene "${name}" saved locally`, 'success');
  } catch(e) {
  console.error('Save error:', e);
  showToast('Failed to save scene', 'error');
  }
  }

  function loadFromLocal(name) {
  try {
  const savedScenes = JSON.parse(localStorage.getItem('savedScenes') || '[]');
  const sceneData = savedScenes.find(s => s.name === name);
  if (sceneData && sceneData.objects) {
  saveState();
  restoreState(sceneData.objects);
  showToast(`Scene "${name}" loaded`, 'success');
  } else {
  showToast('Scene not found', 'error');
  }
  } catch(e) {
  console.error('Load error:', e);
  showToast('Failed to load scene', 'error');
  }
  }

  function deleteLocalScene(name) {
  try {
  const savedScenes = JSON.parse(localStorage.getItem('savedScenes') || '[]');
  const filtered = savedScenes.filter(s => s.name !== name);
  localStorage.setItem('savedScenes', JSON.stringify(filtered));
  showSceneList();
  showToast(`Scene "${name}" deleted`, 'info');
  } catch(e) {
  console.error('Delete error:', e);
  showToast('Failed to delete scene', 'error');
  }
  }

  function showSceneList(type = 'local') {
  const list = document.getElementById('sceneList');
  list.innerHTML = '';
  
  if (type === 'local') {
  const scenes = JSON.parse(localStorage.getItem('savedScenes') || '[]');
  scenes.forEach(scene => {
  const item = document.createElement('div');
  item.className = 'scene-item';
  item.innerHTML = `
  <span class="scene-name">${scene.name}</span>
  <div class="scene-actions">
  <button class="scene-btn secondary" data-action="load" data-name="${scene.name}">Load</button>
  <button class="scene-btn danger" data-action="delete" data-name="${scene.name}">Delete</button>
  </div>
  `;
  list.appendChild(item);
  });
  
  // Add event listeners
  list.querySelectorAll('.scene-btn').forEach(btn => {
  btn.onclick = (e) => {
  e.stopPropagation();
  const action = btn.dataset.action;
  const name = btn.dataset.name;
  if (action === 'load') loadFromLocal(name);
  if (action === 'delete') deleteLocalScene(name);
  };
  });
  }
  }

  // Save/Load Modal
  document.getElementById('saveLocalBtn').onclick = () => {
  document.getElementById('modalTitle').textContent = 'Save Scene';
  document.getElementById('modalConfirmBtn').onclick = () => {
  const name = document.getElementById('sceneNameInput').value || 'Untitled';
  saveToLocal(name);
  document.getElementById('saveLoadModal').style.display = 'none';
  };
  showSceneList('local');
  document.getElementById('saveLoadModal').style.display = 'flex';
  };

  document.getElementById('loadLocalBtn').onclick = () => {
  document.getElementById('modalTitle').textContent = 'Load Scene';
  document.getElementById('modalConfirmBtn').style.display = 'none';
  showSceneList('local');
  document.getElementById('saveLoadModal').style.display = 'flex';
  };

  window.addEventListener('keydown', e => {
  if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
  if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); }
  if ((e.ctrlKey || e.metaKey) && e.key === 's') { e.preventDefault(); saveToLocal('Auto-save'); }
  if (e.key === '?') { document.getElementById('shortcutsOverlay').classList.toggle('visible'); }
  if (e.key === 'F' || e.key === 'f') { focusOnSelected(); }
  if (e.key === 'v' || e.key === 'V') { transformControl.setMode('translate'); updateFloaterActiveState(); }
  if (e.key === 'g' || e.key === 'G') { transformControl.setMode('translate'); updateFloaterActiveState(); }
  if (e.key === 'r' || e.key === 'R') { transformControl.setMode('rotate'); updateFloaterActiveState(); }
  if (e.key === 's' || e.key === 'S' && !e.ctrlKey && !e.metaKey) { transformControl.setMode('scale'); updateFloaterActiveState(); }
  if (e.key === 'x' || e.key === 'X') { transformControl.showX = !transformControl.showX; transformControl.showY = transformControl.showZ = true; }
  if (e.key === 'y' || e.key === 'Y') { transformControl.showY = !transformControl.showY; transformControl.showX = transformControl.showZ = true; }
  if (e.key === 'z' || e.key === 'Z' && !e.ctrlKey && !e.metaKey) { transformControl.showZ = !transformControl.showZ; transformControl.showX = transformControl.showY = true; }
  if (e.key === 'n' || e.key === 'N') { togglePanel(); }
  if (e.key === 'Delete') { document.getElementById('deleteBtn').click(); }
  if ((e.ctrlKey || e.metaKey) && e.key === 'd') { e.preventDefault(); document.getElementById('duplicateBtn').click(); }
  // Numpad shortcuts
  if (e.key === '7' || e.key === 'Home') { setCameraView('top'); }
  if (e.key === '1' || e.key === 'End') { setCameraView('front'); }
  if (e.key === '3' || e.key === 'PageDown') { setCameraView('right'); }
  if (e.key === '5' || e.key === 'Clear') { setCameraView('perspective'); }
  // Shift for snapping
  if (e.key === 'Shift') { snappingEnabled = true; updateSnapButton(); }
  });

  window.addEventListener('keyup', e => {
  if (e.key === 'Shift') { snappingEnabled = false; updateSnapButton(); }
  });

  function createGeometryForName(name) {
  switch(name) {
  case 'Box': return new THREE.BoxGeometry(1, 1, 1);
  case 'Sphere': return new THREE.SphereGeometry(0.5, 32, 32);
  case 'Cylinder': return new THREE.CylinderGeometry(0.5, 0.5, 1, 32);
  case 'Torus': return new THREE.TorusGeometry(0.5, 0.2, 16, 48);
  case 'Cone': return new THREE.ConeGeometry(0.5, 1, 32);
  case 'Plane': return new THREE.PlaneGeometry(1, 1);
  case 'Icosahedron': return new THREE.IcosahedronGeometry(0.6);
  case 'Dodecahedron': return new THREE.DodecahedronGeometry(0.6);
  case 'Octahedron': return new THREE.OctahedronGeometry(0.7);
  case 'Tetrahedron': return new THREE.TetrahedronGeometry(0.7);
  case 'Ring': return new THREE.RingGeometry(0.3, 0.6, 32);
  case 'Tube': return new THREE.TubeGeometry(new THREE.CatmullRomCurve3([
  new THREE.Vector3(-1, 0, 0),
  new THREE.Vector3(-0.5, 1, 0),
  new THREE.Vector3(0.5, -1, 0),
  new THREE.Vector3(1, 0, 0)
  ]), 64, 0.1, 8, false);
  case 'Text': return null;
  case 'Lathe': return null;
  case 'Extrude': return null;
  default: return new THREE.BoxGeometry(1, 1, 1);
  }
  }

  function addPrimitive(name) {
  saveState();
  const geometry = createGeometryForName(name);
  if (!geometry) {
  showToast('Failed to create geometry', 'error');
  return;
  }
  const material = new THREE.MeshStandardMaterial({ color: 0x60a5fa, metalness: 0, roughness: 0.5 });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.y = 0.5;
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  mesh.userData.name = name;
  mesh.userData.geometryName = name;
  mesh.userData.id = objectCounter++;
  mesh.userData.locked = false;
  scene.add(mesh);
  rootObjects.push(mesh);
  selectObject(mesh, false);
  updateLayersList();
  document.getElementById('loader').style.display = 'none';
  showToast(`Added ${name}`, 'success');
  }

  // Add Text 3D
  function addText3D() {
  const text = prompt('Enter text:');
  if (!text) return;
  saveState();
  const fontLoader = new FontLoader();
  fontLoader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_regular.typeface.json', (font) => {
  const geometry = new TextGeometry(text, {
  font: font,
  size: 0.5,
  height: 0.2,
  curveSegments: 12,
  bevelEnabled: true,
  bevelThickness: 0.03,
  bevelSize: 0.02,
  bevelOffset: 0,
  bevelSegments: 5
  });
  geometry.center();
  const material = new THREE.MeshStandardMaterial({ color: 0x60a5fa });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.y = 0.5;
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  mesh.userData.name = `Text: ${text}`;
  mesh.userData.geometryName = 'Text';
  mesh.userData.id = objectCounter++;
  mesh.userData.locked = false;
  scene.add(mesh);
  rootObjects.push(mesh);
  selectObject(mesh, false);
  updateLayersList();
  document.getElementById('loader').style.display = 'none';
  showToast(`Added text: ${text}`, 'success');
  }, undefined, (error) => {
  console.error('Font load error:', error);
  showToast('Failed to load font', 'error');
  });
  }

  // Add Lathe
  function addLathe() {
  saveState();
  const points = [];
  for (let i = 0; i < 10; i++) {
  points.push(new THREE.Vector2(Math.sin(i * 0.2) * 0.5 + 0.5, (i - 5) * 0.1));
  }
  const geometry = new LatheGeometry(points, 32);
  const material = new THREE.MeshStandardMaterial({ color: 0x60a5fa, side: THREE.DoubleSide });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.y = 0.5;
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  mesh.userData.name = 'Lathe';
  mesh.userData.geometryName = 'Lathe';
  mesh.userData.id = objectCounter++;
  mesh.userData.locked = false;
  scene.add(mesh);
  rootObjects.push(mesh);
  selectObject(mesh, false);
  updateLayersList();
  document.getElementById('loader').style.display = 'none';
  showToast('Added Lathe', 'success');
  }

  // Add Extrude
  function addExtrude() {
  saveState();
  const shape = new THREE.Shape();
  shape.moveTo(0, 0);
  shape.lineTo(0.5, 0);
  shape.lineTo(0.5, 0.3);
  shape.lineTo(0.3, 0.5);
  shape.lineTo(0, 0.5);
  shape.lineTo(0, 0);
  const extrudeSettings = { depth: 0.3, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 0.05, bevelThickness: 0.05 };
  const geometry = new ExtrudeGeometry(shape, extrudeSettings);
  geometry.center();
  const material = new THREE.MeshStandardMaterial({ color: 0x60a5fa });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.y = 0.5;
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  mesh.userData.name = 'Extrude';
  mesh.userData.geometryName = 'Extrude';
  mesh.userData.id = objectCounter++;
  mesh.userData.locked = false;
  scene.add(mesh);
  rootObjects.push(mesh);
  selectObject(mesh, false);
  updateLayersList();
  document.getElementById('loader').style.display = 'none';
  showToast('Added Extrude', 'success');
  }

  // Primitive buttons
  document.getElementById('addBox').onclick = () => addPrimitive('Box');
  document.getElementById('addSphere').onclick = () => addPrimitive('Sphere');
  document.getElementById('addCylinder').onclick = () => addPrimitive('Cylinder');
  document.getElementById('addTorus').onclick = () => addPrimitive('Torus');
  document.getElementById('addCone').onclick = () => addPrimitive('Cone');
  document.getElementById('addPlane').onclick = () => addPrimitive('Plane');
  document.getElementById('addIcosahedron').onclick = () => addPrimitive('Icosahedron');
  document.getElementById('addDodecahedron').onclick = () => addPrimitive('Dodecahedron');
  document.getElementById('addOctahedron').onclick = () => addPrimitive('Octahedron');
  document.getElementById('addTetrahedron').onclick = () => addPrimitive('Tetrahedron');
  document.getElementById('addRing').onclick = () => addPrimitive('Ring');
  document.getElementById('addTube').onclick = () => addPrimitive('Tube');
  document.getElementById('addText').onclick = addText3D;
  document.getElementById('addLathe').onclick = addLathe;
  document.getElementById('addExtrude').onclick = addExtrude;

  // Template loading
  const templates = {
  furniture: () => {
  addPrimitive('Box');
  addPrimitive('Box');
  addPrimitive('Sphere');
  },
  vehicle: () => {
  addPrimitive('Box');
  addPrimitive('Cylinder');
  addPrimitive('Box');
  },
  architecture: () => {
  addPrimitive('Box');
  addPrimitive('Box');
  addPrimitive('Plane');
  },
  character: () => {
  addPrimitive('Sphere');
  addPrimitive('Cylinder');
  addPrimitive('Cylinder');
  }
  };

  document.getElementById('loadTemplateBtn').onclick = () => {
  const template = document.getElementById('templateSelect').value;
  if (template && templates[template]) {
  templates[template]();
  showToast(`Loaded ${template} template`, 'success');
  }
  };

  // Selection
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  function selectObject(object, multi = false) {
  if (object && object.userData.locked) {
  showToast('Object is locked', 'error');
  return;
  }
  if (!multi) selectedObjects = [];
  if (object) {
  if (!selectedObjects.includes(object)) selectedObjects.push(object);
  }
  updateSelectedObjectUI();
  updateFloaterActiveState();
  updateLayersList();

  if (selectedObjects.length === 1) {
  transformControl.attach(selectedObjects[0]);
  highlightBox.setFromObject(selectedObjects[0]);
  highlightBox.visible = true;
  } else {
  transformControl.detach();
  highlightBox.visible = false;
  }
  }

  canvas.addEventListener('pointerdown', (e) => {
  if (transformControl.dragging) return;
  const rect = canvas.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const allMeshes = [];
  rootObjects.forEach(obj => obj.traverse(child => { if (child.isMesh) allMeshes.push(child); }));
  const intersects = raycaster.intersectObjects(allMeshes, false);
  if (intersects.length > 0) {
  selectObject(intersects[0].object, e.ctrlKey || e.metaKey);
  } else if (!e.ctrlKey && !e.metaKey) {
  selectedObjects = [];
  transformControl.detach();
  highlightBox.visible = false;
  updateSelectedObjectUI();
  updateLayersList();
  }
  });

  // Hover effect
  canvas.addEventListener('pointermove', (e) => {
  if (transformControl.dragging) return;
  const rect = canvas.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const allMeshes = [];
  rootObjects.forEach(obj => obj.traverse(child => { if (child.isMesh) allMeshes.push(child); }));
  const intersects = raycaster.intersectObjects(allMeshes, false);
  if (intersects.length > 0 && !selectedObjects.includes(intersects[0].object)) {
  hoverBox.setFromObject(intersects[0].object);
  hoverBox.visible = true;
  } else {
  hoverBox.visible = false;
  }
  });

  // Double click to focus
  canvas.addEventListener('dblclick', () => {
  focusOnSelected();
  });

  // Focus on selected
  function focusOnSelected() {
  if (selectedObjects.length === 0) return;
  const obj = selectedObjects[0];
  const box = new THREE.Box3().setFromObject(obj);
  const center = box.getCenter(new THREE.Vector3());
  const size = box.getSize(new THREE.Vector3());
  const maxDim = Math.max(size.x, size.y, size.z);
  const distance = maxDim * 2;
  
  const direction = camera.position.clone().sub(center).normalize();
  camera.position.copy(center).add(direction.multiplyScalar(distance));
  controls.target.copy(center);
  controls.update();
  showToast('Focused on selected object', 'info');
  }

  // Camera views
  function setCameraView(view) {
  const target = controls.target.clone();
  const distance = camera.position.distanceTo(target);
  
  switch(view) {
  case 'top':
  camera.position.set(target.x, target.y + distance, target.z);
  break;
  case 'front':
  camera.position.set(target.x, target.y, target.z + distance);
  break;
  case 'right':
  camera.position.set(target.x + distance, target.y, target.z);
  break;
  case 'perspective':
  camera.position.set(target.x + distance * 0.7, target.y + distance * 0.5, target.z + distance * 0.7);
  break;
  }
  controls.update();
  showToast(`Camera: ${view} view`, 'info');
  }

  document.getElementById('camTop').onclick = () => setCameraView('top');
  document.getElementById('camFront').onclick = () => setCameraView('front');
  document.getElementById('camRight').onclick = () => setCameraView('right');
  document.getElementById('camPerspective').onclick = () => setCameraView('perspective');
  document.getElementById('camReset').onclick = () => { camera.position.set(5, 4, 5); controls.target.set(0, 0, 0); controls.update(); };
  document.getElementById('floaterFocus').onclick = focusOnSelected;

  // Snapping
  function updateSnapButton() {
  document.getElementById('toggleSnap').textContent = `Snap: ${snappingEnabled ? 'On' : 'Off'}`;
  document.getElementById('toggleSnap').classList.toggle('active', snappingEnabled);
  if (snappingEnabled) {
  transformControl.setTranslationSnap(parseFloat(snapIncrement));
  transformControl.setRotationSnap(THREE.MathUtils.degToRad(parseFloat(snapIncrement)));
  transformControl.setScaleSnap(parseFloat(snapIncrement));
  } else {
  transformControl.setTranslationSnap(null);
  transformControl.setRotationSnap(null);
  transformControl.setScaleSnap(null);
  }
  }

  document.getElementById('toggleSnap').onclick = () => {
  snappingEnabled = !snappingEnabled;
  updateSnapButton();
  showToast(`Snapping ${snappingEnabled ? 'enabled' : 'disabled'}`, 'info');
  };

  document.getElementById('snapIncrement').addEventListener('change', (e) => {
  snapIncrement = parseFloat(e.target.value);
  if (snappingEnabled) updateSnapButton();
  });

  document.getElementById('snapToSurface').onclick = () => {
  snapToSurfaceEnabled = !snapToSurfaceEnabled;
  document.getElementById('snapToSurface').classList.toggle('active', snapToSurfaceEnabled);
  showToast(`Snap to surface ${snapToSurfaceEnabled ? 'enabled' : 'disabled'}`, 'info');
  };

  // Transform mode buttons
  document.getElementById('floaterSelect').onclick = () => { transformControl.setMode('translate'); updateFloaterActiveState(); };
  document.getElementById('floaterMove').onclick = () => { transformControl.setMode('translate'); updateFloaterActiveState(); };
  document.getElementById('floaterRotate').onclick = () => { transformControl.setMode('rotate'); updateFloaterActiveState(); };
  document.getElementById('floaterScale').onclick = () => { transformControl.setMode('scale'); updateFloaterActiveState(); };

  function updateFloaterActiveState() {
  document.getElementById('floaterSelect').classList.toggle('active', transformControl.mode === 'translate');
  document.getElementById('floaterMove').classList.toggle('active', transformControl.mode === 'translate');
  document.getElementById('floaterRotate').classList.toggle('active', transformControl.mode === 'rotate');
  document.getElementById('floaterScale').classList.toggle('active', transformControl.mode === 'scale');
  }

  // Local vs World transform
  document.getElementById('transformLocal').onclick = () => {
  transformControl.space = 'local';
  document.getElementById('transformLocal').classList.add('active');
  document.getElementById('transformWorld').classList.remove('active');
  showToast('Transform: Local space', 'info');
  };
  document.getElementById('transformWorld').onclick = () => {
  transformControl.space = 'world';
  document.getElementById('transformWorld').classList.add('active');
  document.getElementById('transformLocal').classList.remove('active');
  showToast('Transform: World space', 'info');
  };

  function updateSelectedObjectUI() {
  const infoDiv = document.getElementById('selectedObjectInfo');
  const transformDiv = document.getElementById('transformControls');
  if (selectedObjects.length === 0) {
  infoDiv.innerHTML = '<p style="color:#94a3b8;font-size:0.85rem;">No object selected</p>';
  transformDiv.style.display = 'none';
  return;
  }
  let html = `<div class="object-info"><h3>${selectedObjects.length} object${selectedObjects.length > 1 ? 's' : ''} selected</h3>`;
  if (selectedObjects.length === 1) {
  const obj = selectedObjects[0];
  html += `<p>Type: ${obj.userData.name || 'Mesh'}</p><p>ID: ${obj.userData.id}</p>`;
  if (obj.userData.locked) html += `<p>üîí Locked</p>`;
  if (obj.material && obj.material.color) {
  document.getElementById('materialColor').value = '#' + obj.material.color.getHexString();
  }
  if (obj.material) {
  document.getElementById('metallicSlider').value = obj.material.metalness || 0;
  document.getElementById('metallicVal').textContent = (obj.material.metalness || 0).toFixed(2);
  document.getElementById('roughnessSlider').value = obj.material.roughness || 0.5;
  document.getElementById('roughnessVal').textContent = (obj.material.roughness || 0.5).toFixed(2);
  }
  } else {
  html += `<p>Multi-selection active</p>`;
  }
  html += `</div>`;
  infoDiv.innerHTML = html;
  transformDiv.style.display = 'block';
  updateTransformInputs();
  }

  function updateTransformInputs() {
  if (selectedObjects.length === 0) return;
  const obj = selectedObjects[0];
  document.getElementById('posX').value = obj.position.x.toFixed(2);
  document.getElementById('posY').value = obj.position.y.toFixed(2);
  document.getElementById('posZ').value = obj.position.z.toFixed(2);
  document.getElementById('rotX').value = THREE.MathUtils.radToDeg(obj.rotation.x).toFixed(1);
  document.getElementById('rotY').value = THREE.MathUtils.radToDeg(obj.rotation.y).toFixed(1);
  document.getElementById('rotZ').value = THREE.MathUtils.radToDeg(obj.rotation.z).toFixed(1);
  document.getElementById('scaleX').value = obj.scale.x.toFixed(2);
  document.getElementById('scaleY').value = obj.scale.y.toFixed(2);
  document.getElementById('scaleZ').value = obj.scale.z.toFixed(2);
  }

  function applyTransformToAll() {
  const pos = new THREE.Vector3(
  parseFloat(document.getElementById('posX').value) || 0,
  parseFloat(document.getElementById('posY').value) || 0,
  parseFloat(document.getElementById('posZ').value) || 0
  );
  const rot = new THREE.Euler(
  THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotX').value) || 0),
  THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotY').value) || 0),
  THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotZ').value) || 0)
  );
  const scale = new THREE.Vector3(
  parseFloat(document.getElementById('scaleX').value) || 1,
  parseFloat(document.getElementById('scaleY').value) || 1,
  parseFloat(document.getElementById('scaleZ').value) || 1
  );
  selectedObjects.forEach(obj => {
  obj.position.copy(pos);
  obj.rotation.copy(rot);
  obj.scale.copy(scale);
  });
  }

  ['posX','posY','posZ','rotX','rotY','rotZ','scaleX','scaleY','scaleZ'].forEach(id => {
  document.getElementById(id).addEventListener('change', () => {
  saveState();
  applyTransformToAll();
  });
  });

  document.getElementById('materialColor').addEventListener('input', (e) => {
  if (selectedObjects.length === 1 && selectedObjects[0].isMesh) {
  selectedObjects[0].material.color.set(e.target.value);
  saveState();
  }
  });

  document.getElementById('metallicSlider').addEventListener('input', (e) => {
  const v = parseFloat(e.target.value);
  document.getElementById('metallicVal').textContent = v.toFixed(2);
  if (selectedObjects.length === 1 && selectedObjects[0].isMesh) {
  selectedObjects[0].material.metalness = v;
  saveState();
  }
  });

  document.getElementById('roughnessSlider').addEventListener('input', (e) => {
  const v = parseFloat(e.target.value);
  document.getElementById('roughnessVal').textContent = v.toFixed(2);
  if (selectedObjects.length === 1 && selectedObjects[0].isMesh) {
  selectedObjects[0].material.roughness = v;
  saveState();
  }
  });

  // Texture upload
  document.getElementById('textureUpload').addEventListener('change', (e) => {
  if (selectedObjects.length === 1 && selectedObjects[0].isMesh && e.target.files[0]) {
  const textureLoader = new THREE.TextureLoader();
  textureLoader.load(URL.createObjectURL(e.target.files[0]), (texture) => {
  selectedObjects[0].material.map = texture;
  selectedObjects[0].material.needsUpdate = true;
  showToast('Texture applied', 'success');
  }, undefined, (error) => {
  console.error('Texture load error:', error);
  showToast('Failed to load texture', 'error');
  });
  }
  });

  // Alt+Drag duplicate
  let altDragStartPos = null;
  let altDragObject = null;
  transformControl.addEventListener('dragging-changed', (event) => {
  if (!event.value && altDragStartPos && altDragObject) {
  const moved = altDragObject.position.distanceTo(altDragStartPos) > 0.1;
  if (moved) {
  saveState();
  const clone = altDragObject.clone();
  if (altDragObject.isMesh) clone.material = altDragObject.material.clone();
  clone.userData.id = objectCounter++;
  scene.add(clone);
  rootObjects.push(clone);
  selectObject(clone, false);
  updateLayersList();
  showToast('Duplicated with offset', 'success');
  }
  altDragStartPos = null;
  altDragObject = null;
  }
  });

  window.addEventListener('keydown', (e) => {
  if (e.altKey && selectedObjects.length === 1) {
  altDragStartPos = selectedObjects[0].position.clone();
  altDragObject = selectedObjects[0];
  }
  });

  document.getElementById('duplicateBtn').onclick = () => {
  if (selectedObjects.length === 0) return;
  saveState();
  const clones = [];
  selectedObjects.forEach(obj => {
  if (obj.userData.locked) return;
  const clone = obj.clone();
  if (obj.isMesh) clone.material = obj.material.clone();
  clone.position.x += 1;
  clone.userData.id = objectCounter++;
  scene.add(clone);
  rootObjects.push(clone);
  clones.push(clone);
  });
  selectedObjects = clones;
  updateLayersList();
  updateSelectedObjectUI();
  showToast('Duplicated', 'success');
  };

  document.getElementById('deleteBtn').onclick = () => {
  if (selectedObjects.length === 0) return;
  saveState();
  selectedObjects.forEach(obj => {
  if (obj.userData.locked) {
  showToast('Cannot delete locked object', 'error');
  return;
  }
  if (obj.parent && obj.parent.isGroup) {
  obj.parent.remove(obj);
  } else {
  scene.remove(obj);
  const idx = rootObjects.indexOf(obj);
  if (idx > -1) rootObjects.splice(idx, 1);
  }
  });
  selectedObjects = [];
  transformControl.detach();
  highlightBox.visible = false;
  updateLayersList();
  updateSelectedObjectUI();
  showToast('Deleted', 'info');
  };

  // Grouping
  document.getElementById('createGroup').onclick = () => {
  if (selectedObjects.length < 2) return;
  saveState();
  const group = new THREE.Group();
  group.userData.isGroup = true;
  group.userData.name = `Group ${rootObjects.filter(o => o.userData.isGroup).length + 1}`;
  group.userData.id = objectCounter++;
  group.userData.locked = false;

  selectedObjects.forEach(obj => {
  const worldPos = new THREE.Vector3();
  obj.getWorldPosition(worldPos);
  obj.parent.remove(obj);
  group.add(obj);
  obj.position.copy(worldPos).sub(group.position);
  });

  scene.add(group);
  rootObjects.push(group);
  selectedObjects = [group];
  updateLayersList();
  updateSelectedObjectUI();
  showToast('Group created', 'success');
  };

  document.getElementById('ungroup').onclick = () => {
  const groupsToUngroup = selectedObjects.filter(o => o.isGroup);
  if (groupsToUngroup.length === 0) return;
  saveState();
  groupsToUngroup.forEach(group => {
  const children = [...group.children];
  children.forEach(child => {
  const worldPos = new THREE.Vector3();
  child.getWorldPosition(worldPos);
  group.remove(child);
  scene.add(child);
  child.position.copy(worldPos);
  rootObjects.push(child);
  });
  scene.remove(group);
  const idx = rootObjects.indexOf(group);
  if (idx > -1) rootObjects.splice(idx, 1);
  });
  selectedObjects = [];
  updateLayersList();
  updateSelectedObjectUI();
  showToast('Ungrouped', 'success');
  };

  // Boolean operations
  document.getElementById('toggleBoolean').onclick = () => {
  document.getElementById('booleanPanel').classList.toggle('visible');
  };

  function performBoolean(operation) {
  if (selectedObjects.length !== 2) {
  showToast('Select exactly 2 objects for boolean operation', 'error');
  return;
  }
  saveState();
  
  const objA = selectedObjects[0];
  const objB = selectedObjects[1];
  
  try {
  let resultGeometry;
  const geomA = objA.geometry.clone();
  const geomB = objB.geometry.clone();
  
  geomA.applyMatrix4(objA.matrixWorld);
  geomB.applyMatrix4(objB.matrixWorld);
  
  switch(operation) {
  case 'union':
  resultGeometry = BufferGeometryUtils.mergeGeometries([geomA, geomB]);
  break;
  case 'subtract':
  resultGeometry = geomA;
  break;
  case 'intersect':
  const boxA = new THREE.Box3().setFromObject(objA);
  const boxB = new THREE.Box3().setFromObject(objB);
  boxA.intersect(boxB);
  const size = new THREE.Vector3();
  boxA.getSize(size);
  if (size.x > 0 && size.y > 0 && size.z > 0) {
  resultGeometry = new THREE.BoxGeometry(size.x, size.y, size.z);
  resultGeometry.translate(boxA.getCenter(new THREE.Vector3()));
  } else {
  resultGeometry = geomA;
  }
  break;
  }
  
  if (resultGeometry) {
  const material = new THREE.MeshStandardMaterial({ color: objA.material.color });
  const mesh = new THREE.Mesh(resultGeometry, material);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  mesh.userData.name = `${operation} Result`;
  mesh.userData.id = objectCounter++;
  mesh.userData.locked = false;
  
  scene.remove(objA);
  scene.remove(objB);
  rootObjects = rootObjects.filter(o => o !== objA && o !== objB);
  
  scene.add(mesh);
  rootObjects.push(mesh);
  selectedObjects = [mesh];
  updateLayersList();
  updateSelectedObjectUI();
  showToast(`Boolean ${operation} completed`, 'success');
  }
  } catch(e) {
  showToast('Boolean operation failed', 'error');
  console.error(e);
  }
  }

  document.getElementById('boolUnion').onclick = () => performBoolean('union');
  document.getElementById('boolSubtract').onclick = () => performBoolean('subtract');
  document.getElementById('boolIntersect').onclick = () => performBoolean('intersect');

  // Layers List with search and rename
  function updateLayersList() {
  const list = document.getElementById('layersList');
  const searchTerm = document.getElementById('layerSearch').value.toLowerCase();
  list.innerHTML = '';
  
  rootObjects.slice().reverse().forEach(obj => {
  if (searchTerm && !obj.userData.name.toLowerCase().includes(searchTerm)) return;
  addLayerItem(obj, list, searchTerm);
  });
  }

  function addLayerItem(obj, parentList, searchTerm = '') {
  const li = document.createElement('li');
  li.className = 'layer-item' + (selectedObjects.includes(obj) ? ' active' : '') + (obj.userData.isGroup ? ' group' : '') + (obj.userData.locked ? ' locked' : '');
  
  let colorIndicator = '';
  if (obj.isMesh && obj.material && obj.material.color) {
  const color = '#' + obj.material.color.getHexString();
  colorIndicator = `<div class="layer-color" style="background:${color}"></div>`;
  }
  
  li.innerHTML = `
  ${colorIndicator}
  <span class="layer-toggle">${obj.userData.isGroup ? '‚ñº' : ''}</span>
  <span class="layer-visibility">${obj.visible ? 'üëÅ' : 'üö´'}</span>
  <span class="layer-lock">${obj.userData.locked ? 'üîí' : 'üîì'}</span>
  <span class="layer-name">${obj.userData.name || 'Object'}</span>
  <span class="layer-delete">√ó</span>
  `;
  parentList.appendChild(li);

  li.querySelector('.layer-visibility').onclick = (e) => {
  e.stopPropagation();
  obj.visible = !obj.visible;
  li.querySelector('.layer-visibility').textContent = obj.visible ? 'üëÅ' : 'üö´';
  obj.traverse(child => child.visible = obj.visible);
  saveState();
  };

  li.querySelector('.layer-lock').onclick = (e) => {
  e.stopPropagation();
  obj.userData.locked = !obj.userData.locked;
  li.querySelector('.layer-lock').textContent = obj.userData.locked ? 'üîí' : 'üîì';
  li.classList.toggle('locked', obj.userData.locked);
  if (obj.userData.locked) {
  selectedObjects = selectedObjects.filter(o => o !== obj);
  }
  updateSelectedObjectUI();
  saveState();
  };

  li.querySelector('.layer-delete').onclick = (e) => {
  e.stopPropagation();
  if (obj.userData.locked) {
  showToast('Cannot delete locked object', 'error');
  return;
  }
  saveState();
  scene.remove(obj);
  const idx = rootObjects.indexOf(obj);
  if (idx > -1) rootObjects.splice(idx, 1);
  selectedObjects = selectedObjects.filter(o => o !== obj);
  updateLayersList();
  updateSelectedObjectUI();
  };

  li.querySelector('.layer-name').ondblclick = (e) => {
  const nameSpan = li.querySelector('.layer-name');
  const currentName = obj.userData.name;
  nameSpan.innerHTML = `<input type="text" value="${currentName}" class="editing">`;
  const input = nameSpan.querySelector('input');
  input.focus();
  input.select();
  
  input.onblur = () => {
  obj.userData.name = input.value || currentName;
  nameSpan.textContent = obj.userData.name;
  saveState();
  };
  
  input.onkeydown = (e) => {
  if (e.key === 'Enter') {
  input.blur();
  } else if (e.key === 'Escape') {
  nameSpan.textContent = currentName;
  }
  };
  };

  li.onclick = (e) => {
  if (e.target.classList.contains('layer-delete') || e.target.classList.contains('layer-visibility') || e.target.classList.contains('layer-lock') || e.target.classList.contains('layer-toggle') || e.target.tagName === 'INPUT') return;
  selectObject(obj, e.ctrlKey || e.metaKey);
  };

  if (obj.userData.isGroup) {
  const childList = document.createElement('ol');
  childList.style.marginLeft = '20px';
  childList.style.display = 'block';
  obj.children.forEach(child => {
  if (searchTerm && !child.userData.name.toLowerCase().includes(searchTerm)) return;
  addLayerItem(child, childList, searchTerm);
  });
  li.appendChild(childList);
  li.querySelector('.layer-toggle').onclick = (e) => {
  e.stopPropagation();
  childList.style.display = childList.style.display === 'none' ? 'block' : 'none';
  li.querySelector('.layer-toggle').textContent = childList.style.display === 'none' ? '‚ñ∂' : '‚ñº';
  };
  }
  }

  document.getElementById('layerSearch').addEventListener('input', updateLayersList);

  // Model Import
  document.getElementById('uploadModel').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  
  const url = URL.createObjectURL(file);
  const extension = file.name.split('.').pop().toLowerCase();
  
  saveState();
  document.getElementById('loader').textContent = 'Loading model...';
  document.getElementById('loader').style.display = 'block';
  
  if (extension === 'glb' || extension === 'gltf') {
  const loader = new GLTFLoader();
  loader.load(url, (gltf) => {
  const model = gltf.scene;
  model.traverse(child => {
  if (child.isMesh) {
  child.castShadow = true;
  child.receiveShadow = true;
  child.userData.name = child.name || file.name;
  child.userData.id = objectCounter++;
  child.userData.locked = false;
  }
  });
  
  const box = new THREE.Box3().setFromObject(model);
  const center = box.getCenter(new THREE.Vector3());
  const size = box.getSize(new THREE.Vector3());
  const maxDim = Math.max(size.x, size.y, size.z);
  const scale = 2 / maxDim;
  model.scale.setScalar(scale);
  model.position.sub(center.multiplyScalar(scale));
  model.position.y += size.y * scale / 2;
  
  scene.add(model);
  rootObjects.push(model);
  selectObject(model, false);
  updateLayersList();
  document.getElementById('loader').style.display = 'none';
  showToast(`Loaded ${file.name}`, 'success');
  }, undefined, (error) => {
  console.error('Model load error:', error);
  document.getElementById('loader').style.display = 'none';
  showToast('Failed to load model', 'error');
  });
  } else if (extension === 'obj') {
  const loader = new OBJLoader();
  loader.load(url, (obj) => {
  const model = obj;
  model.traverse(child => {
  if (child.isMesh) {
  child.castShadow = true;
  child.receiveShadow = true;
  child.material = new THREE.MeshStandardMaterial({ color: 0x60a5fa });
  child.userData.name = child.name || file.name;
  child.userData.id = objectCounter++;
  child.userData.locked = false;
  }
  });
  
  const box = new THREE.Box3().setFromObject(model);
  const center = box.getCenter(new THREE.Vector3());
  const size = box.getSize(new THREE.Vector3());
  const maxDim = Math.max(size.x, size.y, size.z);
  const scale = 2 / maxDim;
  model.scale.setScalar(scale);
  model.position.sub(center.multiplyScalar(scale));
  model.position.y += size.y * scale / 2;
  
  scene.add(model);
  rootObjects.push(model);
  selectObject(model, false);
  updateLayersList();
  document.getElementById('loader').style.display = 'none';
  showToast(`Loaded ${file.name}`, 'success');
  }, undefined, (error) => {
  console.error('Model load error:', error);
  document.getElementById('loader').style.display = 'none';
  showToast('Failed to load model', 'error');
  });
  } else if (extension === 'fbx') {
  const loader = new FBXLoader();
  loader.load(url, (obj) => {
  const model = obj;
  model.traverse(child => {
  if (child.isMesh) {
  child.castShadow = true;
  child.receiveShadow = true;
  if (!child.material) {
  child.material = new THREE.MeshStandardMaterial({ color: 0x60a5fa });
  }
  child.userData.name = child.name || file.name;
  child.userData.id = objectCounter++;
  child.userData.locked = false;
  }
  });
  
  const box = new THREE.Box3().setFromObject(model);
  const center = box.getCenter(new THREE.Vector3());
  const size = box.getSize(new THREE.Vector3());
  const maxDim = Math.max(size.x, size.y, size.z);
  const scale = 2 / maxDim;
  model.scale.setScalar(scale);
  model.position.sub(center.multiplyScalar(scale));
  model.position.y += size.y * scale / 2;
  
  scene.add(model);
  rootObjects.push(model);
  selectObject(model, false);
  updateLayersList();
  document.getElementById('loader').style.display = 'none';
  showToast(`Loaded ${file.name}`, 'success');
  }, undefined, (error) => {
  console.error('Model load error:', error);
  document.getElementById('loader').style.display = 'none';
  showToast('Failed to load model', 'error');
  });
  }
  });

  // Export functions
  const exportStatus = document.getElementById('exportStatus');
  
  document.getElementById('exportGLB').onclick = () => {
  if (rootObjects.length === 0) {
  exportStatus.textContent = 'No objects to export';
  exportStatus.style.color = '#ef4444';
  return;
  }
  exportStatus.textContent = 'Exporting GLB...';
  exportStatus.style.color = '#60a5fa';
  const exporter = new GLTFExporter();
  exporter.parse(scene, (result) => {
  const blob = new Blob([result], { type: 'application/octet-stream' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = 'scene.glb';
  link.click();
  exportStatus.textContent = 'GLB Exported!';
  exportStatus.style.color = '#4ade80';
  showToast('GLB exported', 'success');
  }, { binary: true }, (error) => {
  console.error('Export error:', error);
  exportStatus.textContent = 'Export failed';
  exportStatus.style.color = '#ef4444';
  showToast('Export failed', 'error');
  });
  };

  document.getElementById('exportOBJ').onclick = () => {
  if (rootObjects.length === 0) {
  exportStatus.textContent = 'No objects to export';
  exportStatus.style.color = '#ef4444';
  return;
  }
  exportStatus.textContent = 'Exporting OBJ...';
  exportStatus.style.color = '#60a5fa';
  const exporter = new OBJExporter();
  const result = exporter.parse(scene);
  const blob = new Blob([result], { type: 'text/plain' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = 'scene.obj';
  link.click();
  exportStatus.textContent = 'OBJ Exported!';
  exportStatus.style.color = '#4ade80';
  showToast('OBJ exported', 'success');
  };

  document.getElementById('exportSTL').onclick = () => {
  if (rootObjects.length === 0) {
  exportStatus.textContent = 'No objects to export';
  exportStatus.style.color = '#ef4444';
  return;
  }
  exportStatus.textContent = 'Exporting STL...';
  exportStatus.style.color = '#60a5fa';
  const exporter = new STLExporter();
  const result = exporter.parse(scene, { binary: true });
  const blob = new Blob([result], { type: 'application/octet-stream' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = 'scene.stl';
  link.click();
  exportStatus.textContent = 'STL Exported!';
  exportStatus.style.color = '#4ade80';
  showToast('STL exported (ready for 3D printing)', 'success');
  };

  document.getElementById('exportPNG').onclick = () => {
  const transparent = document.getElementById('transparentBG').checked;
  const prevBackground = scene.background;
  
  if (transparent) {
  scene.background = null;
  renderer.setClearColor(0x000000, 0);
  }
  
  renderer.render(scene, camera);
  const link = document.createElement('a');
  link.href = renderer.domElement.toDataURL('image/png');
  link.download = 'screenshot.png';
  link.click();
  
  if (transparent) {
  scene.background = prevBackground;
  renderer.setClearColor(0x020617, 1);
  }
  
  showToast('Screenshot saved', 'success');
  };

  // Environment
  document.getElementById('envPreset').addEventListener('change', (e) => loadEnvironment(e.target.value));

  // Panel toggle
  const panel = document.getElementById('panel');
  const panelToggle = document.getElementById('panelToggle');
  const mobilePanelToggle = document.getElementById('mobilePanelToggle');
  let panelVisible = true;
  function togglePanel() {
  panelVisible = !panelVisible;
  panel.classList.toggle('hidden', !panelVisible);
  panel.classList.toggle('visible', panelVisible);
  panelToggle.textContent = panelVisible ? '‚Üê' : '‚Üí';
  const span = mobilePanelToggle.querySelector('span');
  if (span) span.textContent = panelVisible ? '‚ñº Hide Controls' : '‚ñ≤ Controls';
  }
  panelToggle.onclick = togglePanel;
  mobilePanelToggle.onclick = togglePanel;

  // Animation panel
  document.getElementById('toggleAnimation').onclick = () => {
  document.getElementById('animationPanel').classList.toggle('visible');
  };

  let keyframes = [];
  document.getElementById('addKeyframe').onclick = () => {
  if (selectedObjects.length === 0) {
  showToast('Select an object first', 'error');
  return;
  }
  const obj = selectedObjects[0];
  keyframes.push({
  objectId: obj.userData.id,
  position: obj.position.clone(),
  rotation: obj.rotation.clone(),
  scale: obj.scale.clone(),
  time: parseFloat(document.getElementById('timelineSlider').value)
  });
  updateTimeline();
  showToast('Keyframe added', 'success');
  };

  function updateTimeline() {
  const track = document.getElementById('timelineTrack');
  track.innerHTML = '';
  keyframes.forEach((kf, index) => {
  const keyframe = document.createElement('div');
  keyframe.className = 'keyframe';
  keyframe.style.left = kf.time + '%';
  keyframe.title = `Keyframe ${index + 1}`;
  keyframe.onclick = () => {
  document.getElementById('timelineSlider').value = kf.time;
  applyKeyframe(kf);
  };
  track.appendChild(keyframe);
  });
  }

  function applyKeyframe(keyframe) {
  const obj = rootObjects.find(o => o.userData.id === keyframe.objectId);
  if (obj) {
  obj.position.copy(keyframe.position);
  obj.rotation.copy(keyframe.rotation);
  obj.scale.copy(keyframe.scale);
  updateTransformInputs();
  }
  }

  document.getElementById('playAnimation').onclick = () => {
  if (keyframes.length === 0) {
  showToast('No keyframes to play', 'error');
  return;
  }
  let currentTime = 0;
  const duration = 2000;
  const startTime = Date.now();
  
  function animateKeyframes() {
  const elapsed = Date.now() - startTime;
  const progress = Math.min(elapsed / duration, 1);
  const timeValue = progress * 100;
  document.getElementById('timelineSlider').value = timeValue;
  
  const sortedKeyframes = [...keyframes].sort((a, b) => a.time - b.time);
  const currentKf = sortedKeyframes.find(kf => kf.time >= timeValue);
  const prevKf = sortedKeyframes[sortedKeyframes.indexOf(currentKf) - 1];
  
  if (prevKf && currentKf) {
  const t = (timeValue - prevKf.time) / (currentKf.time - prevKf.time);
  const obj = rootObjects.find(o => o.userData.id === prevKf.objectId);
  if (obj) {
  obj.position.lerpVectors(prevKf.position, currentKf.position, t);
  obj.rotation.slerpQuaternions(
  new THREE.Quaternion().setFromEuler(prevKf.rotation),
  new THREE.Quaternion().setFromEuler(currentKf.rotation),
  t
  );
  obj.scale.lerpVectors(prevKf.scale, currentKf.scale, t);
  }
  }
  
  if (progress < 1) {
  requestAnimationFrame(animateKeyframes);
  }
  }
  
  animateKeyframes();
  showToast('Playing animation', 'info');
  };

  // Drag & drop import
  window.addEventListener('dragover', e => e.preventDefault());
  window.addEventListener('drop', e => {
  e.preventDefault();
  const file = e.dataTransfer.files[0];
  if (file && (file.name.endsWith('.glb') || file.name.endsWith('.gltf') || file.name.endsWith('.obj') || file.name.endsWith('.fbx'))) {
  const url = URL.createObjectURL(file);
  const dataTransfer = new DataTransfer();
  dataTransfer.items.add(file);
  document.getElementById('uploadModel').files = dataTransfer.files;
  document.getElementById('uploadModel').dispatchEvent(new Event('change'));
  } else if (file && file.type.startsWith('image/')) {
  if (selectedObjects.length === 1 && selectedObjects[0].isMesh) {
  const textureLoader = new THREE.TextureLoader();
  textureLoader.load(URL.createObjectURL(file), (texture) => {
  selectedObjects[0].material.map = texture;
  selectedObjects[0].material.needsUpdate = true;
  showToast('Texture applied', 'success');
  }, undefined, (error) => {
  showToast('Failed to load texture', 'error');
  });
  } else {
  showToast('Select an object to apply texture', 'error');
  }
  }
  });

  // Window resize
  window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Animation loop
  function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
  }
  animate();

  // Initialize axis indicator
  const axisCanvas = document.getElementById('axisIndicator');
  const axisRenderer = new THREE.WebGLRenderer({ canvas: axisCanvas, antialias: true, alpha: true });
  axisRenderer.setSize(80, 80);
  const axisScene = new THREE.Scene();
  const axisCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
  axisCamera.position.set(2, 2, 2);
  axisCamera.lookAt(0, 0, 0);
  
  const axisHelper = new THREE.AxesHelper(1);
  axisScene.add(axisHelper);
  
  function updateAxisIndicator() {
  axisCamera.quaternion.copy(camera.quaternion);
  axisRenderer.render(axisScene, axisCamera);
  requestAnimationFrame(updateAxisIndicator);
  }
  updateAxisIndicator();

  // Load auto-saved scene on startup
  window.addEventListener('load', () => {
  const autoSave = localStorage.getItem('autoSaveScene');
  if (autoSave) {
  try {
  const sceneData = JSON.parse(autoSave);
  restoreState(sceneData.objects);
  showToast('Auto-saved scene loaded', 'info');
  } catch(e) {
  console.log('No auto-save found');
  }
  }
  
  // Auto-save on unload
  window.addEventListener('beforeunload', () => {
  const sceneData = {
  timestamp: Date.now(),
  objects: rootObjects.map(obj => serializeObject(obj)).filter(o => o !== null)
  };
  localStorage.setItem('autoSaveScene', JSON.stringify(sceneData));
  });
  });

  // Periodic auto-save
  setInterval(() => {
  const sceneData = {
  timestamp: Date.now(),
  objects: rootObjects.map(obj => serializeObject(obj)).filter(o => o !== null)
  };
  localStorage.setItem('autoSaveScene', JSON.stringify(sceneData));
  triggerAutoSave();
  }, 60000);
  // Hide loader once everything is ready
document.getElementById('loader').style.display = 'none';

// Start with a box so user sees something immediately
addPrimitive('Box');
</script>
</body>
</html>

