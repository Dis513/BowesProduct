<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>BowesProduct </title>
  <style>
  *, *::before, *::after { box-sizing: border-box; }
  html, body { margin: 0; height: 100%; background: #020617; color: white; font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif; overflow: hidden; -webkit-font-smoothing: antialiased; }
 
  /* ================= HEADER ================= */
  .site-header {
    position: sticky; top: 0; z-index: 1000; background: rgba(2,6,23,0.95); border-bottom: 1px solid #1e293b; backdrop-filter: blur(10px);
  }
  .header-inner { max-width: 1400px; margin: 0 auto; padding: 0.6rem 1rem; display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 0.5rem; }
  .header-left { display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; }
  .logo a { font-size: 1.3rem; font-weight: 700; color: white; text-decoration: none; white-space: nowrap; }
  .main-nav { display: flex; gap: 1rem; flex-wrap: wrap; }
  .main-nav a { color: #e5e7eb; text-decoration: none; font-size: 0.9rem; white-space: nowrap; }
  .main-nav a:hover, .main-nav a.active { color: #60a5fa; }
  .header-right { display: flex; align-items: center; gap: 0.8rem; min-height: 44px; flex-wrap: wrap; }
  #profilePic { width: 32px; height: 32px; border-radius: 50%; border: 2px solid #60a5fa; object-fit: cover; display: none; }
  .login-btn { padding: 0.45rem 1.1rem; border-radius: 999px; border: 1.5px solid #60a5fa; background: transparent; color: #60a5fa; font-size: 0.95rem; cursor: pointer; }
  #levelInfo { display: none; font-size: 0.8rem; color: #cbd5e1; }
  #levelText { white-space: nowrap; font-size: 0.75rem; }
  #xpOuter { width: 100px; height: 5px; background: #1e293b; border-radius: 3px; margin-top: 4px; }
  #xpBar { height: 100%; width: 0%; background: #60a5fa; border-radius: 3px; transition: width 0.35s ease; }
  @media (max-width: 900px) {
    .header-inner { padding: 0.5rem; }
    .header-left { width: 100%; justify-content: space-between; }
    .main-nav { gap: 0.8rem; order: 3; width: 100%; }
    .main-nav a { font-size: 0.85rem; }
    .header-right { width: 100%; justify-content: space-between; }
    #levelInfo { flex: 1; }
    #xpOuter { width: 100%; }
  }
  /* ================= APPLICATION MENU BAR ================= */
  .app-menu-bar {
    background: rgba(15,23,42,0.98);
    border-bottom: 1px solid #1e293b;
    padding: 0;
    padding-left: 150px;
    display: flex;
    gap: 0;
    font-size: 0.85rem;
    position: sticky;
    top: 70px;
    z-index: 999;
    backdrop-filter: blur(10px);
    flex-wrap: wrap;
    height: 36px;
    align-items: center;
  }
  .menu-bar { display: flex; height: 100%; }
  .menu-bar > div {
    position: relative; cursor: pointer; padding: 0.5rem 1rem; height: 100%; display: flex; align-items: center; user-select: none;
  }
  .menu-bar > div:hover { color: #60a5fa; background: rgba(96, 165, 250, 0.1); }
  .dropdown {
    position: absolute; top: 100%; left: 0; background: #0f172a; border: 1px solid #1e293b; min-width: 260px; display: none; flex-direction: column; box-shadow: 0 8px 25px rgba(0,0,0,0.6); border-radius: 6px; overflow: hidden; z-index: 10000; margin-top: 2px;
  }
  .dropdown div { padding: 0.6rem 1.2rem; text-align: left; white-space: nowrap; transition: background 0.15s; font-size: 0.85rem; cursor: pointer; }
  .dropdown div:hover { background: #1e293b; }
  .dropdown div:active { background: #334155; }
  .dropdown .shortcut { float: right; color: #64748b; font-size: 0.75rem; margin-left: 2rem; }
  .dropdown hr { border: none; border-top: 1px solid #1e293b; margin: 0.4rem 0; }
  .dropdown .submenu { position: absolute; left: 100%; top: 0; min-width: 220px; display: none; }
  .dropdown div:hover .submenu { display: flex; }
  .menu-bar > div:hover .dropdown, .dropdown:hover { display: flex; }
  /* ================= MAIN LAYOUT ================= */
  #container { position: relative; width: 100%; height: 100%; padding-top: 106px; padding-bottom: 0; display: flex; }
 
  /* ================= CANVAS AREA ================= */
  #canvas-container {
    flex: 1; position: relative; background: #1a1a2e; overflow: hidden; display: flex; flex-direction: column;
  }
 
  /* Rulers */
  .ruler { position: absolute; background: #1e293b; color: #64748b; font-size: 10px; z-index: 10; }
  .ruler-h { top: 0; left: 60px; right: 0; height: 20px; border-bottom: 1px solid #334155; }
  .ruler-v { top: 20px; left: 0; width: 60px; bottom: 0; border-right: 1px solid #334155; }
  .ruler-corner { position: absolute; top: 0; left: 0; width: 60px; height: 20px; background: #1e293b; border-right: 1px solid #334155; border-bottom: 1px solid #334155; z-index: 11; }
 
  #canvas { display: block; width: 100%; height: 100%; touch-action: none; outline: none; margin-top: 20px; margin-left: 60px; background: #1a1a2e; }
  /* ================= LEFT TOOLBAR ================= */
  #floatingToolbar {
    position: fixed; left: 20px; top: 116px; background: rgba(30, 41, 59, 0.95); padding: 10px; border-radius: 12px; border: 1px solid #1e293b; backdrop-filter: blur(8px); z-index: 1150; display: flex; flex-direction: column; gap: 8px; max-height: calc(100vh - 180px); overflow-y: auto;
  }
  .tool-group { display: flex; flex-direction: column; gap: 2px; padding: 4px 0; border-bottom: 1px solid #1e293b; }
  .tool-group:last-child { border-bottom: none; }
  .tool-btn {
    width: 42px; height: 42px; border-radius: 6px; border: 1px solid transparent; background: transparent; color: #94a3b8; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.15s; font-size: 1.3rem; position: relative;
  }
  .tool-btn:hover { background: rgba(51, 65, 85, 1); color: white; }
  .tool-btn.active { color: #22c55e; background: rgba(34, 197, 94, 0.1); border-color: #22c55e; }
  .tool-btn.deactivated { border: 1px solid #ef4444 !important; color: #ef4444; opacity: 0.6; }
  .tool-btn.panel-open { box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.5); }
  /* ================= RIGHT PANEL DOCK ================= */
  .panel-dock {
    position: fixed; right: 20px; top: 116px; width: 320px; max-height: calc(100vh - 140px); background: rgba(2, 6, 23, 0.95); border: 1px solid #1e293b; border-radius: 12px; overflow: hidden; z-index: 20; backdrop-filter: blur(10px); box-shadow: 0 10px 30px rgba(0,0,0,0.4); display: flex; flex-direction: column;
  }
 
  #dockToggle {
    position: absolute; left: -50px; top: 50%; transform: translateY(-50%); width: 50px; height: 100px; background: rgba(2, 6, 23, 0.98); border: 1px solid #1e293b; border-right: none; border-radius: 12px 0 0 12px; color: #60a5fa; font-size: 2rem; cursor: pointer; display: flex; align-items: center; justify-content: center; z-index: 21; backdrop-filter: blur(12px); box-shadow: 0 6px 30px rgba(0,0,0,0.5); transition: all 0.3s ease;
  }
  #dockToggle:hover { background: rgba(30, 41, 59, 0.98); color: white; transform: translateY(-50%) translateX(-4px); }
  .panel-tabs { display: flex; background: #0f172a; border-bottom: 1px solid #1e293b; overflow-x: auto; position: relative; }
  .panel-tab {
    padding: 0.6rem 1rem; background: transparent; border: none; color: #94a3b8; cursor: pointer; font-size: 0.8rem; white-space: nowrap; transition: all 0.2s; flex-shrink: 0;
  }
  .panel-tab:hover { color: #e5e7eb; }
  .panel-tab.active { color: #60a5fa; background: rgba(96, 165, 250, 0.1); border-bottom: 2px solid #60a5fa; }
  .panel-close-btn {
    position: absolute; right: 8px; top: 50%; transform: translateY(-50%); width: 28px; height: 28px; border-radius: 6px; border: 1px solid #334155; background: #1e293b; color: #94a3b8; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; transition: all 0.2s;
  }
  .panel-close-btn:hover { background: #334155; color: #e5e7eb; }
  .panel-content { padding: 1rem; overflow-y: auto; flex: 1; }
  .panel-section { display: none; }
  .panel-section.active { display: block; }
  .panel-section h3 {
    color: #60a5fa; margin: 1rem 0 0.8rem; font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid #1e293b; padding-bottom: 0.4rem; font-weight: 600;
  }
  .panel-section h3:first-child { margin-top: 0; }
  .control-group { margin-bottom: 1rem; }
  .control-group label { display: block; font-size: 0.8rem; color: #94a3b8; margin-bottom: 0.4rem; }
  .control-row { display: flex; gap: 0.5rem; align-items: center; }
 
  input[type="text"], input[type="number"], select {
    width: 100%; padding: 0.4rem 0.6rem; border-radius: 4px; border: 1px solid #334155; background: #0f172a; color: #e5e7eb; font-size: 0.85rem;
  }
  input[type="text"]:focus, input[type="number"]:focus, select:focus { outline: none; border-color: #60a5fa; }
 
  input[type="range"] { width: 100%; accent-color: #60a5fa; }
  input[type="color"] { width: 100%; height: 36px; padding: 2px; border: 1px solid #334155; border-radius: 4px; background: #0f172a; cursor: pointer; }
 
  .btn {
    padding: 0.5rem 1rem; border-radius: 6px; border: 1px solid #334155; background: #1e293b; color: #e5e7eb; cursor: pointer; font-size: 0.85rem; transition: all 0.2s;
  }
  .btn:hover { background: #334155; border-color: #475569; }
  .btn-primary { background: #60a5fa; border-color: #60a5fa; color: white; }
  .btn-primary:hover { background: #3b82f6; border-color: #3b82f6; }
  .btn-sm { padding: 0.3rem 0.6rem; font-size: 0.75rem; }
  .btn-group { display: flex; gap: 0.25rem; }
  .btn-group .btn { flex: 1; }
  /* Tool Notification */
  .tool-notification {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.8);
    background: linear-gradient(135deg, rgba(96, 165, 250, 0.95), rgba(59, 130, 246, 0.95));
    color: white;
    padding: 1.5rem 2.5rem;
    border-radius: 16px;
    font-size: 1.8rem;
    font-weight: 700;
    letter-spacing: 0.5px;
    z-index: 10000;
    pointer-events: none;
    opacity: 0;
    box-shadow: 0 20px 60px rgba(96, 165, 250, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
  }
  .tool-notification.show {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }
  .tool-notification.hide {
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.9);
  }
  /* Color Picker Popup */
  .color-picker-popup {
    position: fixed;
    left: 70px;
    top: 116px;
    width: 280px;
    background: rgba(15, 23, 42, 0.98);
    border: 1px solid #1e293b;
    border-radius: 12px;
    padding: 1rem;
    z-index: 1200;
    box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    backdrop-filter: blur(10px);
    display: none;
  }
 
  .color-picker-popup.active {
    display: block;
  }
 
  .color-picker-popup h4 {
    margin: 0 0 1rem 0;
    color: #60a5fa;
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    border-bottom: 1px solid #1e293b;
    padding-bottom: 0.5rem;
  }
  #loader {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #60a5fa; font-size: 1.2rem; font-weight: 600; pointer-events: none; z-index: 5;
  }
  /* Context Menu */
  .context-menu {
    position: fixed; background: #0f172a; border: 1px solid #1e293b; min-width: 180px; border-radius: 8px; box-shadow: 0 8px 20px rgba(0,0,0,0.5); z-index: 2000; display: none;
  }
  .context-menu div { padding: 0.6rem 1rem; cursor: pointer; font-size: 0.85rem; }
  .context-menu div:hover { background: #1e293b; }
  .context-menu hr { border: none; border-top: 1px solid #1e293b; margin: 0.3rem 0; }
 
  .selection-box {
    position: absolute;
    border: 1px dashed #22c55e !important;
    background: rgba(34, 197, 94, 0.15) !important;
    pointer-events: none;
    z-index: 100;
    display: none;
  }
  /* Status Bar */
  .status-bar {
    position: fixed; bottom: 0; left: 0; right: 0; background: rgba(15, 23, 42, 0.95); border-top: 1px solid #1e293b; padding: 0.4rem 1rem; font-size: 0.75rem; color: #64748b; display: flex; justify-content: space-between; z-index: 1000; backdrop-filter: blur(10px);
  }
  .status-bar .left { display: flex; gap: 2rem; }
  .status-bar .right { display: flex; gap: 1rem; }
  /* Outliner Item */
  .outliner-item {
    padding: 0.5rem;
    background: #0f172a;
    border-radius: 6px;
    margin-bottom: 0.3rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.85rem;
    transition: background 0.15s;
  }
  .outliner-item:hover { background: #1e293b; }
  .outliner-item.selected { background: rgba(96, 165, 250, 0.2); border: 1px solid #60a5fa; }
  .outliner-item .icon { font-size: 1rem; }
  .outliner-item .name { flex: 1; }
  .outliner-item .toggle { font-size: 0.8rem; opacity: 0.6; }
  /* Modifier Item */
  .modifier-item {
    padding: 0.6rem;
    background: #0f172a;
    border-radius: 6px;
    margin-bottom: 0.4rem;
    border-left: 3px solid #60a5fa;
  }
  .modifier-item h4 {
    margin: 0 0 0.5rem 0;
    font-size: 0.85rem;
    color: #60a5fa;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .modifier-item .remove {
    cursor: pointer;
    color: #ef4444;
    font-size: 1rem;
  }
  /* Mobile */
  @media (max-width: 900px) {
    #floatingToolbar {
      left: 10px; top: 111px; padding: 6px; max-height: calc(100vh - 160px);
    }
    .tool-btn { width: 38px; height: 38px; font-size: 1.1rem; }
    .panel-dock {
      top: auto;
      bottom: 0;
      right: 0;
      left: 0;
      width: 100%;
      height: 40vh;
      max-height: 40vh;
      border-radius: 12px 12px 0 0;
      transform: none;
      z-index: 2000;
      overflow-y: auto;
    }
    .panel-dock.hidden { transform: translateY(100%); }
    .panel-dock.visible { transform: translateY(0); }
    #dockToggle {
      display: flex;
      top: -50px;
      left: 50%;
      transform: translateX(-50%);
      width: 100px;
      height: 50px;
      border-radius: 12px 12px 0 0;
    }
    .ruler-h { left: 50px; }
    .ruler-v { display: none; }
    #canvas { margin-left: 50px; }
    .app-menu-bar { gap: 1rem; padding-left: 60px; z-index: 999; }
    .menu-bar > div { padding: 0.3rem 0.5rem; font-size: 0.8rem; }
    .status-bar { z-index: 1100; }
    .dropdown { z-index: 1900; }
  }
  </style>
 
<!-- Three.js core -->
<script src="https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.min.js"></script>

<!-- New addons paths (jsm = JS Module) -->
<script type="module">
  import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/controls/OrbitControls.js';
  import { TransformControls } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/controls/TransformControls.js';
  import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/loaders/GLTFLoader.js';
  import { OBJLoader } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/loaders/OBJLoader.js';
  import { STLLoader } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/loaders/STLLoader.js';
  import { GLTFExporter } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/exporters/GLTFExporter.js';

  // Attach them to the global THREE namespace so your existing code works without changes
  window.THREE.OrbitControls = OrbitControls;
  window.THREE.TransformControls = TransformControls;
  window.THREE.GLTFLoader = GLTFLoader;
  window.THREE.OBJLoader = OBJLoader;
  window.THREE.STLLoader = STLLoader;
  window.THREE.GLTFExporter = GLTFExporter;
</script>
</head>
<body>
<header class="site-header">
  <div class="header-inner">
    <div class="header-left">
      <div class="logo"><a href="index.html">BowesProduct</a></div>
      <nav class="main-nav">
        <a href="index.html">Home</a>
        <a href="models.html">Models</a>
        <a href="retexture.html">Retexture</a>
        <a href="3d.html" class="active">3D</a>
      </nav>
    </div>
    <div class="header-right">
      <img id="profilePic" alt="Profile">
      <div id="levelInfo">
        <div id="levelText"></div>
        <div id="xpOuter"><div id="xpBar"></div></div>
      </div>
      <button id="authBtn" class="login-btn">Login</button>
    </div>
  </div>
</header>
<!-- Application Menu Bar -->
<div class="app-menu-bar">
  <div class="menu-bar">
    <div>File
      <div class="dropdown">
        <div onclick="newScene()">New <span class="shortcut">Ctrl+N</span></div>
        <div onclick="showSceneLoader()">Open (Firebase) <span class="shortcut">Ctrl+O</span></div>
        <div onclick="saveScene()">Save <span class="shortcut">Ctrl+S</span></div>
        <hr>
        <div onclick="importModel()">Import (GLTF/OBJ/STL) <span class="shortcut">Ctrl+I</span></div>
        <div onclick="exportModel()">Export (GLTF/OBJ/STL) <span class="shortcut">Ctrl+E</span></div>
      </div>
    </div>
    <div>Edit
      <div class="dropdown">
        <div onclick="undo()">Undo <span class="shortcut">Ctrl+Z</span></div>
        <div onclick="redo()">Redo <span class="shortcut">Ctrl+Y</span></div>
        <hr>
        <div onclick="duplicateSelected()">Duplicate <span class="shortcut">Shift+D</span></div>
        <div onclick="deleteSelected()">Delete <span class="shortcut">X</span></div>
        <div onclick="selectAll()">Select All <span class="shortcut">A</span></div>
      </div>
    </div>
    <div>Object
      <div class="dropdown">
        <div onclick="setTransformMode('translate')">Transform - Move <span class="shortcut">G</span></div>
        <div onclick="setTransformMode('rotate')">Transform - Rotate <span class="shortcut">R</span></div>
        <div onclick="setTransformMode('scale')">Transform - Scale <span class="shortcut">S</span></div>
        <hr>
        <div onclick="parentObjects()">Parent <span class="shortcut">Ctrl+P</span></div>
        <div onclick="joinObjects()">Join <span class="shortcut">Ctrl+J</span></div>
        <div onclick="applyTransform()">Apply Transform <span class="shortcut">Ctrl+A</span></div>
      </div>
    </div>
    <div>Mesh
      <div class="dropdown">
        <div>Add ‚Üì
          <div class="submenu">
            <div onclick="addPrimitive('cube')">Cube</div>
            <div onclick="addPrimitive('sphere')">Sphere</div>
            <div onclick="addPrimitive('uvsphere')">UV Sphere</div>
            <div onclick="addPrimitive('icosphere')">Icosphere</div>
            <div onclick="addPrimitive('cylinder')">Cylinder</div>
            <div onclick="addPrimitive('cone')">Cone</div>
            <div onclick="addPrimitive('torus')">Torus</div>
            <div onclick="addPrimitive('plane')">Plane</div>
            <div onclick="addPrimitive('monkey')">Monkey (Suzanne)</div>
          </div>
        </div>
      </div>
    </div>
    <div>Sculpt
      <div class="dropdown">
        <div onclick="setBrush('grab')">Grab Brush</div>
        <div onclick="setBrush('draw')">Draw Brush</div>
        <div onclick="setBrush('smooth')">Smooth Brush</div>
        <div onclick="setBrush('clay')">Clay Brush</div>
        <hr>
        <div onclick="toggleSymmetry()">Toggle Symmetry</div>
      </div>
    </div>
    <div>UV
      <div class="dropdown">
        <div onclick="unwrapUV()">Unwrap <span class="shortcut">U</span></div>
        <div onclick="smartUVProject()">Smart UV Project</div>
      </div>
    </div>
    <div>View
      <div class="dropdown">
        <div onclick="frameSelected()">Frame Selected <span class="shortcut">.</span></div>
        <div onclick="toggleCameraMode()">Toggle Ortho/Perspective <span class="shortcut">5</span></div>
        <hr>
        <div onclick="setShadingMode('solid')">Solid Shading</div>
        <div onclick="setShadingMode('material')">Material Preview</div>
        <div onclick="setShadingMode('wireframe')">Wireframe</div>
      </div>
    </div>
    <div>Render
      <div class="dropdown">
        <div onclick="renderScene()">Render Image <span class="shortcut">F12</span></div>
      </div>
    </div>
  </div>
</div>
<div id="container">
  <!-- Hidden file inputs -->
  <input type="file" id="importFile" accept=".gltf,.glb,.obj,.stl" style="display:none" onchange="handleImport(event)">
  <input type="file" id="normalMapInput" accept="image/*" style="display:none" onchange="handleNormalMap(event)">
  <!-- Tool/Panel Name Notification -->
  <div class="tool-notification" id="toolNotification"></div>
  <!-- Color Picker Popup -->
  <div class="color-picker-popup" id="colorPicker">
    <h4>Material Color</h4>
    <div class="control-group">
      <label>Color</label>
      <input type="color" id="materialColor" value="#60a5fa" onchange="updateMaterialColor()">
    </div>
    <div class="control-group">
      <label>Metallic: <span id="metallicVal">0</span></label>
      <input type="range" id="metallic" min="0" max="1" step="0.01" value="0" oninput="updateMaterial()">
    </div>
    <div class="control-group">
      <label>Roughness: <span id="roughnessVal">0.5</span></label>
      <input type="range" id="roughness" min="0" max="1" step="0.01" value="0.5" oninput="updateMaterial()">
    </div>
    <button class="btn btn-primary" style="width:100%" onclick="applyMaterial()">Apply to Selection</button>
  </div>
  <div id="canvas-container">
    <div id="loader">B Initializing 3D Engine...</div>
   
    <!-- Rulers -->
    <div class="ruler-corner" id="rulerCorner"></div>
    <div class="ruler ruler-h" id="rulerH"></div>
    <div class="ruler ruler-v" id="rulerV"></div>
   
    <canvas id="canvas"></canvas>
   
    <!-- Selection Box -->
    <div class="selection-box" id="selectionBox"></div>
  </div>
  <!-- Left Toolbar -->
  <div id="floatingToolbar">
    <div class="tool-group">
      <div class="tool-btn active" id="selectTool" title="Select Tool" onclick="setTool('select')">‚¨ö</div>
      <div class="tool-btn" id="moveTool" title="Move (G)" onclick="setTransformMode('translate')">‚ú•</div>
      <div class="tool-btn" id="rotateTool" title="Rotate (R)" onclick="setTransformMode('rotate')">‚Üª</div>
      <div class="tool-btn" id="scaleTool" title="Scale (S)" onclick="setTransformMode('scale')">‚ä°</div>
    </div>
    <div class="tool-group">
      <div class="tool-btn" id="addPrimitiveTool" title="Add Primitive (Shift+A)" onclick="showAddMenu()">+</div>
      <div class="tool-btn" id="extrudeTool" title="Extrude (E)" onclick="extrudeSelected()">‚¨Ü</div>
      <div class="tool-btn" id="bevelTool" title="Bevel (Ctrl+B)" onclick="bevelSelected()">‚óø</div>
      <div class="tool-btn" id="loopCutTool" title="Loop Cut (Ctrl+R)" onclick="loopCutSelected()">‚à•</div>
      <div class="tool-btn" id="knifeTool" title="Knife Tool (K)" onclick="setTool('knife')">üî™</div>
    </div>
    <div class="tool-group">
      <div class="tool-btn" id="grabBrush" title="Grab Brush" onclick="setBrush('grab')">‚úä</div>
      <div class="tool-btn" id="drawBrush" title="Draw Brush" onclick="setBrush('draw')">üñå</div>
      <div class="tool-btn" id="smoothBrush" title="Smooth Brush" onclick="setBrush('smooth')">„Ä∞</div>
      <div class="tool-btn" id="clayBrush" title="Clay Brush" onclick="setBrush('clay')">üß±</div>
    </div>
    <div class="tool-group">
      <div class="tool-btn" id="armatureTool" title="Armature" onclick="addArmature()">ü¶¥</div>
      <div class="tool-btn" id="colorTool" title="Material Color" onclick="showColorPicker()">‚óê</div>
    </div>
  </div>
  <!-- Right Panel Dock -->
  <div class="panel-dock visible" id="panelDock">
    <button id="dockToggle">‚óÄ</button>
   
    <div class="panel-tabs">
      <button class="panel-tab active" data-panel="properties">Properties</button>
      <button class="panel-tab" data-panel="outliner">Outliner</button>
      <button class="panel-tab" data-panel="modifiers">Modifiers</button>
      <button class="panel-tab" data-panel="materials">Materials</button>
      <button class="panel-tab" data-panel="world">World</button>
      <button class="panel-tab" data-panel="uv">UV Editor</button>
      <button class="panel-tab" data-panel="timeline">Timeline</button>
      <button class="panel-close-btn" id="panelCloseBtn" title="Close Panel">√ó</button>
    </div>
   
    <div class="panel-content">
      <!-- Properties Panel -->
      <div id="panel-properties" class="panel-section active">
        <h3>Transform</h3>
        <div class="control-row">
          <div class="control-group" style="flex:1">
            <label>Position X</label>
            <input type="number" id="posX" step="0.1" onchange="updateTransform()">
          </div>
          <div class="control-group" style="flex:1">
            <label>Y</label>
            <input type="number" id="posY" step="0.1" onchange="updateTransform()">
          </div>
          <div class="control-group" style="flex:1">
            <label>Z</label>
            <input type="number" id="posZ" step="0.1" onchange="updateTransform()">
          </div>
        </div>
        <div class="control-row">
          <div class="control-group" style="flex:1">
            <label>Rotation X</label>
            <input type="number" id="rotX" step="1" onchange="updateTransform()">
          </div>
          <div class="control-group" style="flex:1">
            <label>Y</label>
            <input type="number" id="rotY" step="1" onchange="updateTransform()">
          </div>
          <div class="control-group" style="flex:1">
            <label>Z</label>
            <input type="number" id="rotZ" step="1" onchange="updateTransform()">
          </div>
        </div>
        <div class="control-row">
          <div class="control-group" style="flex:1">
            <label>Scale X</label>
            <input type="number" id="scaleX" step="0.1" onchange="updateTransform()">
          </div>
          <div class="control-group" style="flex:1">
            <label>Y</label>
            <input type="number" id="scaleY" step="0.1" onchange="updateTransform()">
          </div>
          <div class="control-group" style="flex:1">
            <label>Z</label>
            <input type="number" id="scaleZ" step="0.1" onchange="updateTransform()">
          </div>
        </div>
       
        <h3>Mode</h3>
        <div class="btn-group">
          <button class="btn active" id="modeObject" onclick="setMode('object')">Object</button>
          <button class="btn" id="modeEdit" onclick="setMode('edit')">Edit</button>
          <button class="btn" id="modeSculpt" onclick="setMode('sculpt')">Sculpt</button>
          <button class="btn" id="modeUV" onclick="setMode('uv')">UV</button>
        </div>
      </div>
      <!-- Outliner Panel -->
      <div id="panel-outliner" class="panel-section">
        <div class="control-row" style="margin-bottom: 1rem;">
          <button class="btn btn-sm" onclick="selectAll()">Select All</button>
          <button class="btn btn-sm" onclick="deleteSelected()">Delete</button>
        </div>
        <div id="outlinerList">
          <!-- Outliner items will be populated dynamically -->
        </div>
      </div>
      <!-- Modifiers Panel -->
      <div id="panel-modifiers" class="panel-section">
        <div class="control-group">
          <label>Add Modifier</label>
          <select id="modifierSelect" onchange="addModifier()">
            <option value="">Select...</option>
            <option value="subdivision">Subdivision Surface</option>
            <option value="mirror">Mirror</option>
            <option value="array">Array</option>
            <option value="bevel">Bevel</option>
            <option value="boolean">Boolean</option>
          </select>
        </div>
        <div id="modifierList">
          <!-- Modifier items will be populated dynamically -->
        </div>
      </div>
      <!-- Materials Panel -->
      <div id="panel-materials" class="panel-section">
        <div class="control-row" style="margin-bottom: 1rem;">
          <button class="btn btn-sm btn-primary" onclick="createMaterial()">+ New Material</button>
          <button class="btn btn-sm" onclick="showColorPicker()">Edit</button>
        </div>
        <div id="materialList">
          <!-- Material items will be populated dynamically -->
        </div>
      </div>
      <!-- World Panel -->
      <div id="panel-world" class="panel-section">
        <h3>World</h3>
        <div class="control-group">
          <label>Background Color</label>
          <input type="color" id="worldColor" value="#1a1a2e" onchange="updateWorld()">
        </div>
        <div class="control-group">
          <label>Ambient Intensity: <span id="ambientVal">0.5</span></label>
          <input type="range" id="ambientIntensity" min="0" max="2" step="0.1" value="0.5" oninput="updateWorld()">
        </div>
      </div>
      <!-- UV Editor Panel -->
      <div id="panel-uv" class="panel-section">
        <div class="control-row" style="margin-bottom: 1rem;">
          <button class="btn btn-sm" onclick="unwrapUV()">Unwrap</button>
          <button class="btn btn-sm" onclick="smartUVProject()">Smart UV Project</button>
        </div>
        <div style="background: #0f172a; height: 200px; border-radius: 6px; display: flex; align-items: center; justify-content: center; color: #64748b;">
          UV Editor - Select a mesh to edit UVs
        </div>
      </div>
      <!-- Timeline Panel -->
      <div id="panel-timeline" class="panel-section">
        <h3>Timeline</h3>
        <div class="control-row">
          <button class="btn btn-sm">‚óÄ</button>
          <button class="btn btn-sm">‚ñ∂</button>
          <button class="btn btn-sm">‚è∏</button>
          <div class="control-group" style="flex:1">
            <label>Frame: <span id="currentFrame">0</span></label>
            <input type="range" id="timelineFrame" min="0" max="250" value="0" oninput="updateTimeline()">
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
<!-- Status Bar -->
<div class="status-bar">
  <div class="left">
    <span id="statusMode">Mode: Object</span>
    <span id="statusSelection">Selected: 0 objects, 0 vertices</span>
    <span id="statusTool">Tool: Select</span>
  </div>
  <div class="right">
    <span id="statusFPS">FPS: 60</span>
    <span id="statusCursor">Cursor: 0.0, 0.0, 0.0</span>
  </div>
</div>
<!-- Firebase Integration -->
<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js";
import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-auth.js";
import { getFirestore, doc, getDoc, setDoc, collection, addDoc, getDocs, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js";
import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-storage.js";

const firebaseConfig = {
  apiKey: "AIzaSyB4JMVBMcWcN2wKsaVYmnggHH5ue1mUfaA",
  authDomain: "bowesproduct.firebaseapp.com",
  projectId: "bowesproduct"
};
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const storage = getStorage(app);
const provider = new GoogleAuthProvider();

const authBtn = document.getElementById("authBtn");
const profilePic = document.getElementById("profilePic");
const levelInfo = document.getElementById("levelInfo");
const levelText = document.getElementById("levelText");
const xpBar = document.getElementById("xpBar");

authBtn.onclick = () => auth.currentUser ? signOut(auth) : signInWithPopup(auth, provider);

onAuthStateChanged(auth, async (user) => {
  if (!user) {
    authBtn.textContent = "Login";
    profilePic.style.display = "none";
    levelInfo.style.display = "none";
    return;
  }
  authBtn.textContent = "Logout";
  profilePic.src = user.photoURL || "";
  profilePic.style.display = "block";
  const userRef = doc(db, "users", user.uid);
  let snap = await getDoc(userRef);
  if (!snap.exists()) {
    await setDoc(userRef, { xp: 0, level: 1, createdAt: serverTimestamp() });
    snap = await getDoc(userRef);
  }
  const data = snap.data();
  let xp = data.xp || 0;
  const levels = [0, 200, 500, 1000, 2000, 3500, 5000];
  let level = levels.findIndex(l => xp < l);
  if (level === -1) level = levels.length;
  let prev = levels[level - 1] || 0;
  let next = levels[level] || prev + 1000;
  let progress = ((xp - prev) / (next - prev)) * 100;
  levelText.textContent = `Level ${level} ‚Ä¢ ${xp} XP`;
  xpBar.style.width = progress + "%";
  levelInfo.style.display = "block";
});

// XP System
window.addXP = async (amount) => {
  if (!auth.currentUser) return;
  const userRef = doc(db, "users", auth.currentUser.uid);
  const snap = await getDoc(userRef);
  if (snap.exists()) {
    const data = snap.data();
    const newXP = (data.xp || 0) + amount;
    await setDoc(userRef, { xp: newXP }, { merge: true });
  }
};

// Auto-save every 30 seconds
setInterval(async () => {
  if (auth.currentUser && window.saveSceneToFirebase) {
    await window.saveSceneToFirebase();
  }
}, 30000);
</script>
<script>
// ==================== GLOBAL STATE ====================
let scene, camera, renderer, controls, transformControls;
let selectedObjects = [];
let currentMode = 'object';
let currentTool = 'select';
let currentBrush = 'draw';
let brushSize = 0.5;
let brushStrength = 0.5;
let symmetryEnabled = false;
let sculpting = false;
let raycaster, mouse;
let gridHelper, axesHelper;
let ambientLight, directionalLight, hemisphereLight;
let undoStack = [];
let redoStack = [];
let objectCounter = 0;
let materials = [];
let modifiers = {};
let lastTime = performance.now();
let frameCount = 0;
let fps = 60;
// ==================== INITIALIZATION ====================
function init() {
  console.log('Initializing Blender Pro 2026...');
 
  const canvas = document.getElementById('canvas');
  const container = document.getElementById('canvas-container');
 
  // Scene
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x1a1a2e);
 
  // Camera
  camera = new THREE.PerspectiveCamera(
    75,
    canvas.clientWidth / canvas.clientHeight,
    0.1,
    1000
  );
  camera.position.set(5, 5, 5);
  camera.lookAt(0, 0, 0);
 
  // Renderer
  renderer = new THREE.WebGLRenderer({
    canvas: canvas,
    antialias: true,
    preserveDrawingBuffer: true
  });
  renderer.setSize(canvas.clientWidth, canvas.clientHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
 
  // Orbit Controls
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.screenSpacePanning = true;
  controls.minDistance = 0.1;
  controls.maxDistance = 500;
 
  // Transform Controls
  transformControls = new THREE.TransformControls(camera, renderer.domElement);
  transformControls.addEventListener('dragging-changed', (event) => {
    controls.enabled = !event.value;
  });
  transformControls.addEventListener('change', () => {
    updateProperties();
  });
  scene.add(transformControls);
 
  // Raycaster
  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();
 
  // Grid Helper
  gridHelper = new THREE.GridHelper(20, 20, 0x60a5fa, 0x334155);
  scene.add(gridHelper);
 
  // Axes Helper
  axesHelper = new THREE.AxesHelper(5);
  scene.add(axesHelper);
 
  // Lighting
  ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);
 
  hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
  scene.add(hemisphereLight);
 
  directionalLight = new THREE.DirectionalLight(0xffffff, 1);
  directionalLight.position.set(5, 10, 7);
  directionalLight.castShadow = true;
  directionalLight.shadow.mapSize.width = 2048;
  directionalLight.shadow.mapSize.height = 2048;
  directionalLight.shadow.camera.near = 0.5;
  directionalLight.shadow.camera.far = 500;
  scene.add(directionalLight);
 
  // Event Listeners
  window.addEventListener('resize', onWindowResize);
  canvas.addEventListener('mousedown', onMouseDown);
  canvas.addEventListener('mousemove', onMouseMove);
  canvas.addEventListener('mouseup', onMouseUp);
  canvas.addEventListener('wheel', onMouseWheel, { passive: false });
  canvas.addEventListener('contextmenu', onContextMenu);
  document.addEventListener('keydown', onKeyDown);
  document.addEventListener('keyup', onKeyUp);
 
  // Touch support
  canvas.addEventListener('touchstart', onTouchStart, { passive: false });
  canvas.addEventListener('touchmove', onTouchMove, { passive: false });
  canvas.addEventListener('touchend', onTouchEnd);
 
  // Initialize panels
  initPanelTabs();
  updateOutliner();
 
  // Start animation loop
  animate();
 
  // Hide loader
  setTimeout(() => {
    document.getElementById('loader').style.display = 'none';
    console.log('Blender Pro 2026 initialized successfully!');
  }, 1000);
 
  saveState();
}
// ==================== ANIMATION LOOP ====================
function animate() {
  requestAnimationFrame(animate);
 
  controls.update();
  renderer.render(scene, camera);
 
  // FPS counter
  frameCount++;
  const currentTime = performance.now();
  if (currentTime - lastTime >= 1000) {
    fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
    document.getElementById('statusFPS').textContent = `FPS: ${fps}`;
    frameCount = 0;
    lastTime = currentTime;
  }
 
  // Update cursor position
  updateCursorDisplay();
}
// ==================== WINDOW RESIZE ====================
function onWindowResize() {
  const canvas = document.getElementById('canvas');
  camera.aspect = canvas.clientWidth / canvas.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(canvas.clientWidth, canvas.clientHeight);
}
// ==================== MOUSE EVENTS ====================
function onMouseDown(event) {
  if (event.button === 2) return; // Right click handled by context menu
 
  const canvas = document.getElementById('canvas');
  const rect = canvas.getBoundingClientRect();
 
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
 
  raycaster.setFromCamera(mouse, camera);
 
  if (currentMode === 'sculpt') {
    sculpting = true;
    sculptStroke();
    return;
  }
 
  if (currentTool === 'select' || currentTool === 'move' || currentTool === 'rotate' || currentTool === 'scale') {
    const intersects = raycaster.intersectObjects(scene.children, true);
   
    if (intersects.length > 0) {
      let obj = intersects[0].object;
     
      // Find parent object if we hit a mesh
      while (obj.parent && obj.parent.type !== 'Scene') {
        obj = obj.parent;
      }
     
      if (!event.shiftKey) {
        deselectAll();
      }
     
      selectObject(obj);
     
      if (selectedObjects.length > 0) {
        transformControls.attach(selectedObjects[0]);
      }
    } else {
      deselectAll();
      transformControls.detach();
    }
  }
}
function onMouseMove(event) {
  const canvas = document.getElementById('canvas');
  const rect = canvas.getBoundingClientRect();
 
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
 
  if (sculpting && currentMode === 'sculpt') {
    sculptStroke();
  }
 
  updateCursorDisplay();
}
function onMouseUp(event) {
  sculpting = false;
  saveState();
}
function onMouseWheel(event) {
  event.preventDefault();
  // Zoom handled by OrbitControls
}
function onContextMenu(event) {
  event.preventDefault();
  showContextMenu(event.clientX, event.clientY);
}
// ==================== TOUCH EVENTS ====================
function onTouchStart(event) {
  if (event.touches.length === 1) {
    const touch = event.touches[0];
    const mouseEvent = new MouseEvent('mousedown', {
      clientX: touch.clientX,
      clientY: touch.clientY,
      button: 0
    });
    onMouseDown(mouseEvent);
  }
}
function onTouchMove(event) {
  event.preventDefault();
  if (event.touches.length === 1) {
    const touch = event.touches[0];
    const mouseEvent = new MouseEvent('mousemove', {
      clientX: touch.clientX,
      clientY: touch.clientY
    });
    onMouseMove(mouseEvent);
  }
}
function onTouchEnd(event) {
  const mouseEvent = new MouseEvent('mouseup', {});
  onMouseUp(mouseEvent);
}
// ==================== KEYBOARD EVENTS ====================
function onKeyDown(event) {
  if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;
 
  // Transform shortcuts
  if (event.key === 'g' || event.key === 'G') {
    setTransformMode('translate');
  } else if (event.key === 'r' || event.key === 'R') {
    setTransformMode('rotate');
  } else if (event.key === 's' || event.key === 'S') {
    setTransformMode('scale');
  }
 
  // Mode switching
  else if (event.key === 'Tab') {
    event.preventDefault();
    toggleMode();
  }
 
  // Object operations
  else if (event.key === 'x' || event.key === 'X') {
    deleteSelected();
  } else if (event.key === 'a' || event.key === 'A') {
    if (event.ctrlKey || event.metaKey) {
      event.preventDefault();
      selectAll();
    } else {
      selectAll();
    }
  } else if ((event.shiftKey && event.key === 'D') || (event.shiftKey && event.key === 'd')) {
    event.preventDefault();
    duplicateSelected();
  }
 
  // Add primitive
  else if (event.shiftKey && (event.key === 'A' || event.key === 'a')) {
    event.preventDefault();
    showAddMenu();
  }
 
  // Edit mode operations
  else if (event.key === 'e' || event.key === 'E') {
    if (currentMode === 'edit') {
      extrudeSelected();
    }
  }
 
  // Undo/Redo
  else if (event.ctrlKey || event.metaKey) {
    if (event.key === 'z' || event.key === 'Z') {
      event.preventDefault();
      if (event.shiftKey) {
        redo();
      } else {
        undo();
      }
    } else if (event.key === 'y' || event.key === 'Y') {
      event.preventDefault();
      redo();
    } else if (event.key === 's' || event.key === 'S') {
      event.preventDefault();
      saveScene();
    }
  }
 
  // Render
  else if (event.key === 'F12') {
    event.preventDefault();
    renderScene();
  }
 
  // Camera
  else if (event.key === '5') {
    toggleCameraMode();
  }
 
  // Frame selected
  else if (event.key === '.') {
    frameSelected();
  }
}
function onKeyUp(event) {
  // Key up handlers if needed
}
// ==================== TOOL & MODE MANAGEMENT ====================
function setTool(tool) {
  currentTool = tool;
 
  // Update toolbar buttons
  document.querySelectorAll('.tool-btn').forEach(btn => {
    btn.classList.remove('active');
  });
 
  const toolBtn = document.getElementById(tool + 'Tool');
  if (toolBtn) {
    toolBtn.classList.add('active');
  }
 
  document.getElementById('statusTool').textContent = `Tool: ${tool.charAt(0).toUpperCase() + tool.slice(1)}`;
  showNotification(tool.charAt(0).toUpperCase() + tool.slice(1) + ' Tool');
}
function setMode(mode) {
  currentMode = mode;
 
  // Update mode buttons
  document.querySelectorAll('#panel-properties .btn-group .btn').forEach(btn => {
    btn.classList.remove('active');
  });
  const modeBtn = document.getElementById('mode' + mode.charAt(0).toUpperCase() + mode.slice(1));
  if (modeBtn) {
    modeBtn.classList.add('active');
  }
 
  document.getElementById('statusMode').textContent = `Mode: ${mode.charAt(0).toUpperCase() + mode.slice(1)}`;
 
  if (mode === 'sculpt') {
    showNotification('Sculpt Mode');
  } else {
    showNotification(mode.charAt(0).toUpperCase() + mode.slice(1) + ' Mode');
  }
}
function toggleMode() {
  const modes = ['object', 'edit', 'sculpt', 'uv'];
  const currentIndex = modes.indexOf(currentMode);
  const nextIndex = (currentIndex + 1) % modes.length;
  setMode(modes[nextIndex]);
}
function setTransformMode(mode) {
  transformControls.setMode(mode);
 
  // Update toolbar buttons
  document.querySelectorAll('.tool-btn').forEach(btn => {
    btn.classList.remove('active');
  });
 
  let toolName = '';
  if (mode === 'translate') toolName = 'move';
  else if (mode === 'rotate') toolName = 'rotate';
  else if (mode === 'scale') toolName = 'scale';
 
  const toolBtn = document.getElementById(toolName + 'Tool');
  if (toolBtn) {
    toolBtn.classList.add('active');
  }
 
  currentTool = toolName;
  document.getElementById('statusTool').textContent = `Tool: ${toolName.charAt(0).toUpperCase() + toolName.slice(1)}`;
  showNotification(toolName.charAt(0).toUpperCase() + toolName.slice(1));
}
function setBrush(brush) {
  currentBrush = brush;
 
  setMode('sculpt');
 
  // Update brush buttons
  document.querySelectorAll('.tool-btn').forEach(btn => {
    btn.classList.remove('active');
  });
 
  const brushBtn = document.getElementById(brush + 'Brush');
  if (brushBtn) {
    brushBtn.classList.add('active');
  }
 
  showNotification(brush.charAt(0).toUpperCase() + brush.slice(1) + ' Brush');
}
function toggleSymmetry() {
  symmetryEnabled = !symmetryEnabled;
  showNotification(symmetryEnabled ? 'Symmetry Enabled' : 'Symmetry Disabled');
}
// ==================== OBJECT SELECTION ====================
function selectObject(obj) {
  if (!obj || obj.type === 'GridHelper' || obj.type === 'AxesHelper' || obj.type === 'TransformControls') {
    return;
  }
 
  if (!selectedObjects.includes(obj)) {
    selectedObjects.push(obj);
   
    // Add selection indicator
    if (obj.material) {
      if (!obj.userData.originalMaterial) {
        obj.userData.originalMaterial = obj.material.clone();
      }
      obj.material = obj.material.clone();
      obj.material.emissive = new THREE.Color(0x22c55e);
      obj.material.emissiveIntensity = 0.2;
    }
   
    updateProperties();
    updateOutliner();
  }
}
function deselectAll() {
  selectedObjects.forEach(obj => {
    // Restore original material
    if (obj.userData.originalMaterial) {
      obj.material = obj.userData.originalMaterial;
      delete obj.userData.originalMaterial;
    }
  });
 
  selectedObjects = [];
  transformControls.detach();
  updateProperties();
  updateOutliner();
}
function selectAll() {
  scene.children.forEach(obj => {
    if (obj.isMesh && obj.type !== 'GridHelper' && obj.type !== 'AxesHelper') {
      selectObject(obj);
    }
  });
}
// ==================== PRIMITIVE CREATION ====================
function addPrimitive(type) {
  let geometry, material, mesh;
 
  material = new THREE.MeshStandardMaterial({
    color: 0x60a5fa,
    metalness: 0,
    roughness: 0.5
  });
 
  switch(type) {
    case 'cube':
      geometry = new THREE.BoxGeometry(1, 1, 1);
      break;
    case 'sphere':
      geometry = new THREE.SphereGeometry(0.5, 32, 32);
      break;
    case 'uvsphere':
      geometry = new THREE.SphereGeometry(0.5, 32, 16);
      break;
    case 'icosphere':
      geometry = new THREE.IcosahedronGeometry(0.5, 2);
      break;
    case 'cylinder':
      geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 32);
      break;
    case 'cone':
      geometry = new THREE.ConeGeometry(0.5, 1, 32);
      break;
    case 'torus':
      geometry = new THREE.TorusGeometry(0.5, 0.2, 16, 100);
      break;
    case 'plane':
      geometry = new THREE.PlaneGeometry(1, 1);
      break;
    case 'monkey':
      geometry = new THREE.IcosahedronGeometry(0.5, 1);
      const positions = geometry.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        const y = positions.getY(i);
        if (y > 0.2) {
          positions.setX(i, positions.getX(i) * 1.2);
          positions.setZ(i, positions.getZ(i) * 0.8);
        }
      }
      geometry.computeVertexNormals();
      break;
    default:
      geometry = new THREE.BoxGeometry(1, 1, 1);
  }
 
  mesh = new THREE.Mesh(geometry, material);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  mesh.name = `${type}_${++objectCounter}`;
  mesh.userData.modifiers = [];
  mesh.userData.materials = [];
 
  scene.add(mesh);
  selectObject(mesh);
  transformControls.attach(mesh);
 
  updateOutliner();
  saveState();
 
  if (window.addXP) {
    window.addXP(5);
  }
 
  showNotification(`Added ${type}`);
}
function showAddMenu() {
  const primitives = ['cube', 'sphere', 'uvsphere', 'icosphere', 'cylinder', 'cone', 'torus', 'plane', 'monkey'];
  const primitive = prompt('Enter primitive name:\n' + primitives.join(', '), 'cube');
  if (primitive && primitives.includes(primitive.toLowerCase())) {
    addPrimitive(primitive.toLowerCase());
  }
}
// ==================== OBJECT OPERATIONS ====================
function duplicateSelected() {
  const newObjects = [];
 
  selectedObjects.forEach(obj => {
    const clone = obj.clone();
    clone.position.x += 1;
    clone.name = obj.name + '_copy';
    clone.material = obj.material.clone();
    scene.add(clone);
    newObjects.push(clone);
  });
 
  deselectAll();
  newObjects.forEach(obj => selectObject(obj));
 
  saveState();
  showNotification('Duplicated');
}
function deleteSelected() {
  selectedObjects.forEach(obj => {
    scene.remove(obj);
    if (obj.geometry) obj.geometry.dispose();
    if (obj.material) obj.material.dispose();
  });
 
  selectedObjects = [];
  transformControls.detach();
  updateOutliner();
  saveState();
  showNotification('Deleted');
}
function applyTransform() {
  if (selectedObjects.length === 0) return;
 
  selectedObjects.forEach(obj => {
    obj.updateMatrix();
  });
 
  saveState();
  showNotification('Transform Applied');
}
function parentObjects() {
  if (selectedObjects.length < 2) {
    showNotification('Select at least 2 objects');
    return;
  }
 
  const parent = selectedObjects[0];
  for (let i = 1; i < selectedObjects.length; i++) {
    parent.attach(selectedObjects[i]);
  }
 
  updateOutliner();
  saveState();
  showNotification('Parented');
}
function joinObjects() {
  if (selectedObjects.length < 2) {
    showNotification('Select at least 2 objects');
    return;
  }
 
  showNotification('Join - Feature simplified in this version');
}
// ==================== EDIT MODE OPERATIONS ====================
function extrudeSelected() {
  if (selectedObjects.length === 0 || currentMode !== 'edit') {
    showNotification('Select an object in Edit mode');
    return;
  }
 
  const obj = selectedObjects[0];
  if (!obj.geometry) return;
 
  obj.scale.multiplyScalar(1.2);
 
  saveState();
  showNotification('Extruded');
}
function bevelSelected() {
  if (selectedObjects.length === 0) {
    showNotification('Select an object');
    return;
  }
 
  const obj = selectedObjects[0];
  addModifierToObject(obj, 'bevel');
 
  saveState();
  showNotification('Beveled');
}
function loopCutSelected() {
  if (selectedObjects.length === 0) {
    showNotification('Select an object');
    return;
  }
 
  showNotification('Loop Cut - Requires advanced mesh editing');
}
// ==================== SCULPTING ====================
function sculptStroke() {
  if (selectedObjects.length === 0) return;
 
  const obj = selectedObjects[0];
  raycaster.setFromCamera(mouse, camera);
 
  const intersects = raycaster.intersectObject(obj);
  if (intersects.length > 0) {
    const point = intersects[0].point;
    const normal = intersects[0].face.normal;
   
    modifyVertices(obj, point, normal);
  }
}
function modifyVertices(obj, center, normal) {
  const geometry = obj.geometry;
  const positions = geometry.attributes.position;
 
  for (let i = 0; i < positions.count; i++) {
    const vertex = new THREE.Vector3();
    vertex.fromBufferAttribute(positions, i);
    vertex.applyMatrix4(obj.matrixWorld);
   
    const distance = vertex.distanceTo(center);
   
    if (distance < brushSize) {
      const influence = 1 - (distance / brushSize);
      const displacement = normal.clone().multiplyScalar(brushStrength * influence * 0.1);
     
      if (currentBrush === 'draw' || currentBrush === 'clay') {
        vertex.add(displacement);
      } else if (currentBrush === 'grab') {
        const toCenter = center.clone().sub(vertex).normalize();
        vertex.add(toCenter.multiplyScalar(brushStrength * influence * 0.1));
      } else if (currentBrush === 'smooth') {
        // Average with neighbors - simplified
      }
     
      vertex.applyMatrix4(obj.matrixWorld.clone().invert());
      positions.setXYZ(i, vertex.x, vertex.y, vertex.z);
    }
  }
 
  geometry.attributes.position.needsUpdate = true;
  geometry.computeVertexNormals();
 
  if (symmetryEnabled) {
    const centerSym = center.clone();
    centerSym.x = -centerSym.x;
   
    for (let i = 0; i < positions.count; i++) {
      const vertex = new THREE.Vector3();
      vertex.fromBufferAttribute(positions, i);
      vertex.applyMatrix4(obj.matrixWorld);
     
      const distance = vertex.distanceTo(centerSym);
     
      if (distance < brushSize) {
        const influence = 1 - (distance / brushSize);
        const displacement = normal.clone().multiplyScalar(brushStrength * influence * 0.1);
       
        if (currentBrush === 'draw' || currentBrush === 'clay') {
          vertex.add(displacement);
        } else if (currentBrush === 'grab') {
          const toCenter = centerSym.clone().sub(vertex).normalize();
          vertex.add(toCenter.multiplyScalar(brushStrength * influence * 0.1));
        }
       
        vertex.applyMatrix4(obj.matrixWorld.clone().invert());
        positions.setXYZ(i, vertex.x, vertex.y, vertex.z);
      }
    }
   
    geometry.attributes.position.needsUpdate = true;
    geometry.computeVertexNormals();
  }
}
// ==================== MODIFIERS ====================
function addModifier() {
  const select = document.getElementById('modifierSelect');
  const type = select.value;
 
  if (!type || selectedObjects.length === 0) {
    showNotification('Select an object and modifier type');
    return;
  }
 
  const obj = selectedObjects[0];
  addModifierToObject(obj, type);
 
  select.value = '';
  saveState();
 
  if (window.addXP) {
    window.addXP(10);
  }
}
function addModifierToObject(obj, type) {
  const modifier = {
    type: type,
    enabled: true,
    params: {}
  };
 
  if (!obj.userData.modifiers) {
    obj.userData.modifiers = [];
  }
 
  obj.userData.modifiers.push(modifier);
 
  applyModifierEffect(obj, modifier);
 
  updateModifierList();
  showNotification(`Added ${type} modifier`);
}
function applyModifierEffect(obj, modifier) {
  switch(modifier.type) {
    case 'subdivision':
      if (obj.geometry) {
        obj.geometry.computeVertexNormals();
      }
      break;
    case 'mirror':
    case 'array':
    case 'bevel':
    case 'boolean':
      break;
  }
}
function removeModifier(obj, index) {
  if (obj.userData.modifiers) {
    obj.userData.modifiers.splice(index, 1);
    updateModifierList();
    saveState();
  }
}
function updateModifierList() {
  const list = document.getElementById('modifierList');
  list.innerHTML = '';
 
  if (selectedObjects.length === 0) return;
 
  const obj = selectedObjects[0];
  if (!obj.userData.modifiers) return;
 
  obj.userData.modifiers.forEach((mod, index) => {
    const item = document.createElement('div');
    item.className = 'modifier-item';
    item.innerHTML = `
      <h4>${mod.type.charAt(0).toUpperCase() + mod.type.slice(1)} <span class="remove" onclick="removeModifier(selectedObjects[0], ${index})">√ó</span></h4>
    `;
    list.appendChild(item);
  });
}
// ==================== MATERIALS ====================
function createMaterial() {
  const material = {
    name: `Material_${materials.length + 1}`,
    color: 0x60a5fa,
    metalness: 0,
    roughness: 0.5,
    normalMap: null
  };
 
  materials.push(material);
  updateMaterialList();
 
  if (selectedObjects.length > 0) {
    applyMaterialToObjects(selectedObjects, material);
  }
 
  showNotification('Created Material');
}
function showColorPicker() {
  if (selectedObjects.length === 0) {
    showNotification('Select an object first');
    return;
  }
 
  const obj = selectedObjects[0];
  if (obj.material) {
    const color = '#' + obj.material.color.getHexString();
    document.getElementById('materialColor').value = color;
    document.getElementById('metallic').value = obj.material.metalness;
    document.getElementById('roughness').value = obj.material.roughness;
    document.getElementById('metallicVal').textContent = obj.material.metalness;
    document.getElementById('roughnessVal').textContent = obj.material.roughness;
  }
 
  document.getElementById('colorPicker').classList.toggle('active');
}
function updateMaterialColor() {
  const color = document.getElementById('materialColor').value;
  document.getElementById('materialColor').style.backgroundColor = color;
}
function updateMaterial() {
  const metallic = parseFloat(document.getElementById('metallic').value);
  const roughness = parseFloat(document.getElementById('roughness').value);
 
  document.getElementById('metallicVal').textContent = metallic;
  document.getElementById('roughnessVal').textContent = roughness;
}
function applyMaterial() {
  if (selectedObjects.length === 0) return;
 
  const color = document.getElementById('materialColor').value;
  const metallic = parseFloat(document.getElementById('metallic').value);
  const roughness = parseFloat(document.getElementById('roughness').value);
 
  const material = new THREE.MeshStandardMaterial({
    color: color,
    metalness: metallic,
    roughness: roughness
  });
 
  selectedObjects.forEach(obj => {
    obj.material = material;
  });
 
  document.getElementById('colorPicker').classList.remove('active');
  saveState();
  showNotification('Material Applied');
}
function applyMaterialToObjects(objects, materialData) {
  const material = new THREE.MeshStandardMaterial({
    color: materialData.color,
    metalness: materialData.metalness,
    roughness: materialData.roughness
  });
 
  objects.forEach(obj => {
    obj.material = material;
  });
}
function updateMaterialList() {
  const list = document.getElementById('materialList');
  list.innerHTML = '';
 
  materials.forEach((mat, index) => {
    const item = document.createElement('div');
    item.className = 'outliner-item';
    item.innerHTML = `
      <span class="icon">‚óê</span>
      <span class="name">${mat.name}</span>
    `;
    item.onclick = () => {
      if (selectedObjects.length > 0) {
        applyMaterialToObjects(selectedObjects, mat);
      }
    };
    list.appendChild(item);
  });
}
function handleNormalMap(event) {
  const file = event.target.files[0];
  if (!file || selectedObjects.length === 0) return;
 
  const reader = new FileReader();
  reader.onload = (e) => {
    const texture = new THREE.TextureLoader().load(e.target.result);
    selectedObjects[0].material.normalMap = texture;
    selectedObjects[0].material.needsUpdate = true;
  };
  reader.readAsDataURL(file);
}
// ==================== UV EDITING ====================
function unwrapUV() {
  if (selectedObjects.length === 0) {
    showNotification('Select a mesh');
    return;
  }
 
  const obj = selectedObjects[0];
  const geometry = obj.geometry;
 
  if (!geometry.attributes.uv) {
    geometry.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(geometry.attributes.position.count * 2), 2));
  }
 
  const positions = geometry.attributes.position;
  const uvs = geometry.attributes.uv;
 
  for (let i = 0; i < positions.count; i++) {
    uvs.setXY(i, (positions.getX(i) + 0.5) % 1, (positions.getY(i) + 0.5) % 1);
  }
 
  geometry.attributes.uv.needsUpdate = true;
 
  saveState();
 
  if (window.addXP) {
    window.addXP(20);
  }
 
  showNotification('UV Unwrapped');
}
function smartUVProject() {
  showNotification('Smart UV Project - Basic projection applied');
  unwrapUV();
}
// ==================== IMPORT/EXPORT ====================
function importModel() {
  document.getElementById('importFile').click();
}
function handleImport(event) {
  const file = event.target.files[0];
  if (!file) return;
 
  const reader = new FileReader();
  reader.onload = (e) => {
    const contents = e.target.result;
   
    if (file.name.endsWith('.gltf') || file.name.endsWith('.glb')) {
      const loader = new THREE.GLTFLoader();
      loader.parse(contents, '', (gltf) => {
        const model = gltf.scene;
        model.name = file.name;
        scene.add(model);
        updateOutliner();
        saveState();
        showNotification('Imported GLTF');
      });
    } else if (file.name.endsWith('.obj')) {
      const loader = new THREE.OBJLoader();
      const model = loader.parse(contents);
      model.name = file.name;
      scene.add(model);
      updateOutliner();
      saveState();
        showNotification('Imported OBJ');
    } else if (file.name.endsWith('.stl')) {
      const loader = new THREE.STLLoader();
      const geometry = loader.parse(contents);
      const material = new THREE.MeshStandardMaterial({ color: 0x60a5fa });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.name = file.name;
      scene.add(mesh);
      updateOutliner();
      saveState();
      showNotification('Imported STL');
    }
  };
 
  if (file.name.endsWith('.gltf') || file.name.endsWith('.glb') || file.name.endsWith('.obj')) {
    reader.readAsText(file);
  } else {
    reader.readAsArrayBuffer(file);
  }
 
  event.target.value = '';
}
function exportModel() {
  const format = prompt('Export format (gltf, obj, stl):', 'gltf');
 
  if (selectedObjects.length === 0) {
    showNotification('Select objects to export');
    return;
  }
 
  if (format === 'gltf') {
    const exporter = new THREE.GLTFExporter();
    exporter.parse(selectedObjects, (result) => {
      const output = JSON.stringify(result, null, 2);
      const blob = new Blob([output], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'model.gltf';
      a.click();
      URL.revokeObjectURL(url);
      showNotification('Exported GLTF');
    });
  } else {
    showNotification('Export format not fully implemented');
  }
}
// ==================== RENDERING ====================
function setShadingMode(mode) {
  scene.traverse((obj) => {
    if (obj.isMesh && obj.material) {
      if (mode === 'wireframe') {
        obj.material.wireframe = true;
      } else {
        obj.material.wireframe = false;
      }
    }
  });
 
  showNotification(`${mode.charAt(0).toUpperCase() + mode.slice(1)} Shading`);
}
function renderScene() {
  renderer.setSize(1920, 1080);
  renderer.render(scene, camera);
 
  const link = document.createElement('a');
  link.download = 'render.png';
  link.href = renderer.domElement.toDataURL('image/png');
  link.click();
 
  const canvas = document.getElementById('canvas');
  renderer.setSize(canvas.clientWidth, canvas.clientHeight);
 
  if (window.addXP) {
    window.addXP(30);
  }
 
  showNotification('Render Complete');
}
// ==================== VIEW CONTROLS ====================
function frameSelected() {
  if (selectedObjects.length === 0) return;
 
  const box = new THREE.Box3();
  selectedObjects.forEach(obj => {
    box.expandByObject(obj);
  });
 
  const center = box.getCenter(new THREE.Vector3());
  const size = box.getSize(new THREE.Vector3());
  const maxDim = Math.max(size.x, size.y, size.z);
 
  controls.target.copy(center);
  camera.position.set(
    center.x + maxDim,
    center.y + maxDim,
    center.z + maxDim
  );
  camera.lookAt(center);
 
  showNotification('Framed Selection');
}
function toggleCameraMode() {
  if (camera.isPerspectiveCamera) {
    const aspect = camera.aspect;
    const frustumSize = 10;
    camera = new THREE.OrthographicCamera(
      frustumSize * aspect / -2,
      frustumSize * aspect / 2,
      frustumSize / 2,
      frustumSize / -2,
      0.1,
      1000
    );
  } else {
    camera = new THREE.PerspectiveCamera(75, renderer.domElement.width / renderer.domElement.height, 0.1, 1000);
  }
 
  camera.position.set(5, 5, 5);
  camera.lookAt(0, 0, 0);
  controls.object = camera;
  transformControls.camera = camera;
 
  showNotification(camera.isPerspectiveCamera ? 'Perspective' : 'Orthographic');
}
function updateWorld() {
  const color = document.getElementById('worldColor').value;
  const intensity = parseFloat(document.getElementById('ambientIntensity').value);
 
  scene.background = new THREE.Color(color);
  ambientLight.intensity = intensity;
  document.getElementById('ambientVal').textContent = intensity;
}
// ==================== UNDO/REDO ====================
function saveState() {
  const state = {
    objectCount: scene.children.length,
    timestamp: Date.now()
  };
 
  undoStack.push(JSON.stringify(state));
  if (undoStack.length > 50) undoStack.shift();
  redoStack = [];
}
function undo() {
  if (undoStack.length <= 1) {
    showNotification('Nothing to undo');
    return;
  }
 
  redoStack.push(undoStack.pop());
  showNotification('Undo');
}
function redo() {
  if (redoStack.length === 0) {
    showNotification('Nothing to redo');
    return;
  }
 
  undoStack.push(redoStack.pop());
  showNotification('Redo');
}


// ==================== FINAL INITIALIZATION ====================
// Remove the old init() call and DOMContentLoaded listener
// Call init only once, after everything is defined
init();

// Add a default cube so the scene isn't empty
addPrimitive('cube');
</script>
// ==================== UI UPDATES ====================
function updateProperties() {
  if (selectedObjects.length === 0) {
    document.getElementById('posX').value = '';
    document.getElementById('posY').value = '';
    document.getElementById('posZ').value = '';
    document.getElementById('rotX').value = '';
    document.getElementById('rotY').value = '';
    document.getElementById('rotZ').value = '';
    document.getElementById('scaleX').value = '';
    document.getElementById('scaleY').value = '';
    document.getElementById('scaleZ').value = '';
    return;
  }
 
  const obj = selectedObjects[0];
  document.getElementById('posX').value = obj.position.x.toFixed(2);
  document.getElementById('posY').value = obj.position.y.toFixed(2);
  document.getElementById('posZ').value = obj.position.z.toFixed(2);
  document.getElementById('rotX').value = THREE.MathUtils.radToDeg(obj.rotation.x).toFixed(1);
  document.getElementById('rotY').value = THREE.MathUtils.radToDeg(obj.rotation.y).toFixed(1);
  document.getElementById('rotZ').value = THREE.MathUtils.radToDeg(obj.rotation.z).toFixed(1);
  document.getElementById('scaleX').value = obj.scale.x.toFixed(2);
  document.getElementById('scaleY').value = obj.scale.y.toFixed(2);
  document.getElementById('scaleZ').value = obj.scale.z.toFixed(2);
}
function updateTransform() {
  if (selectedObjects.length === 0) return;
 
  const obj = selectedObjects[0];
  obj.position.x = parseFloat(document.getElementById('posX').value) || 0;
  obj.position.y = parseFloat(document.getElementById('posY').value) || 0;
  obj.position.z = parseFloat(document.getElementById('posZ').value) || 0;
  obj.rotation.x = THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotX').value) || 0);
  obj.rotation.y = THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotY').value) || 0);
  obj.rotation.z = THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotZ').value) || 0);
  obj.scale.x = parseFloat(document.getElementById('scaleX').value) || 1;
  obj.scale.y = parseFloat(document.getElementById('scaleY').value) || 1;
  obj.scale.z = parseFloat(document.getElementById('scaleZ').value) || 1;
 
  saveState();
}
function updateOutliner() {
  const list = document.getElementById('outlinerList');
  list.innerHTML = '';
 
  scene.children.forEach(obj => {
    if (obj.isMesh) {
      const item = document.createElement('div');
      item.className = 'outliner-item' + (selectedObjects.includes(obj) ? ' selected' : '');
      item.innerHTML = `
        <span class="icon">üì¶</span>
        <span class="name">${obj.name}</span>
      `;
      item.onclick = () => {
        deselectAll();
        selectObject(obj);
        transformControls.attach(obj);
      };
      list.appendChild(item);
    }
  });
 
  let vertCount = 0;
  selectedObjects.forEach(obj => {
    if (obj.geometry && obj.geometry.attributes.position) {
      vertCount += obj.geometry.attributes.position.count;
    }
  });
 
  document.getElementById('statusSelection').textContent = `Selected: ${selectedObjects.length} objects, ${vertCount} vertices`;
}
function updateCursorDisplay() {
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(scene.children, true);
 
  if (intersects.length > 0) {
    const point = intersects[0].point;
    document.getElementById('statusCursor').textContent =
      `Cursor: ${point.x.toFixed(1)}, ${point.y.toFixed(1)}, ${point.z.toFixed(1)}`;
  }
}
function updateTimeline() {
  const frame = document.getElementById('timelineFrame').value;
  document.getElementById('currentFrame').textContent = frame;
}
// ==================== ARMATURE ====================
function addArmature() {
  const boneGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
  const boneMaterial = new THREE.MeshBasicMaterial({ color: 0xff6b6b });
  const bone = new THREE.Mesh(boneGeometry, boneMaterial);
  bone.name = `Bone_${++objectCounter}`;
 
  scene.add(bone);
  selectObject(bone);
 
  updateOutliner();
  saveState();
  showNotification('Added Bone');
}
// ==================== NOTIFICATIONS ====================
function showNotification(text) {
  const notification = document.getElementById('toolNotification');
  notification.textContent = text;
  notification.classList.remove('show', 'hide');
 
  requestAnimationFrame(() => {
    notification.classList.add('show');
  });
 
  setTimeout(() => {
    notification.classList.remove('show');
    notification.classList.add('hide');
  }, 1500);
}
// ==================== CONTEXT MENU ====================
function showContextMenu(x, y) {
  const menu = document.createElement('div');
  menu.className = 'context-menu';
  menu.style.left = x + 'px';
  menu.style.top = y + 'px';
  menu.innerHTML = `
    <div onclick="duplicateSelected()">Duplicate</div>
    <div onclick="deleteSelected()">Delete</div>
    <hr>
    <div onclick="setShadingMode('wireframe')">Wireframe</div>
    <div onclick="setShadingMode('solid')">Solid</div>
  `;
 
  document.body.appendChild(menu);
 
  const closeMenu = () => {
    menu.remove();
    document.removeEventListener('click', closeMenu);
  };
 
  setTimeout(() => {
    document.addEventListener('click', closeMenu);
  }, 0);
}
/ ==================== PANEL TABS ====================
function initPanelTabs() {
  document.querySelectorAll('.panel-tab').forEach(tab => {
    tab.addEventListener('click', function() {
      document.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.panel-section').forEach(s => s.classList.remove('active'));
     
      this.classList.add('active');
      document.getElementById('panel-' + this.dataset.panel).classList.add('active');
    });
  });
 
  const dock = document.getElementById('panelDock');
  const dockToggle = document.getElementById('dockToggle');
  const panelCloseBtn = document.getElementById('panelCloseBtn');
  let dockVisible = true;
 
  function toggleDock() {
    dockVisible = !dockVisible;
    dock.classList.toggle('visible', dockVisible);
    dock.classList.toggle('hidden', !dockVisible);
    dockToggle.textContent = dockVisible ? '‚óÄ' : '‚ñ∂';
  }
 
  dockToggle.onclick = toggleDock;
  if (panelCloseBtn) {
    panelCloseBtn.onclick = toggleDock;
  }
}
// ==================== EXPOSE FUNCTIONS ====================
window.setTool = setTool;
window.setMode = setMode;
window.setTransformMode = setTransformMode;
window.setBrush = setBrush;
window.toggleSymmetry = toggleSymmetry;
window.addPrimitive = addPrimitive;
window.showAddMenu = showAddMenu;
window.duplicateSelected = duplicateSelected;
window.deleteSelected = deleteSelected;
window.applyTransform = applyTransform;
window.parentObjects = parentObjects;
window.joinObjects = joinObjects;
window.extrudeSelected = extrudeSelected;
window.bevelSelected = bevelSelected;
window.loopCutSelected = loopCutSelected;
window.addModifier = addModifier;
window.removeModifier = removeModifier;
window.createMaterial = createMaterial;
window.showColorPicker = showColorPicker;
window.updateMaterialColor = updateMaterialColor;
window.updateMaterial = updateMaterial;
window.applyMaterial = applyMaterial;
window.handleNormalMap = handleNormalMap;
window.unwrapUV = unwrapUV;
window.smartUVProject = smartUVProject;
window.importModel = importModel;
window.handleImport = handleImport;
window.exportModel = exportModel;
window.setShadingMode = setShadingMode;
window.renderScene = renderScene;
window.frameSelected = frameSelected;
window.toggleCameraMode = toggleCameraMode;
window.updateWorld = updateWorld;
window.undo = undo;
window.redo = redo;
window.saveScene = saveScene;
window.showSceneLoader = showSceneLoader;
window.newScene = newScene;
window.updateTransform = updateTransform;
window.updateTimeline = updateTimeline;
window.addArmature = addArmature;
// ==================== INITIALIZE ====================
// Wait for EVERYTHING (including all external scripts) to load before initializing
window.addEventListener('load', function() {
  init();
  addPrimitive('cube');  // Add default cube
  console.log('Blender Pro 2026 fully initialized!');
});
</script>
</body>
</html>











