<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Retexture Pro – BowesProduct (Three.js Fixed)</title>

  <!-- Import maps polyfill for older browsers + full compatibility -->
  <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>

  <!-- Import map to enable bare "three" specifier (required since r137+) -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
    }
  }
  </script>

  <style>
    *, *::before, *::after { box-sizing: border-box; }
    html, body { margin: 0; height: 100%; background: #020617; color: white; font-family: system-ui, sans-serif; overflow: hidden; }
    #container { position: relative; width: 100%; height: 100%; }
    #canvas { display: block; width: 100%; height: 100%; }

    .panel {
      position: absolute;
      top: 20px; right: 20px;
      width: 320px; max-height: 90vh;
      background: rgba(2, 6, 23, 0.95);
      border: 1px solid #1e293b;
      border-radius: 12px;
      padding: 1.5rem;
      overflow-y: auto;
      z-index: 10;
      backdrop-filter: blur(10px);
    }
    .panel h2 { color: #60a5fa; margin-top: 0; margin-bottom: 1rem; font-size: 1.1rem; }
    .control-group { margin-bottom: 1.2rem; }
    label { display: block; font-size: 0.9rem; color: #e5e7eb; margin-bottom: 0.4rem; }
    input, select, button {
      width: 100%; padding: 0.5rem;
      border-radius: 0.375rem; border: 1px solid #1f2937;
      background: #020617; color: #e5e7eb;
      font: inherit;
    }
    input[type="range"] { padding: 0.3rem 0; }
    input[type="color"] { height: 44px; padding: 0.2rem; }
    button { background: #60a5fa; border: none; color: white; cursor: pointer; margin-top: 0.8rem; font-weight: 600; }
    button:hover { background: #3b82f6; }
    .hint { font-size: 0.8rem; color: #9ca3af; margin-top: 0.3rem; }
    #brushSize { width: 100%; }
    #status { position: absolute; bottom: 20px; left: 20px; font-size: 0.9rem; color: #94a3b8; }

    @media (max-width: 900px) {
      .panel { width: 100%; right: 0; left: 0; top: auto; bottom: 0; border-radius: 12px 12px 0 0; max-height: 60vh; }
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="canvas"></canvas>
    <div id="status">Drag to rotate • Click/drag to paint • Scroll to zoom</div>

    <div class="panel">
      <h2>Model</h2>
      <div class="control-group">
        <label>Upload GLB (convert FBX → GLB first)</label>
        <input type="file" id="uploadModel" accept=".glb,.gltf">
        <div class="hint">Use Blender or online converter.</div>
      </div>

      <h2>Texture</h2>
      <div class="control-group">
        <label>Preset Textures</label>
        <select id="presetTexture">
          <option value="">Original / None</option>
          <option value="textures/wood_basecolor.jpg">Warm Wood</option>
          <option value="textures/metal_basecolor.jpg">Brushed Metal</option>
          <option value="textures/plastic_basecolor.jpg">Matte Plastic</option>
          <option value="textures/fabric_basecolor.jpg">Fabric</option>
        </select>
      </div>
      <div class="control-group">
        <label>Custom Texture</label>
        <input type="file" id="uploadTexture" accept="image/*">
      </div>

      <h2>Material</h2>
      <div class="control-group">
        <label>Metallic <span id="metallicVal">0.00</span></label>
        <input type="range" id="metallicSlider" min="0" max="1" step="0.01" value="0">
      </div>
      <div class="control-group">
        <label>Roughness <span id="roughnessVal">0.50</span></label>
        <input type="range" id="roughnessSlider" min="0" max="1" step="0.01" value="0.5">
      </div>

      <h2>Vertex Color Painting</h2>
      <div class="control-group">
        <label>Brush Color</label>
        <input type="color" id="paintColor" value="#ff4444">
      </div>
      <div class="control-group">
        <label>Brush Size <span id="brushSizeVal">10</span></label>
        <input type="range" id="brushSize" min="1" max="50" value="10">
      </div>
      <button id="clearPaint">Clear All Paint</button>

      <h2>Lighting</h2>
      <div class="control-group">
        <label>Environment</label>
        <select id="envPreset">
          <option value="neutral">Neutral</option>
          <option value="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r182/examples/textures/equirect/royal_esplanade_1k.hdr">Royal Esplanade</option>
          <option value="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r182/examples/textures/equirect/spruit_sunrise_1k.hdr">Sunrise</option>
          <option value="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r182/examples/textures/equirect/moonless_golf_1k.hdr">Night</option>
        </select>
      </div>

      <h2>Export</h2>
      <button id="exportBtn">Export Modified GLB</button>
    </div>
  </div>

  <div style="position:absolute;bottom:8px;right:8px;font-size:0.7rem;color:#64748b;">
    Powered by Three.js r182 (MIT License) • Retexture tool by Grok @ xAI
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
    import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';

    // Scene setup
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020617);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(3, 2, 5);

    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Environment
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();

    let currentEnvMap = null;
    function loadEnvironment(url) {
      if (url === 'neutral') {
        scene.environment = null;
        scene.background = new THREE.Color(0x020617);
        if (currentEnvMap) currentEnvMap.dispose();
        currentEnvMap = null;
        return;
      }
      new RGBELoader().load(url, (texture) => {
        const envMap = pmremGenerator.fromEquirectangular(texture).texture;
        scene.environment = envMap;
        scene.background = envMap;
        texture.dispose();
        if (currentEnvMap && currentEnvMap !== envMap) currentEnvMap.dispose();
        currentEnvMap = envMap;
      });
    }
    loadEnvironment('neutral');

    // Model
    let currentModel = null;
    let paintedGeometry = null; // We paint only on the first mesh for simplicity
    let paintColor = new THREE.Color('#ff4444');
    let brushSize = 10;

    const gltfLoader = new GLTFLoader();

    function loadModel(url) {
      gltfLoader.load(url, (gltf) => {
        if (currentModel) scene.remove(currentModel);
        currentModel = gltf.scene;
        scene.add(currentModel);

        currentModel.traverse((child) => {
          if (child.isMesh) {
            child.material.vertexColors = true;
            if (!child.geometry.attributes.color) {
              const count = child.geometry.attributes.position.count;
              const colors = new Float32Array(count * 3);
              colors.fill(1); // white
              child.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            }
            // Use first mesh for painting
            if (!paintedGeometry) paintedGeometry = child.geometry;
          }
        });

        // Auto-frame
        const box = new THREE.Box3().setFromObject(currentModel);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        camera.position.copy(center).add(new THREE.Vector3(maxDim, maxDim * 0.7, maxDim));
        controls.target.copy(center);
        controls.update();
      });
    }

    // Painting
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let isPainting = false;

    function paintAt(point) {
      if (!paintedGeometry || !currentModel) return;
      const positions = paintedGeometry.attributes.position;
      const colors = paintedGeometry.attributes.color;
      const brushSq = brushSize * brushSize;
      const worldMatrix = currentModel.matrixWorld;
      const vert = new THREE.Vector3();

      for (let i = 0; i < positions.count; i++) {
        vert.set(positions.getX(i), positions.getY(i), positions.getZ(i)).applyMatrix4(worldMatrix);
        const distSq = point.distanceToSquared(vert);
        if (distSq < brushSq) {
          const influence = 1 - Math.sqrt(distSq) / brushSize;
          colors.setXYZ(i,
            THREE.MathUtils.lerp(colors.getX(i), paintColor.r, influence),
            THREE.MathUtils.lerp(colors.getY(i), paintColor.g, influence),
            THREE.MathUtils.lerp(colors.getZ(i), paintColor.b, influence)
          );
        }
      }
      colors.needsUpdate = true;
    }

    canvas.addEventListener('pointerdown', (e) => { isPainting = true; onPointerMove(e); });
    canvas.addEventListener('pointerup', () => isPainting = false);
    canvas.addEventListener('pointerleave', () => isPainting = false);
    canvas.addEventListener('pointermove', onPointerMove);

    function onPointerMove(event) {
      if (!isPainting || !currentModel) return;
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(currentModel, true);
      if (intersects.length > 0) paintAt(intersects[0].point);
    }

    // UI
    document.getElementById('uploadModel').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) loadModel(URL.createObjectURL(file));
    });

    function applyTexture(url) {
      if (!currentModel) return;
      new THREE.TextureLoader().load(url, (tex) => {
        tex.flipY = false;
        tex.colorSpace = THREE.SRGBColorSpace;
        currentModel.traverse((child) => {
          if (child.isMesh) {
            child.material.map = tex;
            child.material.needsUpdate = true;
          }
        });
      });
    }

    document.getElementById('presetTexture').addEventListener('change', (e) => {
      if (e.target.value) applyTexture(e.target.value);
    });

    document.getElementById('uploadTexture').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) applyTexture(URL.createObjectURL(file));
    });

    document.getElementById('metallicSlider').addEventListener('input', (e) => {
      const v = parseFloat(e.target.value);
      document.getElementById('metallicVal').textContent = v.toFixed(2);
      currentModel?.traverse((child) => {
        if (child.isMesh) child.material.metalness = v;
      });
    });

    document.getElementById('roughnessSlider').addEventListener('input', (e) => {
      const v = parseFloat(e.target.value);
      document.getElementById('roughnessVal').textContent = v.toFixed(2);
      currentModel?.traverse((child) => {
        if (child.isMesh) child.material.roughness = v;
      });
    });

    document.getElementById('paintColor').addEventListener('input', (e) => paintColor.set(e.target.value));
    document.getElementById('brushSize').addEventListener('input', (e) => {
      brushSize = parseFloat(e.target.value);
      document.getElementById('brushSizeVal').textContent = brushSize;
    });

    document.getElementById('clearPaint').addEventListener('click', () => {
      if (!paintedGeometry) return;
      const colors = paintedGeometry.attributes.color;
      for (let i = 0; i < colors.count; i++) colors.setXYZ(i, 1, 1, 1);
      colors.needsUpdate = true;
    });

    document.getElementById('envPreset').addEventListener('change', (e) => loadEnvironment(e.target.value));

    document.getElementById('exportBtn').addEventListener('click', () => {
      if (!currentModel) return;
      const exporter = new GLTFExporter();
      exporter.parse(currentModel, (glb) => {
        const blob = new Blob([glb], { type: 'application/octet-stream' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'retextured_model.glb';
        link.click();
      }, { binary: true });
    });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
