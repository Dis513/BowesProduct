<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Retexture Pro ‚Äì BowesProduct</title>
  <script async src="https://unpkg.com/es-module-shims@1.8.2/dist/es-module-shims.js"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
    }
  }
  </script>
  <style>
  *, *::before, *::after { box-sizing: border-box; }
  html, body { margin: 0; height: 100%; background: #020617; color: white; font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif; overflow: hidden; -webkit-font-smoothing: antialiased; }

  .site-header {
  position: sticky; top: 0; z-index: 1000; background: rgba(2,6,23,0.95); border-bottom: 1px solid #1e293b; backdrop-filter: blur(10px);
  }
  .header-inner { max-width: 1200px; margin: 0 auto; padding: 0.6rem 1rem; display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 0.5rem; }
  .header-left { display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; }
  .logo a { font-size: 1.3rem; font-weight: 700; color: white; text-decoration: none; white-space: nowrap; }
  .main-nav { display: flex; gap: 1rem; flex-wrap: wrap; }
  .main-nav a { color: #e5e7eb; text-decoration: none; font-size: 0.9rem; white-space: nowrap; }
  .main-nav a:hover, .main-nav a.active { color: #60a5fa; }
  .header-right { display: flex; align-items: center; gap: 0.8rem; min-height: 44px; flex-wrap: wrap; }
  #profilePic { width: 32px; height: 32px; border-radius: 50%; border: 2px solid #60a5fa; object-fit: cover; display: none; }
  .login-btn { padding: 0.45rem 1.1rem; border-radius: 999px; border: 1.5px solid #60a5fa; background: transparent; color: #60a5fa; font-size: 0.95rem; cursor: pointer; }
  #levelInfo { display: none; font-size: 0.8rem; color: #cbd5e1; }
  #levelText { white-space: nowrap; font-size: 0.75rem; }
  #xpOuter { width: 100px; height: 5px; background: #1e293b; border-radius: 3px; margin-top: 4px; }
  #xpBar { height: 100%; width: 0%; background: #60a5fa; border-radius: 3px; transition: width 0.35s ease; }

  @media (max-width: 900px) {
  .header-inner { padding: 0.5rem; }
  .header-left { width: 100%; justify-content: space-between; }
  .main-nav { gap: 0.8rem; order: 3; width: 100%; }
  .main-nav a { font-size: 0.85rem; }
  .header-right { width: 100%; justify-content: space-between; }
  #levelInfo { flex: 1; }
  #xpOuter { width: 100%; }
  }

  #container { position: relative; width: 100%; height: 100%; padding-top: 70px; padding-bottom: 80px; }
  #canvas { display: block; width: 100%; height: 100%; touch-action: none; outline: none; }

  /* Desktop Panel */
  .panel {
  position: absolute;
  top: 90px;
  right: 20px;
  width: 380px;
  max-height: calc(100vh - 220px);
  background: rgba(2, 6, 23, 0.95);
  border: 1px solid #1e293b;
  border-radius: 12px;
  padding: 1.5rem;
  overflow-y: auto;
  z-index: 20;
  backdrop-filter: blur(10px);
  transition: transform 0.3s ease;
  box-shadow: 0 10px 25px rgba(0,0,0,0.3);
  }
  .panel.hidden { transform: translateX(420px); }
  .panel::-webkit-scrollbar { width: 6px; }
  .panel::-webkit-scrollbar-track { background: #0f172a; }
  .panel::-webkit-scrollbar-thumb { background: #334155; border-radius: 3px; }

  #panelToggle {
  position: absolute;
  left: -60px;
  top: 50%;
  transform: translateY(-50%);
  width: 60px;
  height: 110px;
  background: rgba(2, 6, 23, 0.98);
  border: 1px solid #1e293b;
  border-right: none;
  border-radius: 20px 0 0 20px;
  color: #60a5fa;
  font-size: 2.4rem;
  font-weight: bold;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 21;
  backdrop-filter: blur(12px);
  box-shadow: 0 6px 30px rgba(0,0,0,0.5);
  transition: all 0.3s ease;
  }
  #panelToggle:hover { background: rgba(30, 41, 59, 0.98); color: white; transform: translateY(-50%) translateX(-4px); }

  /* Mobile Bottom Sheet */
  @media (max-width: 900px) {
  .panel {
  position: absolute;
  top: auto;
  right: 0;
  left: 0;
  bottom: 0;
  width: 100%;
  height: 85vh;
  max-height: none;
  border-radius: 20px 20px 0 0;
  transform: translateY(calc(100% - 60px)); 
  transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1);
  padding-top: 20px;
  padding-bottom: 120px; 
  z-index: 1100;
  overflow-y: auto;
  background: rgba(2, 6, 23, 0.95);
  border: 1px solid #1e293b;
  border-bottom: none;
  box-shadow: 0 -5px 25px rgba(0,0,0,0.5);
  }
  .panel.visible {
  transform: translateY(0);
  }
  
  #panelToggle { display: none; }
  }

  /* Mobile Floating Toggle (Controls) - MOVED TO RIGHT */
  #mobilePanelToggle {
  position: fixed;
  bottom: 20px;
  right: 20px;
  transform: translateX(0);
  width: 140px;
  height: 44px;
  background: rgba(2, 6, 23, 0.9);
  border: 1px solid #60a5fa;
  border-radius: 22px;
  color: #60a5fa;
  font-size: 0.85rem;
  font-weight: 700;
  display: flex; 
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 1200;
  backdrop-filter: blur(12px);
  box-shadow: 0 4px 20px rgba(0,0,0,0.6);
  transition: background 0.2s, transform 0.1s;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  }
  #mobilePanelToggle:active { transform: scale(0.96); }
  #mobilePanelToggle::before {
  content: '';
  position: absolute;
  top: -6px;
  left: 50%;
  transform: translateX(-50%);
  width: 40px;
  height: 4px;
  background: #94a3b8;
  border-radius: 2px;
  opacity: 0.5;
  }
  @media (min-width: 901px) { #mobilePanelToggle { display: none; } }
  @media (max-width: 900px) { #mobilePanelToggle { display: flex; } }

  /* Floating Controls (Paint/Eyedropper/Color) - STAY ON LEFT, CONTROLS ON RIGHT */
  #floatingControls {
  position: fixed;
  bottom: 20px;
  left: 20px;
  display: flex;
  gap: 10px;
  z-index: 1150;
  pointer-events: none;
  }
  .floater {
  pointer-events: auto;
  width: 44px;
  height: 44px;
  border-radius: 50%;
  border: 1px solid #475569;
  background: rgba(30, 41, 59, 0.9);
  backdrop-filter: blur(8px);
  color: #94a3b8;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  transition: all 0.2s;
  font-size: 1.2rem;
  position: relative;
  }
  .floater:hover { background: rgba(51, 65, 85, 1); color: white; transform: translateY(-2px); }
  .floater.active { color: #10b981; border-color: #10b981; background: rgba(2, 6, 23, 1); }
  .floater.active-mask { color: #ec4899; border-color: #ec4899; }
  
  /* Specific Floater Styles */
  #floaterColor {
    padding: 0;
    border: 1px solid #60a5fa;
    overflow: hidden;
    width: 44px;
    height: 44px;
  }
  #floaterColor::-webkit-color-swatch-wrapper { padding: 0; }
  #floaterColor::-webkit-color-swatch { border: none; border-radius: 50%; }
  
  #floaterPaint.active { color: #10b981; border-color: #10b981; }
  #floaterEye.active { color: #10b981; border-color: #10b981; }

  /* Logic for showing/hiding floaters */
  @media (min-width: 901px) { 
    #floatingControls { 
      display: flex !important; 
    } 
  }
  @media (max-width: 900px) {
    .panel.visible ~ #floatingControls { display: none !important; }
    .panel.hidden ~ #floatingControls { display: flex !important; }
  }

  .panel h2 { color: #60a5fa; margin: 1.5rem 0 1rem; font-size: 1.1rem; border-bottom: 1px solid #1e293b; padding-bottom: 0.5rem; }
  .control-group { margin-bottom: 1.2rem; }
  label { display: block; font-size: 0.9rem; color: #e5e7eb; margin-bottom: 0.4rem; }
  input, select, button { width: 100%; padding: 0.5rem; border-radius: 0.375rem; border: 1px solid #1f2937; background: #020617; color: #e5e7eb; font: inherit; }
  input[type="range"] { padding: 0.3rem 0; accent-color: #60a5fa; }
  input[type="color"] { height: 44px; padding: 0.2rem; }
  button { background: #60a5fa; border: none; color: white; cursor: pointer; margin-top: 0.8rem; font-weight: 600; position: relative; z-index: 30; transition: background 0.2s; }
  button:hover { background: #3b82f6; }

  #layersList { list-style: none; padding: 0; margin: 0 0 1rem; }
  .layer-item {
  display: flex; align-items: center; gap: 8px; padding: 10px; background: #0f172a; border-radius: 8px; margin-bottom: 8px; cursor: grab; border: 1px solid transparent;
  }
  .layer-item:active { cursor: grabbing; }
  .layer-item.active { background: #1e293b; border-color: #60a5fa; }
  .layer-visibility { font-size: 1.3rem; cursor: pointer; width: 24px; text-align: center; }
  .layer-color { width: 36px; height: 36px; border: none; border-radius: 6px; cursor: pointer; padding: 0; background: none; }
  .layer-opacity { width: 90px; }
  .layer-name { flex: 1; font-size: 0.95rem; cursor: text; border: none; background: transparent; color: inherit; }
  .layer-name:focus { border-bottom: 1px solid #60a5fa; outline: none; }
  .layer-delete { color: #ef4444; cursor: pointer; font-size: 1.2rem; width: 24px; text-align: center; }
  .layer-blend { width: 100px; font-size: 0.8rem; }
  #addLayerBtn { background: #10b981; }

  #brushCursor, #eyedropperCursor { position: fixed; pointer-events: none; transform: translate(-50%, -50%); z-index: 9999; display: none; }
  #brushCursor { border: 2px solid rgba(255,255,255,0.8); border-radius: 50%; opacity: 0.9; background: rgba(255,68,68,0.2); transition: width 0.1s, height 0.1s; box-shadow: 0 0 10px rgba(0,0,0,0.5); }
  #eyedropperCursor { width: 44px; height: 44px; background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="%2360a5fa" stroke-width="3"><path d="M21 11l-8-8-2 2 8 8 2-2zM4 20l7-7"/></svg>') center/32px no-repeat; }

  #customBrushPreview { width: 80px; height: 80px; background: #1e293b; border-radius: 8px; margin-top: 0.5rem; image-rendering: pixelated; }
  #paintToggle.active { background: #10b981; }
  #eyedropperToggle { background: #a78bfa; }
  #eyedropperToggle.active { background: #10b981; border: 1px solid white; }
  #maskToggle { background: #8b5cf6; }
  #maskToggle.active { background: #ec4899; border: 1px solid white; }

  #undoRedoGroup { display: flex; gap: 0.5rem; margin-top: 0.8rem; }
  #undoBtn, #redoBtn { flex: 1; background: #475569; margin-top: 0; }
  #undoBtn:hover, #redoBtn:hover { background: #64748b; }

  .site-footer { position: fixed; bottom: 0; left: 0; right: 0; background: rgba(2,6,23,0.95); border-top: 1px solid #1e293b; padding: 1rem; z-index: 1000; backdrop-filter: blur(10px); }
  .footer-inner { max-width: 1200px; margin: 0 auto; display: flex; justify-content: space-between; flex-wrap: wrap; gap: 1.5rem; font-size: 0.85rem; }
  .footer-nav { display: flex; gap: 1.5rem; flex-wrap: wrap; }
  .footer-nav a { color: #cbd5e1; text-decoration: none; }
  .footer-nav a:hover { color: #60a5fa; }

  .hint { font-size: 0.75rem; color: #94a3b8; margin-top: 0.25rem; }
  
  #loader {
  position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
  color: #60a5fa; font-size: 1.5rem; font-weight: bold; pointer-events: none; z-index: 0;
  text-shadow: 0 2px 10px rgba(0,0,0,0.5);
  }
  </style>
  <script src="https://sites.super.myninja.ai/_assets/ninja-daytona-script.js"></script>
</head>
<body>

<header class="site-header">
  <div class="header-inner">
  <div class="header-left">
  <div class="logo"><a href="index.html">BowesProduct</a></div>
  <nav class="main-nav">
  <a href="index.html">Home</a>
  <a href="models.html">Models</a>
  <a href="retexture.html" class="active">Retexture</a>
    <a href="editor.html">Editor</a>
  </nav>
  </div>
  <div class="header-right">
  <img id="profilePic" alt="Profile">
  <div id="levelInfo">
  <div id="levelText"></div>
  <div id="xpOuter"><div id="xpBar"></div></div>
  </div>
  <button id="authBtn" class="login-btn">Login</button>
  </div>
  </div>
</header>

<div id="container">
  <div id="loader">Drop a GLB/GLTF model here or use Upload</div>
  <canvas id="canvas"></canvas>
  <div id="brushCursor"></div>
  <div id="eyedropperCursor"></div>

  <!-- Floating Controls: Visible on Desktop ALWAYS, on Mobile ONLY when panel is hidden -->
  <div id="floatingControls">
    <!-- Mobile Buttons: Eyedropper (A), Paint Mode (B), Color (C) -->
    <div class="floater" id="floaterEye" title="Eyedropper Tool">üé®</div>
    <div class="floater" id="floaterPaint" title="Paint Mode">üñå</div>
    <input type="color" id="floaterColor" title="Base Color">
  </div>

  <div class="panel visible" id="panel">
  <button id="panelToggle">‚Üê</button>
  
  <div style="padding:0.8rem;background:rgba(30,41,59,0.4);border-radius:8px;margin-bottom:1rem;font-size:0.85rem;line-height:1.4;border:1px solid #334155;">
  <strong style="color:#60a5fa">Controls:</strong><br>
  ‚Ä¢ Drag to rotate ‚Ä¢ Scroll to zoom<br>
  ‚Ä¢ <b>Paint Mode:</b> Paint directly on mesh<br>
  ‚Ä¢ <b>Mask Mode:</b> Paints global invisibility<br>
  ‚Ä¢ PC: Hold Alt to Sample ‚Ä¢ Mobile: Use Eyedropper<br>
  ‚Ä¢ Ctrl+Z/Y Undo/Redo
  </div>

  <h2>Model</h2>
  <div class="control-group">
  <label for="uploadModel">Upload GLB/GLTF</label>
  <input type="file" id="uploadModel" accept=".glb,.gltf">
  <div class="hint">Supports GLB/GLTF. Auto-centers model.</div>
  </div>

  <h2>Texture</h2>
  <div class="control-group">
  <label for="presetTexture">Preset Textures</label>
  <select id="presetTexture">
  <option value="">Original / None</option>
  <option value="textures/wood_basecolor.jpg">Warm Wood</option>
  <option value="textures/metal_basecolor.jpg">Brushed Metal</option>
  <option value="textures/plastic_basecolor.jpg">Matte Plastic</option>
  <option value="textures/fabric_basecolor.jpg">Fabric</option>
  </select>
  </div>
  <div class="control-group">
  <label for="uploadTexture">Custom Texture</label>
  <input type="file" id="uploadTexture" accept="image/*">
  </div>

  <h2>Material</h2>
  <div class="control-group">
  <label for="metallicSlider">Metallic <span id="metallicVal">0.00</span></label>
  <input type="range" id="metallicSlider" min="0" max="1" step="0.01" value="0">
  </div>
  <div class="control-group">
  <label for="roughnessSlider">Roughness <span id="roughnessVal">0.50</span></label>
  <input type="range" id="roughnessSlider" min="0" max="1" step="0.01" value="0.5">
  </div>

  <h2>Layers</h2>
  <ol id="layersList"></ol>
  <button id="addLayerBtn">+ Add Layer</button>

  <div class="control-group">
  <label for="brushOpacity">Brush Opacity <span id="brushOpacityVal">100</span>%</label>
  <input type="range" id="brushOpacity" min="1" max="100" value="100">
  </div>

  <h2>Painting Tools</h2>
  <div class="control-group">
  <label for="paintColor">Brush Color (current layer)</label>
  <input type="color" id="paintColor" value="#ff4444">
  </div>
  <div class="control-group">
  <label for="brushSize">Brush Size <span id="brushSizeVal">0.10</span></label>
  <input type="range" id="brushSize" min="0.01" max="1.0" step="0.01" value="0.1">
  </div>
  <div class="control-group">
  <label for="brushShape">Brush Shape</label>
  <select id="brushShape">
  <option value="soft-circle">Soft Circle</option>
  <option value="hard-circle">Hard Circle</option>
  <option value="custom">Custom Brush (upload PNG)</option>
  </select>
  </div>
  <div class="control-group" id="customBrushGroup" style="display:none;">
  <label for="uploadBrush">Upload Custom Brush (grayscale PNG)</label>
  <input type="file" id="uploadBrush" accept="image/png">
  <canvas id="customBrushPreview" width="80" height="80"></canvas>
  <div class="hint">White = full paint, black = no paint</div>
  </div>

  <button id="paintToggle">Activate Paint Mode</button>
  <button id="eyedropperToggle">Eyedropper Tool</button>
  <button id="maskToggle">Mask Mode (Paint Invisibility)</button>

  <div id="undoRedoGroup">
  <button id="undoBtn" disabled>Undo (Ctrl+Z)</button>
  <button id="redoBtn" disabled>Redo (Ctrl+Y)</button>
  </div>

  <button id="clearPaint" style="background:#ef4444;">Clear Current Layer</button>
  <button id="clearMask" style="background:#64748b; display:none;">Reset Global Mask</button>

  <h2>Lighting</h2>
  <div class="control-group">
  <label for="envPreset">Environment</label>
  <select id="envPreset">
  <option value="neutral">Neutral</option>
  <option value="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r182/examples/textures/equirect/royal_esplanade_1k.hdr">Royal Esplanade</option>
  <option value="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r182/examples/textures/equirect/spruit_sunrise_1k.hdr">Sunrise</option>
  <option value="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r182/examples/textures/equirect/moonless_golf_1k.hdr">Night</option>
  </select>
  </div>

  <h2>Export</h2>
  <button id="exportBtn">Export Modified GLB</button>
  <div id="exportStatus" style="margin-top:0.5rem;font-size:0.8rem;color:#94a3b8;"></div>
  </div>
</div>

<footer class="site-footer">
  <div class="footer-inner">
  <nav class="footer-nav">
  <a href="about.html">About</a>
  <a href="privacy.html">Privacy</a>
  <a href="terms.html">Terms</a>
  <a href="license.html">License</a>
  <a href="refund.html">Refund</a>
  <a href="rewards.html">Rewards</a>
  </nav>
  <p>¬© 2026 BowesProduct</p>
  </div>
</footer>

<!-- Fixed Mobile Toggle Button (Outside Panel) -->
<div id="mobilePanelToggle"><span>‚ñ≤ Controls</span></div>

<!-- Firebase Auth -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js";
  import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-auth.js";
  import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyB4JMVBMcWcN2wKsaVYmnggHH5ue1mUfaA",
    authDomain: "bowesproduct.firebaseapp.com",
    projectId: "bowesproduct"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);
  const provider = new GoogleAuthProvider();

  const authBtn = document.getElementById("authBtn");
  const profilePic = document.getElementById("profilePic");
  const levelInfo = document.getElementById("levelInfo");
  const levelText = document.getElementById("levelText");
  const xpBar = document.getElementById("xpBar");

  authBtn.onclick = () =>
    auth.currentUser ? signOut(auth) : signInWithPopup(auth, provider);

  onAuthStateChanged(auth, async (user) => {
    if (!user) {
      authBtn.textContent = "Login";
      profilePic.style.display = "none";
      levelInfo.style.display = "none";
      return;
    }
    authBtn.textContent = "Logout";
    profilePic.src = user.photoURL || "";
    profilePic.style.display = "block";

    const ref = doc(db, "users", user.uid);
    let snap = await getDoc(ref);
    if (!snap.exists()) {
      await setDoc(ref, { xp: 10 });
      snap = await getDoc(ref);
    }
    const xp = snap.data().xp || 0;
    const levels = [0, 200, 500, 1000, 2000];
    let level = levels.filter(v => xp >= v).length - 1;
    let next = levels[level + 1] ?? levels[level];
    let progress = next === levels[level] ? 100 :
      ((xp - levels[level]) / (next - levels[level])) * 100;

    levelText.textContent = `Level ${level} ‚Ä¢ ${xp} XP`;
    xpBar.style.width = progress + "%";
    levelInfo.style.display = "block";
  });
</script>

<!-- Three.js + Features -->
<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
  import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';

  const canvas = document.getElementById('canvas');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, preserveDrawingBuffer: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.toneMapping = THREE.NoToneMapping;
  renderer.toneMappingExposure = 1.0;
  renderer.outputColorSpace = THREE.SRGBColorSpace;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x020617);
  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
  dirLight.position.set(5, 10, 7);
  scene.add(dirLight);

  const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
  camera.position.set(3, 2, 5);

  const controls = new OrbitControls(camera, canvas);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };

  const pmremGenerator = new THREE.PMREMGenerator(renderer);
  pmremGenerator.compileEquirectangularShader();
  let currentEnvMap = null;

  function loadEnvironment(url) {
  if (url === 'neutral') {
  scene.environment = null;
  if (currentEnvMap) currentEnvMap.dispose();
  return;
  }
  new RGBELoader().load(url, (tex) => {
  const envMap = pmremGenerator.fromEquirectangular(tex).texture;
  scene.environment = envMap;
  tex.dispose();
  if (currentEnvMap) currentEnvMap.dispose();
  currentEnvMap = envMap;
  });
  }
  loadEnvironment('neutral');

  let currentModel = null;
  let modelSize = 1;
  let paintedGeometries = [];
  let paintColor = new THREE.Color('#ff4444');
  let brushSize = 0.1;
  let brushShape = 'soft-circle';
  let paintModeActive = false;
  let eyedropperActive = false;
  let maskMode = false;

  const layers = [];
  let currentLayerIndex = 0;
  let layerData = {}; 
  let globalMaskData = {};

  const undoStack = [];
  const redoStack = [];
  const MAX_UNDO = 30;
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');

  function saveState() {
  if (paintedGeometries.length === 0) return;
  const state = {
    layers: layers.map(l => ({ color: l.color.clone(), opacity: l.opacity, blendMode: l.blendMode, visible: l.visible, name: l.name })),
    layerData: JSON.parse(JSON.stringify(layerData)),
    globalMaskData: JSON.parse(JSON.stringify(globalMaskData))
  };
  undoStack.push(state);
  if (undoStack.length > MAX_UNDO) undoStack.shift();
  redoStack.length = 0;
  undoBtn.disabled = false;
  redoBtn.disabled = true;
  }

  function undo() {
  if (undoStack.length === 0) return;
  redoStack.push({
    layers: layers.map(l => ({ color: l.color.clone(), opacity: l.opacity, blendMode: l.blendMode, visible: l.visible, name: l.name })),
    layerData: JSON.parse(JSON.stringify(layerData)),
    globalMaskData: JSON.parse(JSON.stringify(globalMaskData))
  });
  const state = undoStack.pop();
  restoreState(state);
  undoBtn.disabled = undoStack.length === 0;
  redoBtn.disabled = false;
  }

  function redo() {
  if (redoStack.length === 0) return;
  undoStack.push({
    layers: layers.map(l => ({ color: l.color.clone(), opacity: l.opacity, blendMode: l.blendMode, visible: l.visible, name: l.name })),
    layerData: JSON.parse(JSON.stringify(layerData)),
    globalMaskData: JSON.parse(JSON.stringify(globalMaskData))
  });
  const state = redoStack.pop();
  restoreState(state);
  redoBtn.disabled = redoStack.length === 0;
  undoBtn.disabled = false;
  }

  function restoreState(state) {
  layers.length = 0;
  state.layers.forEach(ld => layers.push({ color: ld.color, opacity: ld.opacity, blendMode: ld.blendMode, visible: ld.visible, name: ld.name }));
  layerData = JSON.parse(JSON.stringify(state.layerData));
  const newMaskData = {};
  if (state.globalMaskData) {
      Object.keys(state.globalMaskData).forEach(key => {
          newMaskData[key] = new Float32Array(state.globalMaskData[key]);
      });
  }
  globalMaskData = newMaskData;
  
  updateLayersUI();
  updateAllGeometries();
  }

  undoBtn.onclick = undo;
  redoBtn.onclick = redo;
  window.addEventListener('keydown', e => {
  if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
  if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); }
  });

  const brushCursor = document.getElementById('brushCursor');
  const eyedropperCursor = document.getElementById('eyedropperCursor');
  const exportStatus = document.getElementById('exportStatus');
  const maskToggle = document.getElementById('maskToggle');
  const clearMaskBtn = document.getElementById('clearMask');
  const loader = document.getElementById('loader');
  
  const floaterPaint = document.getElementById('floaterPaint');
  const floaterEye = document.getElementById('floaterEye');
  const floaterColor = document.getElementById('floaterColor');

  const panel = document.getElementById('panel');
  const panelToggle = document.getElementById('panelToggle');
  const mobilePanelToggle = document.getElementById('mobilePanelToggle');
  let panelVisible = true;

  function togglePanel() {
  panelVisible = !panelVisible;
  panel.classList.toggle('hidden', !panelVisible);
  panel.classList.toggle('visible', panelVisible);
  panelToggle.textContent = panelVisible ? '‚Üê' : '‚Üí';
  if(window.innerWidth <= 900) {
     const span = mobilePanelToggle.querySelector('span');
     if(span) span.textContent = panelVisible ? '‚ñº Hide Controls' : '‚ñ≤ Controls';
  }
  updateFloaterVisibility();
  }

  function updateFloaterVisibility() {
     const isMobile = window.innerWidth <= 900;
     const showFloaters = !isMobile || (isMobile && !panelVisible);
     
     if(paintModeActive) {
         floaterPaint.classList.add('active');
     } else {
         floaterPaint.classList.remove('active');
     }
     if(eyedropperActive) {
         floaterEye.classList.add('active');
     } else {
         floaterEye.classList.remove('active');
     }
     if(maskMode) {
         floaterPaint.classList.add('active-mask');
     } else {
         floaterPaint.classList.remove('active-mask');
     }
  }

  panelToggle.onclick = togglePanel;
  mobilePanelToggle.onclick = (e) => {
    e.stopPropagation();
    togglePanel();
  };

  function updatePanelMode() {
  if (window.innerWidth <= 900) {
  mobilePanelToggle.style.display = 'flex';
  panelToggle.style.display = 'none';
  } else {
  mobilePanelToggle.style.display = 'none';
  panelToggle.style.display = 'flex';
  }
  updateFloaterVisibility();
  }
  updatePanelMode();
  window.addEventListener('resize', updatePanelMode);

  canvas.addEventListener('touchstart', (e) => {
  if (window.innerWidth <= 900 && panelVisible && !paintModeActive && !eyedropperActive && !maskMode && e.touches.length === 1) {
    const touch = e.touches[0];
    const target = document.elementFromPoint(touch.clientX, touch.clientY);
    if (target === canvas || target.id === 'container') {
      e.preventDefault(); 
      togglePanel();
    }
  }
  });

  function blendColor(base, overlay, mode, opacity) {
  const o = overlay.clone();
  switch (mode) {
  case 'multiply':
  return base.clone().multiplyScalar(1 - opacity).add(base.clone().multiply(o).multiplyScalar(opacity));
  case 'screen':
  return base.clone().lerp(new THREE.Color(1,1,1), 1 - (1 - base.r) * (1 - o.r) * opacity);
  case 'overlay':
  const r = base.r < 0.5 ? 2 * base.r * o.r : 1 - 2 * (1 - base.r) * (1 - o.r);
  const g = base.g < 0.5 ? 2 * base.g * o.g : 1 - 2 * (1 - base.g) * (1 - o.g);
  const b = base.b < 0.5 ? 2 * base.b * o.b : 1 - 2 * (1 - base.b) * (1 - o.b);
  return base.clone().multiplyScalar(1 - opacity).add(new THREE.Color(r, g, b).multiplyScalar(opacity));
  case 'add':
  return base.clone().add(o.multiplyScalar(opacity));
  default: 
  return base.clone().lerp(o, opacity);
  }
  }

  function addLayer() {
  saveState();
  const layer = {
  name: `Layer ${layers.length + 1}`,
  color: new THREE.Color('#ff4444'),
  opacity: 1.0,
  visible: true,
  blendMode: 'normal'
  };
  layers.push(layer);
  paintedGeometries.forEach((pg, idx) => {
  const geoKey = `geo_${idx}`;
  if (!layerData[geoKey]) layerData[geoKey] = {};
  const colors = new Float32Array(pg.geometry.attributes.position.count * 3).fill(1);
  layerData[geoKey][layers.length - 1] = Array.from(colors);
  });
  updateLayersUI();
  setActiveLayer(layers.length - 1);
  }

  function deleteLayer(idx) {
  if (layers.length <= 1) return;
  saveState();
  Object.keys(layerData).forEach(key => {
  const geoLayers = layerData[key];
  delete geoLayers[idx];
  for (let i = idx; i < layers.length - 1; i++) {
  geoLayers[i] = geoLayers[i + 1];
  }
  delete geoLayers[layers.length - 1];
  });
  layers.splice(idx, 1);
  if (currentLayerIndex >= layers.length) currentLayerIndex = layers.length - 1;
  updateLayersUI();
  updateAllGeometries();
  }

  function moveLayer(fromIdx, toIdx) {
  saveState();
  const [layer] = layers.splice(fromIdx, 1);
  layers.splice(toIdx, 0, layer);
  Object.keys(layerData).forEach(key => {
  const geoLayers = layerData[key];
  const data = geoLayers[fromIdx];
  delete geoLayers[fromIdx];
  const keys = Object.keys(geoLayers).map(Number).sort((a,b)=>a-b);
  const values = keys.map(k => geoLayers[k]);
  values.splice(fromIdx, 1);
  values.splice(toIdx, 0, data);
  for(let i=0; i<layers.length; i++) {
     geoLayers[i] = values[i];
  }
  });
  if (currentLayerIndex === fromIdx) currentLayerIndex = toIdx;
  else if (fromIdx < currentLayerIndex && toIdx >= currentLayerIndex) currentLayerIndex--;
  else if (fromIdx > currentLayerIndex && toIdx <= currentLayerIndex) currentLayerIndex++;
  updateLayersUI();
  updateAllGeometries();
  }

  function setActiveLayer(idx) {
  currentLayerIndex = idx;
  updateLayersUI();
  paintColor.copy(layers[idx].color);
  const displayColor = paintColor.clone();
  document.getElementById('paintColor').value = '#' + displayColor.getHexString();
  floaterColor.value = '#' + displayColor.getHexString();
  
  // Update paintColor variable to match the new layer's color
  paintColor.set(layers[idx].color);
  }

  function updateLayersUI() {
  const list = document.getElementById('layersList');
  list.innerHTML = '';
  layers.slice().reverse().forEach((layer, reverseIdx) => {
  const i = layers.length - 1 - reverseIdx;
  const li = document.createElement('li');
  li.className = 'layer-item' + (i === currentLayerIndex ? ' active' : '');
  li.draggable = true;
  
  const displayColor = layer.color.clone();
  
  li.innerHTML = `
  <span class="layer-visibility">${layer.visible ? 'üëÅ' : 'üö´'}</span>
  <input type="color" class="layer-color" value="#${displayColor.getHexString()}">
  <input type="range" class="layer-opacity" min="0" max="100" value="${layer.opacity * 100}">
  <select class="layer-blend">
  <option value="normal">Normal</option>
  <option value="multiply">Multiply</option>
  <option value="screen">Screen</option>
  <option value="overlay">Overlay</option>
  <option value="add">Add</option>
  </select>
  <input class="layer-name" value="${layer.name}">
  <span class="layer-delete">√ó</span>
  `;

  li.querySelector('.layer-name').addEventListener('click', (e) => setActiveLayer(i));
  li.querySelector('.layer-visibility').onclick = (e) => {
  e.stopPropagation();
  layer.visible = !layer.visible;
  li.querySelector('.layer-visibility').textContent = layer.visible ? 'üëÅ' : 'üö´';
  updateAllGeometries();
  };

  li.querySelector('.layer-color').oninput = (e) => {
  e.stopPropagation();
  layer.color.set(e.target.value); 
  if (i === currentLayerIndex) paintColor.copy(layer.color);
  updateAllGeometries();
  };

  li.querySelector('.layer-opacity').oninput = (e) => {
  e.stopPropagation();
  layer.opacity = e.target.value / 100;
  updateAllGeometries();
  };

  li.querySelector('.layer-blend').onchange = (e) => {
  e.stopPropagation();
  layer.blendMode = e.target.value;
  updateAllGeometries();
  };

  li.querySelector('.layer-delete').onclick = (e) => {
  e.stopPropagation();
  deleteLayer(i);
  };

  li.addEventListener('dragstart', (e) => e.dataTransfer.setData('text/plain', i));
  li.addEventListener('dragover', (e) => e.preventDefault());
  li.addEventListener('drop', (e) => {
  e.preventDefault();
  e.stopPropagation();
  const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
  const toIdx = i;
  if (fromIdx !== toIdx && !isNaN(fromIdx)) moveLayer(fromIdx, toIdx);
  });

  list.appendChild(li);
  });
  }

  function updateAllGeometries() {
  paintedGeometries.forEach((pg, geoIdx) => {
  const col = pg.geometry.attributes.color;
  const geoKey = `geo_${geoIdx}`;
  const maskArr = globalMaskData[geoKey]; 

  for (let i = 0; i < col.count; i++) {
  col.setXYZ(i, 1, 1, 1);
  }

  layers.forEach((layer, layerIdx) => {
  if (!layer.visible) return;
  const geoLayerData = layerData[geoKey]?.[layerIdx];
  if (!geoLayerData) return;

  for (let i = 0; i < col.count; i++) {
  const base = new THREE.Color(col.getX(i), col.getY(i), col.getZ(i));
  const overlay = new THREE.Color(geoLayerData[i*3], geoLayerData[i*3+1], geoLayerData[i*3+2]);
  if (overlay.r !== 1 || overlay.g !== 1 || overlay.b !== 1) {
  const result = blendColor(base, overlay, layer.blendMode, layer.opacity);
  col.setXYZ(i, result.r, result.g, result.b);
  }
  }
  });

  if (maskArr) {
    for (let i = 0; i < col.count; i++) {
      const maskVal = maskArr[i];
      if (maskVal < 0.99) {
        col.setXYZ(i, col.getX(i) * maskVal, col.getY(i) * maskVal, col.getZ(i) * maskVal);
      }
    }
  }

  col.needsUpdate = true;
  });
  }

  document.getElementById('addLayerBtn').onclick = addLayer;
  addLayer();

  maskToggle.onclick = () => {
  maskMode = !maskMode;
  maskToggle.classList.toggle('active', maskMode);
  clearMaskBtn.style.display = maskMode ? 'block' : 'none';
  controls.enabled = !maskMode && !paintModeActive && !eyedropperActive;
  
  if(maskMode) {
    maskToggle.textContent = 'Exit Mask Mode';
    if(paintModeActive) setPaintMode(false);
    if(eyedropperActive) setEyedropperMode(false);
    
    // Initialize mask data if it doesn't exist
    paintedGeometries.forEach((pg, geoIdx) => {
      const geoKey = `geo_${geoIdx}`;
      if (!globalMaskData[geoKey]) {
        globalMaskData[geoKey] = new Float32Array(pg.geometry.attributes.position.count).fill(1.0);
      }
    });
  } else {
    maskToggle.textContent = 'Mask Mode (Paint Invisibility)';
  }
  updateFloaterVisibility();
  };
  
  clearMaskBtn.onclick = () => {
      saveState();
      Object.keys(globalMaskData).forEach(k => {
          globalMaskData[k].fill(1.0);
      });
      updateAllGeometries();
  };

  document.getElementById('brushOpacity').oninput = (e) => {
  document.getElementById('brushOpacityVal').textContent = e.target.value;
  };

  function sampleColor(x, y) {
  const rect = canvas.getBoundingClientRect();
  const gl = renderer.getContext();
  const pixel = new Uint8Array(4);
  const pixelX = Math.floor((x - rect.left) * renderer.getPixelRatio());
  const pixelY = Math.floor((rect.height - (y - rect.top)) * renderer.getPixelRatio());
  gl.readPixels(pixelX, pixelY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
  
  const r = pixel[0] / 255;
  const g = pixel[1] / 255;
  const b = pixel[2] / 255;
  
  paintColor.setRGB(r, g, b);
  
  const displayColor = paintColor.clone();
  document.getElementById('paintColor').value = '#' + displayColor.getHexString();
  floaterColor.value = '#' + displayColor.getHexString();
  
  // Update paintColor variable
  paintColor.setRGB(r, g, b);
  
  if(!maskMode) {
      layers[currentLayerIndex].color.copy(paintColor);
      updateLayersUI();
  }
  }

  function getWorldBrushRadius() {
  const dist = camera.position.distanceTo(controls.target);
  const fov = camera.fov * (Math.PI / 180);
  const visibleHeight = 2 * Math.tan(fov / 2) * dist;
  return brushSize * visibleHeight * 0.3;
  }

  function getBrushRadiusInPixels() {
  const worldRadius = getWorldBrushRadius();
  const dist = camera.position.distanceTo(controls.target);
  const fov = camera.fov * (Math.PI / 180);
  const visibleHeight = 2 * Math.tan(fov / 2) * dist;
  const pixelRadius = (worldRadius / visibleHeight) * window.innerHeight;
  return pixelRadius;
  }

  function updateBrushCursor(x, y) {
  if (!paintModeActive && !maskMode) return;
  brushCursor.style.display = maskMode ? 'none' : 'block';
  if (maskMode) {
     brushCursor.style.display = 'block';
     brushCursor.style.borderColor = '#ec4899';
     brushCursor.style.backgroundColor = 'rgba(236, 72, 153, 0.1)';
  } else {
     brushCursor.style.borderColor = paintColor.getStyle();
     brushCursor.style.backgroundColor = `rgba(${paintColor.r*255}, ${paintColor.g*255}, ${paintColor.b*255}, 0.1)`;
  }
  brushCursor.style.left = x + 'px';
  brushCursor.style.top = y + 'px';
  const radiusPx = getBrushRadiusInPixels();
  const diameter = Math.max(radiusPx * 2, 10);
  brushCursor.style.width = diameter + 'px';
  brushCursor.style.height = diameter + 'px';
  if (brushShape === 'soft-circle') {
     brushCursor.style.boxShadow = `0 0 ${diameter/2}px ${diameter/4}px ${maskMode ? '#ec4899' : paintColor.getStyle()}`;
  } else {
     brushCursor.style.boxShadow = 'none';
  }
  }

  function hideCursors() {
  brushCursor.style.display = 'none';
  eyedropperCursor.style.display = 'none';
  }

  function paintAt(point) {
  if ((!paintModeActive && !maskMode) || paintedGeometries.length === 0) return;
  
  const brushOpacity = document.getElementById('brushOpacity').value / 100;
  const radius = getWorldBrushRadius();
  const radiusSq = radius * radius;
  const vert = new THREE.Vector3();

  if (maskMode) {
      let painted = false;
      paintedGeometries.forEach((pg, geoIdx) => {
          const pos = pg.geometry.attributes.position;
          const col = pg.geometry.attributes.color;
          const inv = new THREE.Matrix4().copy(pg.mesh.matrixWorld).invert();
          const local = point.clone().applyMatrix4(inv);
          const geoKey = `geo_${geoIdx}`;
          if (!globalMaskData[geoKey]) {
              globalMaskData[geoKey] = new Float32Array(pos.count).fill(1.0);
          }
          const maskArr = globalMaskData[geoKey];
          
          for (let i = 0; i < pos.count; i++) {
              vert.fromBufferAttribute(pos, i);
              const distSq = vert.distanceToSquared(local);
              if (distSq > radiusSq) continue;
              
              let falloff = 1 - Math.sqrt(distSq) / radius;
              if (brushShape === 'hard-circle') falloff = 1;
              if (brushShape === 'soft-circle') falloff = Math.pow(falloff, 2);
              
              const alpha = brushOpacity * falloff;
              maskArr[i] = Math.max(0, maskArr[i] * (1 - alpha));
              painted = true;
          }
      });
      if (painted) {
          updateAllGeometries();
      }
      return;
  }

  paintedGeometries.forEach((pg, geoIdx) => {
  const pos = pg.geometry.attributes.position;
  const inv = new THREE.Matrix4().copy(pg.mesh.matrixWorld).invert();
  const local = point.clone().applyMatrix4(inv);
  const geoKey = `geo_${geoIdx}`;
  const maskArr = globalMaskData[geoKey];
  
  if (!layerData[geoKey]) layerData[geoKey] = {};
  if (!layerData[geoKey][currentLayerIndex]) {
  const colors = new Float32Array(pos.count * 3).fill(1);
  layerData[geoKey][currentLayerIndex] = Array.from(colors);
  }
  const geoLayerColors = layerData[geoKey][currentLayerIndex];

  for (let i = 0; i < pos.count; i++) {
  vert.fromBufferAttribute(pos, i);
  const distSq = vert.distanceToSquared(local);
  if (distSq > radiusSq) continue;
  
  let falloff = 1 - Math.sqrt(distSq) / radius;
  if (brushShape === 'hard-circle') falloff = 1;
  if (brushShape === 'soft-circle') falloff = Math.pow(falloff, 2);

  const alpha = brushOpacity * falloff;
  const paintRGB = layers[currentLayerIndex].color;

  const current = new THREE.Color(geoLayerColors[i*3], geoLayerColors[i*3+1], geoLayerColors[i*3+2]);
  const result = blendColor(current, paintRGB, layers[currentLayerIndex].blendMode, alpha);

  geoLayerColors[i*3] = result.r;
  geoLayerColors[i*3+1] = result.g;
  geoLayerColors[i*3+2] = result.b;
  }
  });

  updateAllGeometries();
  }

  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  let isPointerDown = false;

  canvas.addEventListener('pointermove', (e) => {
  if (paintModeActive || maskMode) updateBrushCursor(e.clientX, e.clientY);
  if (isPointerDown && (paintModeActive || maskMode) && currentModel && !eyedropperActive) {
  const rect = canvas.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObject(currentModel, true);
  if (intersects.length > 0) paintAt(intersects[0].point);
  }
  });

  canvas.addEventListener('pointerdown', (e) => {
  isPointerDown = true;
  if (eyedropperActive) {
  sampleColor(e.clientX, e.clientY);
  return;
  }
  if ((paintModeActive || maskMode) && currentModel) {
  const rect = canvas.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObject(currentModel, true);
  if (intersects.length > 0) paintAt(intersects[0].point);
  }
  });

  canvas.addEventListener('pointerup', () => {
  if (isPointerDown) {
  isPointerDown = false;
  saveState();
  }
  });

  canvas.addEventListener('pointerleave', () => { isPointerDown = false; hideCursors(); });

  window.addEventListener('keydown', (e) => {
  if (e.altKey && (paintModeActive || maskMode) && !eyedropperActive) {
  eyedropperActive = true;
  hideCursors();
  eyedropperCursor.style.display = 'block';
  }
  });

  window.addEventListener('keyup', (e) => {
  if (!e.altKey && eyedropperActive) {
  eyedropperActive = false;
  hideCursors();
  }
  });

  const setPaintMode = (isActive) => {
      paintModeActive = isActive;
      const btn = document.getElementById('paintToggle');
      btn.textContent = paintModeActive ? 'Deactivate Paint Mode' : 'Activate Paint Mode';
      btn.classList.toggle('active', paintModeActive);
      // FIX: Disable orbit controls when paint mode is active
      controls.enabled = !paintModeActive && !maskMode && !eyedropperActive;
      
      if(maskMode) maskToggle.click();
      if(eyedropperActive) setEyedropperMode(false);
      if (!paintModeActive) hideCursors();
      else updateBrushCursor(window.innerWidth/2, window.innerHeight/2);
      updateFloaterVisibility();
  };

  const setEyedropperMode = (isActive) => {
      eyedropperActive = isActive;
      const btn = document.getElementById('eyedropperToggle');
      btn.textContent = eyedropperActive ? 'Cancel Eyedropper' : 'Eyedropper Tool';
      btn.classList.toggle('active', eyedropperActive);
      // FIX: Disable orbit controls when eyedropper is active
      controls.enabled = !eyedropperActive && !paintModeActive && !maskMode;
      if (!eyedropperActive) hideCursors();
      updateFloaterVisibility();
  }

  document.getElementById('eyedropperToggle').addEventListener('click', () => setEyedropperMode(!eyedropperActive));
  floaterEye.onclick = () => setEyedropperMode(!eyedropperActive);

  document.getElementById('paintToggle').addEventListener('click', () => setPaintMode(!paintModeActive));
  floaterPaint.onclick = () => setPaintMode(!paintModeActive);

  floaterColor.oninput = (e) => {
      paintColor.set(e.target.value);
      layers[currentLayerIndex].color.copy(paintColor);
      document.getElementById('paintColor').value = e.target.value;
      updateLayersUI();
      
      // Also update the base color in the paint color picker
      document.getElementById('paintColor').value = e.target.value;
      paintColor.set(e.target.value);
  };

  document.getElementById('uploadModel').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const url = URL.createObjectURL(file);
  loadModel(url);
  });

  function loadModel(url) {
  loader.style.display = 'block';
  loader.textContent = "Loading...";
  new GLTFLoader().load(url, (gltf) => {
  if (currentModel) scene.remove(currentModel);
  currentModel = gltf.scene;
  scene.add(currentModel);
  const box = new THREE.Box3().setFromObject(currentModel);
  modelSize = box.getSize(new THREE.Vector3()).length() || 1;
  const center = box.getCenter(new THREE.Vector3());
  camera.position.copy(center).add(new THREE.Vector3(modelSize, modelSize * 0.7, modelSize));
  controls.target.copy(center);
  controls.update();
  
  paintedGeometries = [];
  layerData = {};
  globalMaskData = {};
  undoStack.length = 0;
  redoStack.length = 0;
  undoBtn.disabled = true;
  redoBtn.disabled = true;
  
  currentModel.traverse((child) => {
  if (child.isMesh) {
  if (!(child.material instanceof THREE.MeshStandardMaterial)) {
  child.material = new THREE.MeshStandardMaterial({ map: child.material?.map, color: 0xffffff });
  }
  child.material.vertexColors = true;
  if (!child.geometry.attributes.color) {
  const colors = new Float32Array(child.geometry.attributes.position.count * 3).fill(1);
  child.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  }
  const geoIdx = paintedGeometries.length;
  paintedGeometries.push({ geometry: child.geometry, mesh: child });
  const geoKey = `geo_${geoIdx}`;
  layerData[geoKey] = {};
  globalMaskData[geoKey] = new Float32Array(child.geometry.attributes.position.count).fill(1.0);
  layers.forEach((_, layerIdx) => {
  const colors = new Float32Array(child.geometry.attributes.position.count * 3).fill(1);
  layerData[geoKey][layerIdx] = Array.from(colors);
  });
  }
  });
  updateAllGeometries();
  saveState();
  loader.style.display = 'none';
  }, undefined, (error) => {
  loader.textContent = "Error loading model";
  console.error(error);
  });
  }

  function applyTexture(url) {
  if (!currentModel) return;
  new THREE.TextureLoader().load(url, (tex) => {
  tex.flipY = false;
  tex.colorSpace = THREE.SRGBColorSpace;
  currentModel.traverse((child) => {
  if (child.isMesh) {
  child.material.map = tex.clone();
  child.material.needsUpdate = true;
  }
  });
  });
  }

  document.getElementById('presetTexture').addEventListener('change', (e) => {
  if (e.target.value) applyTexture(e.target.value);
  });

  document.getElementById('uploadTexture').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (file) applyTexture(URL.createObjectURL(file));
  });

  document.getElementById('metallicSlider').addEventListener('input', (e) => {
  const v = parseFloat(e.target.value);
  document.getElementById('metallicVal').textContent = v.toFixed(2);
  currentModel?.traverse((child) => {
  if (child.isMesh) child.material.metalness = v;
  });
  });

  document.getElementById('roughnessSlider').addEventListener('input', (e) => {
  const v = parseFloat(e.target.value);
  document.getElementById('roughnessVal').textContent = v.toFixed(2);
  currentModel?.traverse((child) => {
  if (child.isMesh) child.material.roughness = v;
  });
  });

  document.getElementById('paintColor').addEventListener('input', (e) => {
  paintColor.set(e.target.value);
  layers[currentLayerIndex].color.copy(paintColor);
  // Update floaterColor to match
  floaterColor.value = e.target.value;
  updateLayersUI();
  });

  document.getElementById('brushSize').addEventListener('input', (e) => {
  brushSize = parseFloat(e.target.value);
  document.getElementById('brushSizeVal').textContent = brushSize.toFixed(2);
  });

  document.getElementById('brushShape').addEventListener('change', (e) => {
  brushShape = e.target.value;
  const customGroup = document.getElementById('customBrushGroup');
  customGroup.style.display = brushShape === 'custom' ? 'block' : 'none';
  });

  document.getElementById('envPreset').addEventListener('change', (e) => loadEnvironment(e.target.value));

  document.getElementById('clearPaint').addEventListener('click', () => {
  saveState();
  paintedGeometries.forEach((pg, geoIdx) => {
  const geoKey = `geo_${geoIdx}`;
  if (layerData[geoKey] && layerData[geoKey][currentLayerIndex]) {
  layerData[geoKey][currentLayerIndex].fill(1);
  }
  });
  updateAllGeometries();
  });

  document.getElementById('exportBtn').addEventListener('click', () => {
  if (!currentModel) {
  exportStatus.textContent = 'No model loaded';
  exportStatus.style.color = '#ef4444';
  return;
  }
  exportStatus.textContent = 'Exporting...';
  exportStatus.color = '#60a5fa';
  const exporter = new GLTFExporter();
  const clone = currentModel.clone();
  clone.traverse((child) => {
  if (child.isMesh) {
  child.material = child.material.clone();
  child.material.vertexColors = true;
  child.material.needsUpdate = true;
  }
  });
  exporter.parse(clone, (result) => {
  const blob = new Blob([result], { type: 'application/octet-stream' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = 'retextured_model.glb';
  link.click();
  exportStatus.textContent = 'Exported!';
  exportStatus.style.color = '#4ade80';
  }, (err) => {
  exportStatus.textContent = 'Export failed';
  exportStatus.color = '#ef4444';
  console.error(err);
  }, { binary: true });
  });

  window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  updatePanelMode();
  });

  function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
  }
  animate();
  
  window.addEventListener('dragover', e => e.preventDefault());
  window.addEventListener('drop', e => {
      e.preventDefault();
      if(e.dataTransfer.files && e.dataTransfer.files[0]) {
          const file = e.dataTransfer.files[0];
          if(file.name.toLowerCase().endsWith('.glb') || file.name.toLowerCase().endsWith('.gltf')) {
              loadModel(URL.createObjectURL(file));
          }
      }
  });
</script>

</body>
</html>


