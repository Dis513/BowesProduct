<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Retexture Pro ‚Äì BowesProduct</title>
  <script async src="https://unpkg.com/es-module-shims@1.8.2/dist/es-module-shims.js"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
    }
  }
  </script>
  <style>
  *, *::before, *::after { box-sizing: border-box; }
  html, body { margin: 0; height: 100%; background: #020617; color: white; font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif; overflow: hidden; -webkit-font-smoothing: antialiased; }

  .site-header {
  position: sticky; top: 0; z-index: 1000; background: rgba(2,6,23,0.95); border-bottom: 1px solid #1e293b; backdrop-filter: blur(10px);
  }
  .header-inner { max-width: 1200px; margin: 0 auto; padding: 0.6rem 1rem; display: flex; align-items: center; justify-content: space-between; }
  .header-left { display: flex; align-items: center; gap: 1.6rem; }
  .logo a { font-size: 1.3rem; font-weight: 700; color: white; text-decoration: none; white-space: nowrap; }
  .main-nav { display: flex; gap: 1.4rem; }
  .main-nav a { color: #e5e7eb; text-decoration: none; font-size: 0.95rem; }
  .main-nav a:hover, .main-nav a.active { color: #60a5fa; }
  .header-right { display: flex; align-items: center; gap: 0.8rem; min-height: 44px; }
  #profilePic { width: 32px; height: 32px; border-radius: 50%; border: 2px solid #60a5fa; object-fit: cover; display: none; }
  .login-btn { padding: 0.45rem 1.1rem; border-radius: 999px; border: 1.5px solid #60a5fa; background: transparent; color: #60a5fa; font-size: 0.95rem; cursor: pointer; }
  #levelInfo { display: none; width: 140px; font-size: 0.8rem; color: #cbd5e1; }
  #levelText { white-space: nowrap; }
  #xpOuter { width: 100%; height: 5px; background: #1e293b; border-radius: 3px; margin-top: 4px; }
  #xpBar { height: 100%; width: 0%; background: #60a5fa; border-radius: 3px; transition: width 0.35s ease; }

  @media (max-width: 768px) {
  .header-inner { flex-direction: column; align-items: stretch; gap: 8px; }
  .header-left { justify-content: space-between; }
  .header-right { justify-content: space-between; width: 100%; }
  #levelInfo { width: 100%; }
  }

  #container { position: relative; width: 100%; height: 100%; padding-top: 70px; padding-bottom: 80px; }
  #canvas { display: block; width: 100%; height: 100%; touch-action: none; outline: none; }

  /* Desktop Panel */
  .panel {
  position: absolute;
  top: 90px;
  right: 20px;
  width: 380px;
  max-height: calc(100vh - 220px);
  background: rgba(2, 6, 23, 0.95);
  border: 1px solid #1e293b;
  border-radius: 12px;
  padding: 1.5rem;
  overflow-y: auto;
  z-index: 20;
  backdrop-filter: blur(10px);
  transition: transform 0.3s ease;
  box-shadow: 0 10px 25px rgba(0,0,0,0.3);
  }
  .panel.hidden { transform: translateX(420px); }
  .panel::-webkit-scrollbar { width: 6px; }
  .panel::-webkit-scrollbar-track { background: #0f172a; }
  .panel::-webkit-scrollbar-thumb { background: #334155; border-radius: 3px; }

  #panelToggle {
  position: absolute;
  left: -60px;
  top: 50%;
  transform: translateY(-50%);
  width: 60px;
  height: 110px;
  background: rgba(2, 6, 23, 0.98);
  border: 1px solid #1e293b;
  border-right: none;
  border-radius: 20px 0 0 20px;
  color: #60a5fa;
  font-size: 2.4rem;
  font-weight: bold;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 21;
  backdrop-filter: blur(12px);
  box-shadow: 0 6px 30px rgba(0,0,0,0.5);
  transition: all 0.3s ease;
  }
  #panelToggle:hover { background: rgba(30, 41, 59, 0.98); color: white; transform: translateY(-50%) translateX(-4px); }

  /* Mobile Bottom Sheet */
  @media (max-width: 900px) {
  .panel {
  position: absolute;
  top: auto;
  right: 0;
  left: 0;
  bottom: 0;
  width: 100%;
  height: 85vh;
  max-height: none;
  border-radius: 20px 20px 0 0;
  transform: translateY(calc(100% - 60px));
  transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1);
  padding-top: 20px;
  padding-bottom: 120px;
  z-index: 1100;
  overflow-y: auto;
  background: rgba(2, 6, 23, 0.95);
  border: 1px solid #1e293b;
  border-bottom: none;
  box-shadow: 0 -5px 25px rgba(0,0,0,0.5);
  }
  .panel.visible {
  transform: translateY(0);
  }

  #panelToggle { display: none; }
  }

  /* Mobile Toggle */
  #mobilePanelToggle {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  width: 160px;
  height: 44px;
  background: rgba(2, 6, 23, 0.9);
  border: 1px solid #60a5fa;
  border-radius: 22px;
  color: #60a5fa;
  font-size: 0.9rem;
  font-weight: 700;
  display: none;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 1200;
  backdrop-filter: blur(12px);
  box-shadow: 0 4px 20px rgba(0,0,0,0.6);
  transition: background 0.2s, transform 0.1s;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  }
  #mobilePanelToggle:active { transform: translateX(-50%) scale(0.96); }
  #mobilePanelToggle::before {
  content: '';
  position: absolute;
  top: -6px;
  left: 50%;
  transform: translateX(-50%);
  width: 40px;
  height: 4px;
  background: #94a3b8;
  border-radius: 2px;
  opacity: 0.5;
  }

  /* Quick Floating Controls */
  #quickControls {
  position: fixed;
  bottom: 80px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 16px;
  z-index: 1200;
  pointer-events: none;
  }
  #quickControls > div {
  pointer-events: auto;
  width: 56px;
  height: 56px;
  border-radius: 50%;
  border: 2px solid #60a5fa;
  background: rgba(2, 6, 23, 0.9);
  backdrop-filter: blur(12px);
  color: #60a5fa;
  font-size: 1.8rem;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  box-shadow: 0 6px 20px rgba(0,0,0,0.6);
  transition: all 0.2s;
  }
  #quickControls > div:hover { transform: translateY(-4px); }
  #quickControls > div.active {
  background: rgba(34, 197, 94, 0.3); /* Green overlay when active */
  color: white;
  border-color: #22c55e;
  }
  #quickColorWrapper {
  position: relative;
  }
  #quickColor {
  opacity: 0;
  width: 100%;
  height: 100%;
  cursor: pointer;
  }
  #quickColorDisplay {
  position: absolute;
  inset: 4px;
  border-radius: 50%;
  background: #ff4444;
  pointer-events: none;
  border: 2px solid #60a5fa;
  }

  .panel h2 { color: #60a5fa; margin: 1.5rem 0 1rem; font-size: 1.1rem; border-bottom: 1px solid #1e293b; padding-bottom: 0.5rem; }
  .control-group { margin-bottom: 1.2rem; }
  label { display: block; font-size: 0.9rem; color: #e5e7eb; margin-bottom: 0.4rem; }
  input, select, button { width: 100%; padding: 0.5rem; border-radius: 0.375rem; border: 1px solid #1f2937; background: #020617; color: #e5e7eb; font: inherit; }
  input[type="range"] { padding: 0.3rem 0; accent-color: #60a5fa; }
  input[type="color"] { height: 44px; padding: 0.2rem; }
  button { background: #60a5fa; border: none; color: white; cursor: pointer; margin-top: 0.8rem; font-weight: 600; position: relative; z-index: 30; transition: background 0.2s; }
  button:hover { background: #3b82f6; }

  #layersList { list-style: none; padding: 0; margin: 0 0 1rem; }
  .layer-item {
  display: flex; align-items: center; gap: 8px; padding: 10px; background: #0f172a; border-radius: 8px; margin-bottom: 8px; cursor: grab; border: 1px solid transparent;
  }
  .layer-item.active { background: #1e293b; border-color: #60a5fa; }
  .layer-visibility { font-size: 1.3rem; cursor: pointer; }
  .layer-color { width: 36px; height: 36px; border: none; border-radius: 6px; cursor: pointer; padding: 0; }
  .layer-delete { color: #ef4444; cursor: pointer; font-size: 1.2rem; }

  #brushCursor, #eyedropperCursor { position: fixed; pointer-events: none; transform: translate(-50%, -50%); z-index: 9999; display: none; }
  #brushCursor { border: 2px solid rgba(255,255,255,0.8); border-radius: 50%; background: rgba(255,68,68,0.2); transition: all 0.1s; box-shadow: 0 0 10px rgba(0,0,0,0.5); }
  #eyedropperCursor { width: 44px; height: 44px; background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="%2360a5fa" stroke-width="3"><path d="M21 11l-8-8-2 2 8 8 2-2zM4 20l7-7"/></svg>') center/32px no-repeat; }

  #paintToggle.active { background: #f87171; }
  #eyedropperToggle.active { background: #7c3aed; border: 1px solid white; }
  #maskToggle.active { background: #ec4899; border: 1px solid white; }

  .site-footer { position: fixed; bottom: 0; left: 0; right: 0; background: rgba(2,6,23,0.95); border-top: 1px solid #1e293b; padding: 1rem; z-index: 1000; backdrop-filter: blur(10px); }

  #loader {
  position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
  color: #60a5fa; font-size: 1.5rem; font-weight: bold; pointer-events: none; z-index: 0;
  text-shadow: 0 2px 10px rgba(0,0,0,0.5);
  }
  </style>
  <script src="https://sites.super.myninja.ai/_assets/ninja-daytona-script.js"></script>
</head>
<body>
<header class="site-header">
  <div class="header-inner">
  <div class="header-left">
  <div class="logo"><a href="index.html">BowesProduct</a></div>
  <nav class="main-nav">
  <a href="index.html">Home</a>
  <a href="models.html">Models</a>
  <a href="retexture.html" class="active">Retexture</a>
  </nav>
  </div>
  <div class="header-right">
  <img id="profilePic" alt="Profile">
  <div id="levelInfo">
  <div id="levelText"></div>
  <div id="xpOuter"><div id="xpBar"></div></div>
  </div>
  <button id="authBtn" class="login-btn">Login</button>
  </div>
  </div>
</header>

<div id="container">
  <div id="loader">Drop a GLB/GLTF model here or use Upload</div>
  <canvas id="canvas"></canvas>
  <div id="brushCursor"></div>
  <div id="eyedropperCursor"></div>

  <!-- Quick Floating Controls -->
  <div id="quickControls">
    <div id="quickPaint">üñå</div>
    <div id="quickEye">üé®</div>
    <div id="quickColorWrapper">
      <input type="color" id="quickColor" value="#ff4444">
      <div id="quickColorDisplay"></div>
    </div>
  </div>

  <div class="panel visible" id="panel">
    <button id="panelToggle">‚Üê</button>

    <div style="padding:0.8rem;background:rgba(30,41,59,0.4);border-radius:8px;margin-bottom:1rem;font-size:0.85rem;line-height:1.4;border:1px solid #334155;">
    <strong style="color:#60a5fa">Controls:</strong><br>
    ‚Ä¢ Drag to rotate ‚Ä¢ Scroll to zoom<br>
    ‚Ä¢ <b>Paint Mode:</b> Paint directly on mesh<br>
    ‚Ä¢ <b>Mask Mode:</b> Paint to hide parts (invisibility)<br>
    ‚Ä¢ PC: Hold Alt to Sample ‚Ä¢ Mobile: Use Eyedropper<br>
    ‚Ä¢ Ctrl+Z/Y Undo/Redo
    </div>

    <h2>Model</h2>
    <div class="control-group">
    <label for="uploadModel">Upload GLB/GLTF</label>
    <input type="file" id="uploadModel" accept=".glb,.gltf">
    <div class="hint">Supports GLB/GLTF. Auto-centers model.</div>
    </div>

    <h2>Texture</h2>
    <div class="control-group">
    <label for="presetTexture">Preset Textures</label>
    <select id="presetTexture">
    <option value="">Original / None</option>
    <option value="textures/wood_basecolor.jpg">Warm Wood</option>
    <option value="textures/metal_basecolor.jpg">Brushed Metal</option>
    <option value="textures/plastic_basecolor.jpg">Matte Plastic</option>
    <option value="textures/fabric_basecolor.jpg">Fabric</option>
    </select>
    </div>
    <div class="control-group">
    <label for="uploadTexture">Custom Texture</label>
    <input type="file" id="uploadTexture" accept="image/*">
    </div>

    <h2>Material</h2>
    <div class="control-group">
    <label for="metallicSlider">Metallic <span id="metallicVal">0.00</span></label>
    <input type="range" id="metallicSlider" min="0" max="1" step="0.01" value="0">
    </div>
    <div class="control-group">
    <label for="roughnessSlider">Roughness <span id="roughnessVal">0.50</span></label>
    <input type="range" id="roughnessSlider" min="0" max="1" step="0.01" value="0.5">
    </div>

    <h2>Layers</h2>
    <ol id="layersList"></ol>
    <button id="addLayerBtn">+ Add Layer</button>

    <div class="control-group">
    <label for="brushOpacity">Brush Opacity <span id="brushOpacityVal">100</span>%</label>
    <input type="range" id="brushOpacity" min="1" max="100" value="100">
    </div>

    <h2>Painting Tools</h2>
    <div class="control-group">
    <label for="paintColor">Brush Color (current layer)</label>
    <input type="color" id="paintColor" value="#ff4444">
    </div>
    <div class="control-group">
    <label for="brushSize">Brush Size <span id="brushSizeVal">0.10</span></label>
    <input type="range" id="brushSize" min="0.01" max="1.0" step="0.01" value="0.1">
    </div>
    <div class="control-group">
    <label for="brushShape">Brush Shape</label>
    <select id="brushShape">
    <option value="soft-circle">Soft Circle</option>
    <option value="hard-circle">Hard Circle</option>
    <option value="custom">Custom Brush (upload PNG)</option>
    </select>
    </div>
    <div class="control-group" id="customBrushGroup" style="display:none;">
    <label for="uploadBrush">Upload Custom Brush (grayscale PNG)</label>
    <input type="file" id="uploadBrush" accept="image/png">
    <canvas id="customBrushPreview" width="80" height="80"></canvas>
    <div class="hint">White = full paint, black = no paint</div>
    </div>

    <button id="paintToggle">Activate Paint Mode</button>
    <button id="eyedropperToggle">Eyedropper Tool</button>
    <button id="maskToggle">Mask Mode (Paint Invisibility)</button>

    <div id="undoRedoGroup">
    <button id="undoBtn" disabled>Undo (Ctrl+Z)</button>
    <button id="redoBtn" disabled>Redo (Ctrl+Y)</button>
    </div>

    <button id="clearPaint" style="background:#ef4444;">Clear Current Layer</button>
    <button id="clearMask" style="background:#64748b; display:none;">Reset Global Mask</button>

    <h2>Lighting</h2>
    <div class="control-group">
    <label for="envPreset">Environment</label>
    <select id="envPreset">
    <option value="neutral">Neutral</option>
    <option value="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r182/examples/textures/equirect/royal_esplanade_1k.hdr">Royal Esplanade</option>
    <option value="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r182/examples/textures/equirect/spruit_sunrise_1k.hdr">Sunrise</option>
    <option value="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r182/examples/textures/equirect/moonless_golf_1k.hdr">Night</option>
    </select>
    </div>

    <h2>Export</h2>
    <button id="exportBtn">Export Modified GLB</button>
    <div id="exportStatus" style="margin-top:0.5rem;font-size:0.8rem;color:#94a3b8;"></div>
  </div>
</div>

<div id="mobilePanelToggle"><span>‚ñ≤ Controls</span></div>

<footer class="site-footer">
  <div class="footer-inner">
  <nav class="footer-nav">
  <a href="about.html">About</a>
  <a href="privacy.html">Privacy</a>
  <a href="terms.html">Terms</a>
  <a href="license.html">License</a>
  <a href="refund.html">Refund</a>
  <a href="rewards.html">Rewards</a>
  </nav>
  <p>¬© 2026 BowesProduct</p>
  </div>
</footer>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
  import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';

  const canvas = document.getElementById('canvas');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, preserveDrawingBuffer: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.toneMapping = THREE.NoToneMapping;
  renderer.outputColorSpace = THREE.SRGBColorSpace;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x020617);
  scene.add(new THREE.AmbientLight(0xffffff, 2.5));
  const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
  dirLight.position.set(5, 10, 7);
  scene.add(dirLight);

  const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
  camera.position.set(3, 2, 5);

  const controls = new OrbitControls(camera, canvas);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };

  const pmremGenerator = new THREE.PMREMGenerator(renderer);
  pmremGenerator.compileEquirectangularShader();
  let currentEnvMap = null;

  function loadEnvironment(url) {
    if (url === 'neutral') {
      scene.environment = null;
      if (currentEnvMap) currentEnvMap.dispose();
      return;
    }
    new RGBELoader().load(url, (tex) => {
      const envMap = pmremGenerator.fromEquirectangular(tex).texture;
      scene.environment = envMap;
      tex.dispose();
      if (currentEnvMap) currentEnvMap.dispose();
      currentEnvMap = envMap;
    });
  }
  loadEnvironment('neutral');

  let currentModel = null;
  let modelSize = 1;
  let paintedGeometries = [];
  let paintColor = new THREE.Color('#ff4444');
  let brushSize = 0.1;
  let brushShape = 'soft-circle';
  let paintModeActive = false;
  let eyedropperActive = false;
  let maskMode = false;

  const layers = [];
  let currentLayerIndex = 0;
  let layerData = {};
  let globalMaskData = {};

  const undoStack = [];
  const redoStack = [];
  const MAX_UNDO = 30;

  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');

  function saveState() {
    if (paintedGeometries.length === 0) return;
    const state = {
      layers: layers.map(l => ({ color: l.color.clone(), opacity: l.opacity, blendMode: l.blendMode, visible: l.visible, name: l.name })),
      layerData: JSON.parse(JSON.stringify(layerData)),
      globalMaskData: JSON.parse(JSON.stringify(globalMaskData))
    };
    undoStack.push(state);
    if (undoStack.length > MAX_UNDO) undoStack.shift();
    redoStack.length = 0;
    undoBtn.disabled = false;
    redoBtn.disabled = true;
  }

  function undo() {
    if (undoStack.length === 0) return;
    redoStack.push({
      layers: layers.map(l => ({ color: l.color.clone(), opacity: l.opacity, blendMode: l.blendMode, visible: l.visible, name: l.name })),
      layerData: JSON.parse(JSON.stringify(layerData)),
      globalMaskData: JSON.parse(JSON.stringify(globalMaskData))
    });
    const state = undoStack.pop();
    restoreState(state);
    undoBtn.disabled = undoStack.length === 0;
    redoBtn.disabled = false;
  }

  function redo() {
    if (redoStack.length === 0) return;
    undoStack.push({
      layers: layers.map(l => ({ color: l.color.clone(), opacity: l.opacity, blendMode: l.blendMode, visible: l.visible, name: l.name })),
      layerData: JSON.parse(JSON.stringify(layerData)),
      globalMaskData: JSON.parse(JSON.stringify(globalMaskData))
    });
    const state = redoStack.pop();
    restoreState(state);
    redoBtn.disabled = redoStack.length === 0;
    undoBtn.disabled = false;
  }

  function restoreState(state) {
    layers.length = 0;
    state.layers.forEach(ld => layers.push({ color: ld.color, opacity: ld.opacity, blendMode: ld.blendMode, visible: ld.visible, name: ld.name }));
    layerData = JSON.parse(JSON.stringify(state.layerData));

    const newMaskData = {};
    if (state.globalMaskData) {
      Object.keys(state.globalMaskData).forEach(key => {
        const old = state.globalMaskData[key];
        const arr = new Float32Array(old.length);
        arr.set(old);
        newMaskData[key] = arr;
      });
    }
    globalMaskData = newMaskData;

    updateLayersUI();
    updateAllGeometries();
  }

  undoBtn.onclick = undo;
  redoBtn.onclick = redo;
  window.addEventListener('keydown', e => {
    if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
    if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); }
  });

  const brushCursor = document.getElementById('brushCursor');
  const eyedropperCursor = document.getElementById('eyedropperCursor');
  const exportStatus = document.getElementById('exportStatus');
  const maskToggle = document.getElementById('maskToggle');
  const clearMaskBtn = document.getElementById('clearMask');
  const loader = document.getElementById('loader');

  const panel = document.getElementById('panel');
  const panelToggle = document.getElementById('panelToggle');
  const mobilePanelToggle = document.getElementById('mobilePanelToggle');
  let panelVisible = true;

  function togglePanel() {
    if (window.innerWidth > 900) return;

    panelVisible = !panelVisible;
    panel.classList.toggle('hidden', !panelVisible);
    panel.classList.toggle('visible', panelVisible);
    const span = mobilePanelToggle.querySelector('span');
    if(span) span.textContent = panelVisible ? '‚ñº Hide Controls' : '‚ñ≤ Controls';
    updateQuickControls();
  }

  panelToggle.onclick = togglePanel;
  mobilePanelToggle.onclick = (e) => {
    e.stopPropagation();
    togglePanel();
  };

  function updatePanelMode() {
    if (window.innerWidth <= 900) {
      mobilePanelToggle.style.display = 'flex';
      panelToggle.style.display = 'none';
    } else {
      mobilePanelToggle.style.display = 'none';
      panelToggle.style.display = 'flex';
      panel.classList.remove('hidden');
      panel.classList.add('visible');
    }
    updateQuickControls();
  }
  updatePanelMode();
  window.addEventListener('resize', updatePanelMode);

  canvas.addEventListener('touchstart', (e) => {
    if (window.innerWidth <= 900 && panelVisible && !paintModeActive && !maskMode && e.touches.length === 1) {
      const touch = e.touches[0];
      const target = document.elementFromPoint(touch.clientX, touch.clientY);
      if (target === canvas || target.id === 'container') {
        e.preventDefault();
        togglePanel();
      }
    }
  });

  function blendColor(base, overlay, mode, opacity) {
    const o = overlay.clone();
    switch (mode) {
      case 'multiply':
        return base.clone().multiplyScalar(1 - opacity).add(base.clone().multiply(o).multiplyScalar(opacity));
      case 'screen':
        return base.clone().lerp(new THREE.Color(1,1,1), 1 - (1 - base.r) * (1 - o.r) * opacity);
      case 'overlay':
        const r = base.r < 0.5 ? 2 * base.r * o.r : 1 - 2 * (1 - base.r) * (1 - o.r);
        const g = base.g < 0.5 ? 2 * base.g * o.g : 1 - 2 * (1 - base.g) * (1 - o.g);
        const b = base.b < 0.5 ? 2 * base.b * o.b : 1 - 2 * (1 - base.b) * (1 - o.b);
        return base.clone().multiplyScalar(1 - opacity).add(new THREE.Color(r, g, b).multiplyScalar(opacity));
      case 'add':
        return base.clone().add(o.multiplyScalar(opacity));
      default:
        return base.clone().lerp(o, opacity);
    }
  }

  function addLayer() {
    saveState();
    const layer = {
      name: `Layer ${layers.length + 1}`,
      color: new THREE.Color('#ff4444'),
      opacity: 1.0,
      visible: true,
      blendMode: 'normal'
    };
    layers.push(layer);
    paintedGeometries.forEach((pg, idx) => {
      const geoKey = `geo_${idx}`;
      if (!layerData[geoKey]) layerData[geoKey] = {};
      const colors = new Float32Array(pg.geometry.attributes.position.count * 3).fill(1);
      layerData[geoKey][layers.length - 1] = Array.from(colors);
    });
    updateLayersUI();
    setActiveLayer(layers.length - 1);
  }

  function setActiveLayer(idx) {
    currentLayerIndex = idx;
    updateLayersUI();
    paintColor.copy(layers[idx].color);
    const displayColor = paintColor.clone();
    document.getElementById('paintColor').value = '#' + displayColor.getHexString();
    updateQuickColorDisplay();
  }

  function updateLayersUI() {
    const list = document.getElementById('layersList');
    list.innerHTML = '';
    layers.slice().reverse().forEach((layer, reverseIdx) => {
      const i = layers.length - 1 - reverseIdx;
      const li = document.createElement('li');
      li.className = 'layer-item' + (i === currentLayerIndex ? ' active' : '');
      li.draggable = true;

      const displayColor = layer.color.clone();

      li.innerHTML = `
        <span class="layer-visibility">${layer.visible ? 'üëÅ' : 'üö´'}</span>
        <input type="color" class="layer-color" value="#${displayColor.getHexString()}">
        <input type="range" class="layer-opacity" min="0" max="100" value="${layer.opacity * 100}">
        <select class="layer-blend">
          <option value="normal">Normal</option>
          <option value="multiply">Multiply</option>
          <option value="screen">Screen</option>
          <option value="overlay">Overlay</option>
          <option value="add">Add</option>
        </select>
        <input class="layer-name" value="${layer.name}">
        <span class="layer-delete">√ó</span>
      `;

      li.querySelector('.layer-name').addEventListener('click', (e) => setActiveLayer(i));
      li.querySelector('.layer-visibility').onclick = (e) => {
        e.stopPropagation();
        layer.visible = !layer.visible;
        li.querySelector('.layer-visibility').textContent = layer.visible ? 'üëÅ' : 'üö´';
        updateAllGeometries();
      };

      li.querySelector('.layer-color').oninput = (e) => {
        e.stopPropagation();
        layer.color.set(e.target.value);
        if (i === currentLayerIndex) paintColor.copy(layer.color);
        updateAllGeometries();
        updateQuickColorDisplay();
      };

      li.querySelector('.layer-opacity').oninput = (e) => {
        e.stopPropagation();
        layer.opacity = e.target.value / 100;
        updateAllGeometries();
      };

      li.querySelector('.layer-blend').onchange = (e) => {
        e.stopPropagation();
        layer.blendMode = e.target.value;
        updateAllGeometries();
      };

      li.querySelector('.layer-delete').onclick = (e) => {
        e.stopPropagation();
        deleteLayer(i);
      };

      li.addEventListener('dragstart', (e) => e.dataTransfer.setData('text/plain', i));
      li.addEventListener('dragover', (e) => e.preventDefault());
      li.addEventListener('drop', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
        const toIdx = i;
        if (fromIdx !== toIdx && !isNaN(fromIdx)) moveLayer(fromIdx, toIdx);
      });

      list.appendChild(li);
    });
  }

  function updateAllGeometries() {
    paintedGeometries.forEach((pg, geoIdx) => {
      const col = pg.geometry.attributes.color;
      const geoKey = `geo_${geoIdx}`;
      const maskArr = globalMaskData[geoKey] || new Float32Array(col.count).fill(1.0);

      for (let i = 0; i < col.count; i++) {
        col.setXYZ(i, 1, 1, 1);
      }

      layers.forEach((layer, layerIdx) => {
        if (!layer.visible) return;
        const geoLayerData = layerData[geoKey]?.[layerIdx];
        if (!geoLayerData) return;

        for (let i = 0; i < col.count; i++) {
          const overlay = new THREE.Color(geoLayerData[i*3], geoLayerData[i*3+1], geoLayerData[i*3+2]);
          if (overlay.r !== 1 || overlay.g !== 1 || overlay.b !== 1) {
            const base = new THREE.Color(col.getX(i), col.getY(i), col.getZ(i));
            const result = blendColor(base, overlay, layer.blendMode, layer.opacity);
            col.setXYZ(i, result.r, result.g, result.b);
          }
        }
      });

      for (let i = 0; i < col.count; i++) {
        col.setXYZ(i, col.getX(i) * maskArr[i], col.getY(i) * maskArr[i], col.getZ(i) * maskArr[i]);
      }

      col.needsUpdate = true;
    });
  }

  document.getElementById('addLayerBtn').onclick = addLayer;
  addLayer();

  maskToggle.onclick = () => {
    maskMode = !maskMode;
    maskToggle.classList.toggle('active', maskMode);
    clearMaskBtn.style.display = maskMode ? 'block' : 'none';
    if (maskMode) {
      maskToggle.textContent = 'Exit Mask Mode';
      if (paintModeActive) {
        paintModeActive = false;
        document.getElementById('paintToggle').classList.remove('active');
        document.getElementById('paintToggle').textContent = 'Activate Paint Mode';
      }
    } else {
      maskToggle.textContent = 'Mask Mode (Paint Invisibility)';
    }
    controls.enabled = !paintModeActive && !maskMode;
    updateQuickControls();
  };

  clearMaskBtn.onclick = () => {
    saveState();
    Object.keys(globalMaskData).forEach(k => globalMaskData[k].fill(1.0));
    updateAllGeometries();
  };

  document.getElementById('brushOpacity').oninput = (e) => {
    document.getElementById('brushOpacityVal').textContent = e.target.value;
  };

  function sampleColor(x, y) {
    const rect = canvas.getBoundingClientRect();
    const gl = renderer.getContext();
    const pixel = new Uint8Array(4);
    const pixelX = Math.floor((x - rect.left) * renderer.getPixelRatio());
    const pixelY = Math.floor((rect.height - (y - rect.top)) * renderer.getPixelRatio());
    gl.readPixels(pixelX, pixelY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);

    const r = pixel[0] / 255;
    const g = pixel[1] / 255;
    const b = pixel[2] / 255;

    paintColor.setRGB(r, g, b);

    const displayColor = paintColor.clone();
    document.getElementById('paintColor').value = '#' + displayColor.getHexString();
    updateQuickColorDisplay();

    if (!maskMode) {
      layers[currentLayerIndex].color.copy(paintColor);
      updateLayersUI();
    }
  }

  function getWorldBrushRadius() {
    const dist = camera.position.distanceTo(controls.target);
    const fov = camera.fov * (Math.PI / 180);
    const visibleHeight = 2 * Math.tan(fov / 2) * dist;
    return brushSize * visibleHeight * 0.3;
  }

  function getBrushRadiusInPixels() {
    const worldRadius = getWorldBrushRadius();
    const dist = camera.position.distanceTo(controls.target);
    const fov = camera.fov * (Math.PI / 180);
    const visibleHeight = 2 * Math.tan(fov / 2) * dist;
    const pixelRadius = (worldRadius / visibleHeight) * window.innerHeight;
    return pixelRadius;
  }

  function updateBrushCursor(x, y) {
    if (!paintModeActive && !maskMode) return;
    brushCursor.style.display = 'block';
    if (maskMode) {
      brushCursor.style.borderColor = '#ec4899';
      brushCursor.style.backgroundColor = 'rgba(236, 72, 153, 0.1)';
    } else {
      brushCursor.style.borderColor = paintColor.getStyle();
      brushCursor.style.backgroundColor = `rgba(${paintColor.r*255}, ${paintColor.g*255}, ${paintColor.b*255}, 0.1)`;
    }
    brushCursor.style.left = x + 'px';
    brushCursor.style.top = y + 'px';
    const radiusPx = getBrushRadiusInPixels();
    const diameter = Math.max(radiusPx * 2, 10);
    brushCursor.style.width = diameter + 'px';
    brushCursor.style.height = diameter + 'px';
    if (brushShape === 'soft-circle') {
      const shadowColor = maskMode ? '#ec4899' : paintColor.getStyle();
      brushCursor.style.boxShadow = `0 0 ${diameter/2}px ${diameter/4}px ${shadowColor}`;
    } else {
      brushCursor.style.boxShadow = 'none';
    }
  }

  function hideCursors() {
    brushCursor.style.display = 'none';
    eyedropperCursor.style.display = 'none';
  }

  function paintAt(point) {
    if ((!paintModeActive && !maskMode) || paintedGeometries.length === 0) return;

    const brushOpacity = document.getElementById('brushOpacity').value / 100;
    const radius = getWorldBrushRadius();
    const radiusSq = radius * radius;
    const vert = new THREE.Vector3();

    paintedGeometries.forEach((pg, geoIdx) => {
      const pos = pg.geometry.attributes.position;
      const inv = new THREE.Matrix4().copy(pg.mesh.matrixWorld).invert();
      const local = point.clone().applyMatrix4(inv);
      const geoKey = `geo_${geoIdx}`;
      const maskArr = globalMaskData[geoKey] || new Float32Array(pos.count).fill(1.0);

      if (maskMode) {
        for (let i = 0; i < pos.count; i++) {
          vert.fromBufferAttribute(pos, i);
          const distSq = vert.distanceToSquared(local);
          if (distSq > radiusSq) continue;
          let falloff = 1 - Math.sqrt(distSq) / radius;
          if (brushShape === 'hard-circle') falloff = 1;
          if (brushShape === 'soft-circle') falloff = 1 - (falloff * falloff);
          const alpha = brushOpacity * falloff;
          maskArr[i] = maskArr[i] * (1 - alpha);
        }
      } else {
        if (!layerData[geoKey]) layerData[geoKey] = {};
        if (!layerData[geoKey][currentLayerIndex]) {
          const colors = new Float32Array(pos.count * 3).fill(1);
          layerData[geoKey][currentLayerIndex] = Array.from(colors);
        }
        const geoLayerColors = layerData[geoKey][currentLayerIndex];

        for (let i = 0; i < pos.count; i++) {
          if (maskArr[i] < 0.01) continue; // Block painting on masked areas

          vert.fromBufferAttribute(pos, i);
          const distSq = vert.distanceToSquared(local);
          if (distSq > radiusSq) continue;

          let falloff = 1 - Math.sqrt(distSq) / radius;
          if (brushShape === 'hard-circle') falloff = 1;
          if (brushShape === 'soft-circle') falloff = 1 - (falloff * falloff);

          const alpha = brushOpacity * falloff;
          const paintRGB = layers[currentLayerIndex].color;

          const current = new THREE.Color(geoLayerColors[i*3], geoLayerColors[i*3+1], geoLayerColors[i*3+2]);
          const result = blendColor(current, paintRGB, layers[currentLayerIndex].blendMode, alpha);

          geoLayerColors[i*3] = result.r;
          geoLayerColors[i*3+1] = result.g;
          geoLayerColors[i*3+2] = result.b;
        }
      }
    });

    updateAllGeometries();
  }

  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  let isPointerDown = false;

  canvas.addEventListener('pointermove', (e) => {
    if (paintModeActive || maskMode) updateBrushCursor(e.clientX, e.clientY);
    if (isPointerDown && (paintModeActive || maskMode) && currentModel && !eyedropperActive) {
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(currentModel, true);
      if (intersects.length > 0) paintAt(intersects[0].point);
    }
  });

  canvas.addEventListener('pointerdown', (e) => {
    isPointerDown = true;
    if (eyedropperActive) {
      sampleColor(e.clientX, e.clientY);
      return;
    }
    if ((paintModeActive || maskMode) && currentModel) {
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(currentModel, true);
      if (intersects.length > 0) paintAt(intersects[0].point);
    }
  });

  canvas.addEventListener('pointerup', () => {
    if (isPointerDown) {
      isPointerDown = false;
      saveState();
    }
  });

  canvas.addEventListener('pointerleave', () => { isPointerDown = false; hideCursors(); });

  window.addEventListener('keydown', (e) => {
    if (e.altKey && (paintModeActive || maskMode) && !eyedropperActive) {
      eyedropperActive = true;
      hideCursors();
      eyedropperCursor.style.display = 'block';
    }
  });

  window.addEventListener('keyup', (e) => {
    if (!e.altKey && eyedropperActive) {
      eyedropperActive = false;
      hideCursors();
    }
  });

  const quickControls = document.getElementById('quickControls');
  const quickPaint = document.getElementById('quickPaint');
  const quickEye = document.getElementById('quickEye');
  const quickColor = document.getElementById('quickColor');
  const quickColorDisplay = document.getElementById('quickColorDisplay');

  quickPaint.onclick = () => document.getElementById('paintToggle').click();
  quickEye.onclick = () => document.getElementById('eyedropperToggle').click();

  quickColor.oninput = (e) => {
    document.getElementById('paintColor').value = e.target.value;
    document.getElementById('paintColor').dispatchEvent(new Event('input'));
  };

  function updateQuickColorDisplay() {
    const displayColor = paintColor.clone();
    quickColorDisplay.style.background = displayColor.getStyle();
    quickColor.value = '#' + displayColor.getHexString();
  }

  function updateQuickControls() {
    const isMobile = window.innerWidth <= 900;
    quickControls.style.display = isMobile ? (panelVisible ? 'none' : 'flex') : 'flex';

    quickPaint.classList.toggle('active', paintModeActive);
    quickEye.classList.toggle('active', eyedropperActive);
    updateQuickColorDisplay();
  }

  document.getElementById('paintToggle').addEventListener('click', () => {
    paintModeActive = !paintModeActive;
    const btn = document.getElementById('paintToggle');
    btn.textContent = paintModeActive ? 'Deactivate Paint Mode' : 'Activate Paint Mode';
    btn.classList.toggle('active', paintModeActive);
    controls.enabled = !paintModeActive && !maskMode;
    if (maskMode && paintModeActive) maskToggle.click();
    eyedropperActive = false;
    document.getElementById('eyedropperToggle').classList.remove('active');
    document.getElementById('eyedropperToggle').textContent = 'Eyedropper Tool';
    if (!paintModeActive) hideCursors();
    else updateBrushCursor(window.innerWidth/2, window.innerHeight/2);
    updateQuickControls();
  });

  document.getElementById('eyedropperToggle').addEventListener('click', () => {
    eyedropperActive = !eyedropperActive;
    const btn = document.getElementById('eyedropperToggle');
    btn.textContent = eyedropperActive ? 'Cancel Eyedropper' : 'Eyedropper Tool';
    btn.classList.toggle('active', eyedropperActive);
    controls.enabled = !eyedropperActive;
    if (eyedropperActive) {
      paintModeActive = false;
      maskMode = false;
      document.getElementById('paintToggle').classList.remove('active');
      document.getElementById('paintToggle').textContent = 'Activate Paint Mode';
      document.getElementById('maskToggle').classList.remove('active');
      document.getElementById('maskToggle').textContent = 'Mask Mode (Paint Invisibility)';
      hideCursors();
    }
    updateQuickControls();
  });

  // Initial quick controls update
  updateQuickControls();

  // ... (upload, loadModel, texture, sliders, export, resize, animate, drag/drop ‚Äî same as stable)

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();
</script>
</body>
</html>
