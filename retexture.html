<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Retexture Pro – BowesProduct (Three.js)</title>

  <style>
    *, *::before, *::after { box-sizing: border-box; }
    html, body { margin: 0; height: 100%; background: #020617; color: white; font-family: system-ui, sans-serif; overflow: hidden; }
    #container { position: relative; width: 100%; height: 100%; }
    #canvas { display: block; width: 100%; height: 100%; }
    
    .panel {
      position: absolute;
      top: 20px; right: 20px;
      width: 320px; max-height: 90vh;
      background: rgba(2, 6, 23, 0.95);
      border: 1px solid #1e293b;
      border-radius: 12px;
      padding: 1.5rem;
      overflow-y: auto;
      z-index: 10;
      backdrop-filter: blur(10px);
    }
    .panel h2 { color: #60a5fa; margin-top: 0; margin-bottom: 1rem; font-size: 1.1rem; }
    .control-group { margin-bottom: 1.2rem; }
    label { display: block; font-size: 0.9rem; color: #e5e7eb; margin-bottom: 0.4rem; }
    input, select, button {
      width: 100%; padding: 0.5rem;
      border-radius: 0.375rem; border: 1px solid #1f2937;
      background: #020617; color: #e5e7eb;
      font: inherit;
    }
    input[type="range"] { padding: 0.3rem 0; }
    input[type="color"] { height: 44px; padding: 0.2rem; }
    button { background: #60a5fa; border: none; color: white; cursor: pointer; margin-top: 0.8rem; font-weight: 600; }
    button:hover { background: #3b82f6; }
    .hint { font-size: 0.8rem; color: #9ca3af; margin-top: 0.3rem; }
    #brushSize { width: 100%; }
    #status { position: absolute; bottom: 20px; left: 20px; font-size: 0.9rem; color: #94a3b8; }

    @media (max-width: 900px) {
      .panel { width: 100%; right: 0; left: 0; top: auto; bottom: 0; border-radius: 12px 12px 0 0; max-height: 60vh; }
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="canvas"></canvas>
    <div id="status">Drag to rotate • Click/drag to paint • Scroll to zoom</div>

    <div class="panel">
      <h2>Model</h2>
      <div class="control-group">
        <label>Upload GLB (FBX → GLB first)</label>
        <input type="file" id="uploadModel" accept=".glb,.gltf" />
        <div class="hint">Convert FBX to GLB in Blender or online tools.</div>
      </div>

      <h2>Texture</h2>
      <div class="control-group">
        <label>Preset Textures</label>
        <select id="presetTexture">
          <option value="">Original / None</option>
          <option value="textures/wood_basecolor.jpg">Warm Wood</option>
          <option value="textures/metal_basecolor.jpg">Brushed Metal</option>
          <option value="textures/plastic_basecolor.jpg">Matte Plastic</option>
          <option value="textures/fabric_basecolor.jpg">Fabric</option>
        </select>
      </div>
      <div class="control-group">
        <label>Custom Texture</label>
        <input type="file" id="uploadTexture" accept="image/*" />
      </div>

      <h2>Material</h2>
      <div class="control-group">
        <label>Metallic <span id="metallicVal">0.0</span></label>
        <input type="range" id="metallicSlider" min="0" max="1" step="0.01" value="0" />
      </div>
      <div class="control-group">
        <label>Roughness <span id="roughnessVal">0.5</span></label>
        <input type="range" id="roughnessSlider" min="0" max="1" step="0.01" value="0.5" />
      </div>

      <h2>Vertex Color Painting</h2>
      <div class="control-group">
        <label>Brush Color</label>
        <input type="color" id="paintColor" value="#ff4444" />
      </div>
      <div class="control-group">
        <label>Brush Size <span id="brushSizeVal">10</span></label>
        <input type="range" id="brushSize" min="1" max="50" value="10" />
      </div>
      <button id="clearPaint">Clear All Paint</button>

      <h2>Lighting</h2>
      <div class="control-group">
        <label>Environment</label>
        <select id="envPreset">
          <option value="neutral">Neutral</option>
          <option value="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r160/examples/textures/equirectangular/royal_esplanade_1k.hdr">Royal Esplanade</option>
          <option value="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r160/examples/textures/equirectangular/spruit_sunrise_1k.hdr">Sunrise</option>
          <option value="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r160/examples/textures/equirectangular/moonless_golf_1k.hdr">Night</option>
        </select>
      </div>

      <h2>Export</h2>
      <button id="exportBtn">Export Modified GLB</button>
    </div>
  </div>

  <div style="position:absolute;bottom:8px;right:8px;font-size:0.7rem;color:#64748b;">
    Powered by Three.js (MIT License) • Model viewer &amp; painting by Grok @ xAI
  </div>

  <!-- Single module script with CDN imports; no bare "three" specifier -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
    import { RGBELoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/RGBELoader.js';
    import { GLTFExporter } from 'https://unpkg.com/three@0.160.0/examples/jsm/exporters/GLTFExporter.js';

    // Scene setup
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020617);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(3, 2, 5);

    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Lighting / environment
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();

    let currentEnvMap = null;
    function loadEnvironment(url) {
      if (url === 'neutral') {
        scene.environment = null;
        scene.background = new THREE.Color(0x020617);
        if (currentEnvMap) {
          currentEnvMap.dispose();
          currentEnvMap = null;
        }
        return;
      }
      new RGBELoader().load(
        url,
        (texture) => {
          const envMap = pmremGenerator.fromEquirectangular(texture).texture;
          scene.environment = envMap;
          scene.background = envMap;
          texture.dispose();
          if (currentEnvMap && currentEnvMap !== envMap) currentEnvMap.dispose();
          currentEnvMap = envMap;
        },
        undefined,
        (err) => console.error('Error loading HDR:', err)
      );
    }
    loadEnvironment('neutral');

    // Model handling
    let currentModel = null;
    let paintedGeometry = null;
    let paintColor = new THREE.Color('#ff4444');
    let brushSize = 10;

    const loader = new GLTFLoader();

    function loadModel(url) {
      loader.load(
        url,
        (gltf) => {
          if (currentModel) scene.remove(currentModel);
          currentModel = gltf.scene;
          scene.add(currentModel);

          currentModel.traverse((child) => {
            if (child.isMesh) {
              child.material.vertexColors = true;
              if (!child.geometry.attributes.color) {
                const colors = new Float32Array(child.geometry.attributes.position.count * 3);
                colors.fill(1); // white
                child.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
              }
              paintedGeometry = child.geometry; // paint first mesh
            }
          });

          const box = new THREE.Box3().setFromObject(currentModel);
          const center = box.getCenter(new THREE.Vector3());
          const size = box.getSize(new THREE.Vector3());
          const maxDim = Math.max(size.x, size.y, size.z);
          camera.position.copy(center).add(new THREE.Vector3(maxDim, maxDim * 0.7, maxDim));
          controls.target.copy(center);
          controls.update();
        },
        undefined,
        (error) => {
          console.error('Error loading model:', error);
        }
      );
    }

    // Optional default model; comment out if you do not have this file
    // loadModel('models/example.glb');

    // Painting
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let isPainting = false;

    function paintAt(point, normal) {
      if (!paintedGeometry || !currentModel) return;
      const positions = paintedGeometry.attributes.position;
      const colors = paintedGeometry.attributes.color;
      const brushSq = brushSize * brushSize;

      const worldMatrix = currentModel.matrixWorld;
      const vert = new THREE.Vector3();

      for (let i = 0; i < positions.count; i++) {
        vert.set(positions.getX(i), positions.getY(i), positions.getZ(i)).applyMatrix4(worldMatrix);
        const distSq = point.distanceToSquared(vert);
        if (distSq < brushSq) {
          const influence = 1 - Math.sqrt(distSq) / brushSize;
          colors.setXYZ(
            i,
            THREE.MathUtils.lerp(colors.getX(i), paintColor.r, influence),
            THREE.MathUtils.lerp(colors.getY(i), paintColor.g, influence),
            THREE.MathUtils.lerp(colors.getZ(i), paintColor.b, influence)
          );
        }
      }
      colors.needsUpdate = true;
    }

    function onPointerMove(event) {
      if (!isPainting || !currentModel) return;
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(currentModel, true);
      if (intersects.length > 0) {
        paintAt(intersects[0].point, intersects[0].face.normal);
      }
    }

    canvas.addEventListener('pointerdown', (e) => {
      isPainting = true;
      onPointerMove(e);
    });
    canvas.addEventListener('pointerup', () => {
      isPainting = false;
    });
    canvas.addEventListener('pointerleave', () => {
      isPainting = false;
    });
    canvas.addEventListener('pointermove', onPointerMove);

    // UI controls
    document.getElementById('uploadModel').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const url = URL.createObjectURL(file);
      loadModel(url);
      // optional: revoke later
      setTimeout(() => URL.revokeObjectURL(url), 30000);
    });

    function applyTexture(url) {
      if (!currentModel) return;
      const texLoader = new THREE.TextureLoader();
      texLoader.load(
        url,
        (tex) => {
          tex.flipY = false;
          tex.colorSpace = THREE.SRGBColorSpace;
          currentModel.traverse((child) => {
            if (child.isMesh && child.material) {
              child.material.map = tex;
              child.material.needsUpdate = true;
            }
          });
        },
        undefined,
        (err) => console.error('Error loading texture:', err)
      );
    }

    document.getElementById('presetTexture').addEventListener('change', (e) => {
      const url = e.target.value;
      if (url) applyTexture(url);
    });

    document.getElementById('uploadTexture').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const url = URL.createObjectURL(file);
      applyTexture(url);
      setTimeout(() => URL.revokeObjectURL(url), 30000);
    });

    document.getElementById('metallicSlider').addEventListener('input', (e) => {
      const v = parseFloat(e.target.value);
      document.getElementById('metallicVal').textContent = v.toFixed(2);
      if (!currentModel) return;
      currentModel.traverse((child) => {
        if (child.isMesh && child.material && 'metalness' in child.material) {
          child.material.metalness = v;
        }
      });
    });

    document.getElementById('roughnessSlider').addEventListener('input', (e) => {
      const v = parseFloat(e.target.value);
      document.getElementById('roughnessVal').textContent = v.toFixed(2);
      if (!currentModel) return;
      currentModel.traverse((child) => {
        if (child.isMesh && child.material && 'roughness' in child.material) {
          child.material.roughness = v;
        }
      });
    });

    document.getElementById('paintColor').addEventListener('input', (e) => {
      paintColor.set(e.target.value);
    });

    document.getElementById('brushSize').addEventListener('input', (e) => {
      brushSize = parseFloat(e.target.value);
      document.getElementById('brushSizeVal').textContent = brushSize;
    });

    document.getElementById('clearPaint').addEventListener('click', () => {
      if (!paintedGeometry) return;
      const colors = paintedGeometry.attributes.color;
      for (let i = 0; i < colors.count; i++) {
        colors.setXYZ(i, 1, 1, 1);
      }
      colors.needsUpdate = true;
    });

    document.getElementById('envPreset').addEventListener('change', (e) => {
      loadEnvironment(e.target.value);
    });

    document.getElementById('exportBtn').addEventListener('click', () => {
      if (!currentModel) return;
      const exporter = new GLTFExporter();
      exporter.parse(
        currentModel,
        (glb) => {
          const blob = new Blob([glb], { type: 'application/octet-stream' });
          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = 'retextured_model.glb';
          link.click();
          setTimeout(() => URL.revokeObjectURL(link.href), 30000);
        },
        { binary: true }
      );
    });

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
