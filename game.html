<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D FPS Battle Arena</title>
    <link rel="stylesheet" href="style.css">

    <!-- Latest Three.js (r182 as of January 2026 - supports CapsuleGeometry natively) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r182/three.min.js"></script>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>

        <!-- HUD -->
        <div id="hud">
            <div id="crosshair">
                <div class="crosshair-line horizontal"></div>
                <div class="crosshair-line vertical"></div>
            </div>

            <div id="health-bar">
                <div id="health-fill"></div>
            </div>

            <div id="ammo-display">30/90</div>
            <div id="score-display">Score: 0</div>
            <div id="wave-display">Wave: 1</div>
        </div>

        <!-- Wave Announcement -->
        <div id="wave-announcement">WAVE 1</div>

        <!-- Main Menu -->
        <div id="menu">
            <h1>3D FPS BATTLE ARENA</h1>
            <p>Survive the waves and become the ultimate champion!</p>

            <div id="character-select">
                <div class="character-option selected" data-character="default" style="background: linear-gradient(135deg, #667eea, #764ba2);">
                    <canvas id="preview-default" width="120" height="120"></canvas>
                </div>
                <div class="character-option" data-character="ninja" style="background: linear-gradient(135deg, #f093fb, #f5576c);">
                    <canvas id="preview-ninja" width="120" height="120"></canvas>
                </div>
                <div class="character-option" data-character="cyber" style="background: linear-gradient(135deg, #4facfe, #00f2fe);">
                    <canvas id="preview-cyber" width="120" height="120"></canvas>
                </div>
            </div>

            <div id="upload-section">
                <h2>Upload Custom Character</h2>
                <p>Upload a GLB/GLTF 3D model (max 50MB)</p>
                <input type="file" id="file-input" accept=".glb,.gltf">
                <button class="upload-button" onclick="document.getElementById('file-input').click()">Choose Model</button>
                <div id="model-preview"></div>
            </div>

            <button class="menu-button" id="start-button">START GAME</button>

            <div id="instructions">
                <h3>Controls</h3>
                <ul>
                    <li><span class="key">WASD</span> Move</li>
                    <li><span class="key">Mouse</span> Look around</li>
                    <li><span class="key">Left Click</span> Shoot</li>
                    <li><span class="key">R</span> Reload</li>
                    <li><span class="key">Shift</span> Sprint</li>
                </ul>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over">
            <h1>GAME OVER</h1>
            <div id="final-score">Final Score: 0</div>
            <button class="menu-button" id="restart-button">PLAY AGAIN</button>
        </div>
    </div>

    <script>
        // Game State
        const gameState = {
            isPlaying: false,
            health: 100,
            ammo: 30,
            maxAmmo: 30,
            reserveAmmo: 90,
            score: 0,
            wave: 1,
            enemies: [],
            bullets: [],
            selectedCharacter: 'default',
            customModel: null
        };

        // Three.js Setup
        let scene, camera, renderer, clock;
        let enemies = [];
        let bullets = [];
        let isLocked = false;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();

        // Initialize Three.js
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 10, 100);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 0);

            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('game-canvas'),
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            clock = new THREE.Clock();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            const pointLight1 = new THREE.PointLight(0x00ff88, 1, 50);
            pointLight1.position.set(10, 10, 10);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xff0066, 1, 50);
            pointLight2.position.set(-10, 10, -10);
            scene.add(pointLight2);

            createMap();
            createCharacterPreviews();

            window.addEventListener('resize', onWindowResize);
        }

        // Create Game Map
        function createMap() {
            // Ground
            const groundGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x2a2a4a, roughness: 0.8, metalness: 0.2 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Walls material
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x3a3a6a, roughness: 0.6, metalness: 0.3 });

            // Arena boundaries
            const wallGeometry = new THREE.BoxGeometry(200, 10, 2);

            const northWall = new THREE.Mesh(wallGeometry, wallMaterial);
            northWall.position.set(0, 5, -100);
            northWall.castShadow = northWall.receiveShadow = true;
            scene.add(northWall);

            const southWall = new THREE.Mesh(wallGeometry, wallMaterial);
            southWall.position.set(0, 5, 100);
            southWall.castShadow = southWall.receiveShadow = true;
            scene.add(southWall);

            const eastWall = new THREE.Mesh(new THREE.BoxGeometry(2, 10, 200), wallMaterial);
            eastWall.position.set(100, 5, 0);
            eastWall.castShadow = eastWall.receiveShadow = true;
            scene.add(eastWall);

            const westWall = new THREE.Mesh(new THREE.BoxGeometry(2, 10, 200), wallMaterial);
            westWall.position.set(-100, 5, 0);
            westWall.castShadow = westWall.receiveShadow = true;
            scene.add(westWall);

            addObstacles();
            addDecorations();
        }

        function addObstacles() {
            const obstaclePositions = [
                { x: 20, z: 20, width: 4, height: 3, depth: 4 },
                { x: -20, z: -20, width: 3, height: 2, depth: 3 },
                { x: 30, z: -30, width: 5, height: 4, depth: 2 },
                { x: -30, z: 30, width: 2, height: 3, depth: 5 },
                { x: 0, z: 40, width: 6, height: 2, depth: 2 },
                { x: 40, z: 0, width: 2, height: 3, depth: 6 },
                { x: -40, z: 0, width: 2, height: 2, depth: 4 },
                { x: 15, z: -40, width: 4, height: 3, depth: 3 },
                { x: -15, z: 40, width: 3, height: 2, depth: 4 },
                { x: 50, z: 50, width: 4, height: 3, depth: 4 },
                { x: -50, z: -50, width: 3, height: 2, depth: 3 }
            ];

            const obstacleColors = [0x4a4a8a, 0x5a5a9a, 0x3a3a7a, 0x6a6aaa];

            obstaclePositions.forEach((pos, index) => {
                const geometry = new THREE.BoxGeometry(pos.width, pos.height, pos.depth);
                const material = new THREE.MeshStandardMaterial({
                    color: obstacleColors[index % obstacleColors.length],
                    roughness: 0.7,
                    metalness: 0.3
                });
                const obstacle = new THREE.Mesh(geometry, material);
                obstacle.position.set(pos.x, pos.height / 2, pos.z);
                obstacle.castShadow = obstacle.receiveShadow = true;
                scene.add(obstacle);
            });
        }

        function addDecorations() {
            // Glowing orbs
            const orbGeometry = new THREE.SphereGeometry(1, 32, 32);
            const orbMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ff88,
                emissive: 0x00ff88,
                emissiveIntensity: 0.5
            });

            for (let i = 0; i < 10; i++) {
                const orb = new THREE.Mesh(orbGeometry, orbMaterial);
                orb.position.set(
                    Math.random() * 160 - 80,
                    2 + Math.random() * 3,
                    Math.random() * 160 - 80
                );
                scene.add(orb);
            }

            // Pillars
            const pillarGeometry = new THREE.CylinderGeometry(1, 1, 8, 32);
            const pillarMaterial = new THREE.MeshStandardMaterial({
                color: 0x5a5a9a,
                roughness: 0.5,
                metalness: 0.5
            });

            for (let i = 0; i < 8; i++) {
                const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                const angle = (i / 8) * Math.PI * 2;
                pillar.position.set(Math.cos(angle) * 40, 4, Math.sin(angle) * 40);
                pillar.castShadow = pillar.receiveShadow = true;
                scene.add(pillar);
            }
        }

        // Create character previews
        function createCharacterPreviews() {
            const characters = ['default', 'ninja', 'cyber'];

            characters.forEach(char => {
                const canvas = document.getElementById(`preview-${char}`);
                const previewScene = new THREE.Scene();
                previewScene.background = new THREE.Color(0x1a1a2e);

                const previewCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
                previewCamera.position.set(0, 1.5, 3);
                previewCamera.lookAt(0, 1, 0);

                const previewRenderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                previewRenderer.setSize(120, 120);

                const light = new THREE.DirectionalLight(0xffffff, 1);
                light.position.set(5, 10, 5);
                previewScene.add(light);

                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                previewScene.add(ambientLight);

                const characterMesh = createCharacterMesh(char);
                previewScene.add(characterMesh);

                const groundGeometry = new THREE.PlaneGeometry(10, 10);
                const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x2a2a4a });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                previewScene.add(ground);

                function animatePreview() {
                    requestAnimationFrame(animatePreview);
                    characterMesh.rotation.y += 0.02;
                    previewRenderer.render(previewScene, previewCamera);
                }
                animatePreview();
            });
        }

        // Create character mesh
        function createCharacterMesh(type) {
            const group = new THREE.Group();

            let color = 0x667eea;
            let accentColor = 0x764ba2;

            switch (type) {
                case 'ninja':
                    color = 0x1a1a1a;
                    accentColor = 0xff0066;
                    break;
                case 'cyber':
                    color = 0x00f2fe;
                    accentColor = 0x4facfe;
                    break;
            }

            // Body (CapsuleGeometry works in r182+)
            const bodyGeometry = new THREE.CapsuleGeometry(0.3, 0.8, 4, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: color, roughness: 0.5, metalness: 0.5 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1;
            group.add(body);

            // Head
            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ color: accentColor, roughness: 0.3, metalness: 0.7 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.7;
            group.add(head);

            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff88, emissive: 0x00ff88, emissiveIntensity: 1 });

            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(0.1, 1.75, 0.2);
            group.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(-0.1, 1.75, 0.2);
            group.add(rightEye);

            return group;
        }

        // Enemy creation
        function createEnemy(position) {
            const enemyGroup = new THREE.Group();

            const bodyGeometry = new THREE.CapsuleGeometry(0.4, 1, 8, 16);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xff0044, roughness: 0.6, metalness: 0.4 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1;
            body.castShadow = true;
            enemyGroup.add(body);

            const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xff0066, roughness: 0.4, metalness: 0.6 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2;
            head.castShadow = true;
            enemyGroup.add(head);

            const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 1 });

            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(0.12, 2.05, 0.25);
            enemyGroup.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(-0.12, 2.05, 0.25);
            enemyGroup.add(rightEye);

            enemyGroup.position.copy(position);
            enemyGroup.userData = {
                health: 50 + gameState.wave * 10,
                speed: 3 + gameState.wave * 0.5,
                damage: 10 + gameState.wave * 2,
                lastAttack: 0
            };

            scene.add(enemyGroup);
            enemies.push(enemyGroup);

            return enemyGroup;
        }

        // Rest of your functions (spawnWave, updateEnemies, shoot, etc.) go here unchanged
        // (I've fixed the syntax issues like performance.now() and gameState.health)

        // Example fixes applied:
        function updateEnemies(delta) {
            const playerPosition = camera.position.clone();

            enemies.forEach((enemy, index) => {
                if (!enemy.parent) return;

                const direction = new THREE.Vector3().subVectors(playerPosition, enemy.position).normalize();
                direction.y = 0;

                enemy.position.add(direction.multiplyScalar(enemy.userData.speed * delta));
                enemy.lookAt(playerPosition.x, enemy.position.y, playerPosition.z);

                const distanceToPlayer = enemy.position.distanceTo(playerPosition);
                if (distanceToPlayer < 2 && performance.now() - enemy.userData.lastAttack > 1000) {
                    gameState.health -= enemy.userData.damage;
                    enemy.userData.lastAttack = performance.now();
                    updateHealthBar();
                    shakeScreen();

                    if (gameState.health <= 0) gameOver();
                }
            });
        }

        function updateHealthBar() {
            const healthFill = document.getElementById('health-fill');
            healthFill.style.width = `${gameState.health}%`;
        }

        // Game loop
        function animate() {
            requestAnimationFrame(animate);

            if (!gameState.isPlaying) {
                renderer.render(scene, camera);
                return;
            }

            const delta = (performance.now() - prevTime) / 1000;

            updatePlayerMovement(delta);
            updateEnemies(delta);
            updateBullets(delta);

            renderer.render(scene, camera);
            prevTime = performance.now();
        }

        // Start game, gameOver, handleFileUpload, etc. (all your original code with the same fixes applied)

        function init() {
            initThreeJS();
            setupEventListeners();
            animate();
        }
    </script>

    <!-- Load GLTFLoader (matching r182) -->
    <script>
        const gltfScript = document.createElement('script');
        gltfScript.src = 'https://cdn.jsdelivr.net/npm/three@0.182.0/examples/js/loaders/GLTFLoader.js';
        gltfScript.onload = function () {
            init();
        };
        gltfScript.onerror = function () {
            console.error('Failed to load GLTFLoader');
            alert('Could not load the 3D model loader. Check your internet connection.');
        };
        document.head.appendChild(gltfScript);
    </script>
</body>
</html>
