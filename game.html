<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>BowesProduct - Tactical Breach</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
*, *::before, *::after { box-sizing: border-box; }
html, body {
  margin: 0;
  background: #020617;
  color: white;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
  overflow-x: hidden;
  height: 100%;
}
canvas { display: block; }
#blocker {
  position: absolute;
  width: 100%;
  height: 100%;
  background-color: rgba(0,0,0,0.5);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}
#instructions {
  width: 80%;
  max-width: 600px;
  background: rgba(2,6,23,0.95);
  padding: 2rem;
  border-radius: 12px;
  border: 1px solid #60a5fa;
  text-align: center;
}
#instructions h1 { color: #60a5fa; }
#instructions ul { text-align: left; color: #cbd5e1; line-height: 1.8; }
/* ================= HEADER ================= */
.site-header {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  z-index: 1000;
  background: rgba(2,6,23,0.95);
  border-bottom: 1px solid #1e293b;
}
.header-inner {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0.6rem 1rem;
  display: flex;
  align-items: center;
  justify-content: space-between;
}
/* LEFT */
.header-left {
  display: flex;
  align-items: center;
  gap: 1.6rem;
}
.logo a {
  font-size: 1.3rem;
  font-weight: 700;
  color: white;
  text-decoration: none;
  white-space: nowrap;
}
.main-nav {
  display: flex;
  gap: 1.4rem;
}
.main-nav a {
  color: #e5e7eb;
  text-decoration: none;
  font-size: 0.95rem;
}
.main-nav a:hover { color:#60a5fa; }
/* RIGHT */
.header-right {
  display: flex;
  align-items: center;
  gap: 0.8rem;
  min-height: 44px;
}
#profilePic {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  border: 2px solid #60a5fa;
  object-fit: cover;
  display: none;
}
.login-btn {
  padding: 0.45rem 1.1rem;
  border-radius: 999px;
  border: 1.5px solid #60a5fa;
  background: transparent;
  color: #60a5fa;
  font-size: 0.95rem;
  cursor: pointer;
}
#levelInfo {
  display: none;
  width: 140px;
  font-size: 0.8rem;
  color: #cbd5e1;
}
#levelText {
  white-space: nowrap;
}
#xpOuter {
  width: 100%;
  height: 5px;
  background: #1e293b;
  border-radius: 3px;
  margin-top: 4px;
}
#xpBar {
  height: 100%;
  width: 0%;
  background: #60a5fa;
  border-radius: 3px;
  transition: width 0.35s ease;
}
/* HUD */
#hud {
  position: absolute;
  bottom: 20px;
  left: 20px;
  color: #60a5fa;
  font-size: 1.2rem;
  z-index: 10;
  pointer-events: none;
}
#crosshair {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 20px;
  height: 20px;
  margin-top: -10px;
  margin-left: -10px;
  color: #60a5fa;
  font-size: 24px;
  pointer-events: none;
}
#minimap {
  position: absolute;
  top: 20px;
  right: 20px;
  width: 200px;
  height: 200px;
  border: 2px solid #60a5fa;
  border-radius: 8px;
  pointer-events: none;
  z-index: 10;
}
</style>
</head>
<body>
<!-- HEADER -->
<header class="site-header">
  <div class="header-inner">
    <div class="header-left">
      <div class="logo"><a href="about.html">BowesProduct</a></div>
      <nav class="main-nav">
        <a href="index.html">Home</a>
        <a href="models.html">Models</a>
        <a href="retexture.html">Retexture</a>
      </nav>
    </div>
    <div class="header-right">
      <img id="profilePic" alt="Profile">
      <div id="levelInfo">
        <div id="levelText"></div>
        <div id="xpOuter"><div id="xpBar"></div></div>
      </div>
      <button id="authBtn" class="login-btn">Login</button>
    </div>
  </div>
</header>

<div id="blocker">
  <div id="instructions">
    <h1>Click to Breach</h1>
    <p>Objective: Plant the bomb (hold F at site) or eliminate all defenders.</p>
    <ul>
      <li>WASD - Move</li>
      <li>Mouse - Aim / Shoot (left click)</li>
      <li>Space - Jump</li>
      <li>Shift - Crouch</li>
      <li>Q/E - Lean</li>
      <li>G - Throw grenade</li>
      <li>F - Plant bomb (at site)</li>
      <li>R - Flashlight</li>
    </ul>
    <p>ESC to unlock mouse.</p>
  </div>
</div>

<div id="hud">
  Health: <span id="health">100</span> | Ammo: <span id="ammo">30 / 120</span> | Lives: <span id="lives">3</span>
</div>
<div id="crosshair">+</div>
<canvas id="minimap"></canvas>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js';
import { PointerLockControls } from 'https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/controls/PointerLockControls.js';
import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/postprocessing/UnrealBloomPass.js';

// Firebase
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js";
import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-auth.js";
import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB4JMVBMcWcN2wKsaVYmnggHH5ue1mUfaA",
  authDomain: "bowesproduct.firebaseapp.com",
  projectId: "bowesproduct"
};
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const provider = new GoogleAuthProvider();

const authBtn = document.getElementById("authBtn");
const profilePic = document.getElementById("profilePic");
const levelInfo = document.getElementById("levelInfo");
const levelText = document.getElementById("levelText");
const xpBar = document.getElementById("xpBar");

authBtn.onclick = () => auth.currentUser ? signOut(auth) : signInWithPopup(auth, provider);

onAuthStateChanged(auth, async (user) => {
  if (!user) {
    authBtn.textContent = "Login";
    profilePic.style.display = "none";
    levelInfo.style.display = "none";
    return;
  }
  authBtn.textContent = "Logout";
  profilePic.src = user.photoURL || "";
  profilePic.style.display = "block";
  const ref = doc(db, "users", user.uid);
  let snap = await getDoc(ref);
  if (!snap.exists()) {
    await setDoc(ref, { xp: 10 });
    snap = await getDoc(ref);
  }
  const xp = snap.data().xp || 0;
  const levels = [0, 200, 500, 1000, 2000];
  let level = levels.filter(v => xp >= v).length - 1;
  let next = levels[level + 1] ?? levels[level];
  let progress = next === levels[level] ? 100 : ((xp - levels[level]) / (next - levels[level])) * 100;
  levelText.textContent = `Level ${level} â€¢ ${xp} XP`;
  xpBar.style.width = progress + "%";
  levelInfo.style.display = "block";
});

// Game
const blocker = document.getElementById('blocker');
const instructions = document.getElementById('instructions');

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

const composer = new EffectComposer(renderer);
const renderPass = new RenderPass(scene, camera); // scene/camera defined later
composer.addPass(renderPass);
const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.4, 0.85);
composer.addPass(bloomPass);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x020617);
scene.fog = new THREE.FogExp2(0x020617, 0.002);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 1.6, 10);

const controls = new PointerLockControls(camera, document.body);

instructions.addEventListener('click', () => controls.lock());
controls.addEventListener('lock', () => blocker.style.display = 'none');
controls.addEventListener('unlock', () => blocker.style.display = '');

scene.add(controls.getObject());

const clock = new THREE.Clock();

// Lighting
const hemiLight = new THREE.HemisphereLight(0x60a5fa, 0x020617, 0.5);
scene.add(hemiLight);

const spotLight = new THREE.SpotLight(0xffffff, 10, 30, Math.PI / 8, 0.5);
spotLight.position.set(0, 5, 0);
spotLight.castShadow = true;
scene.add(spotLight);
spotLight.target = controls.getObject();
spotLight.visible = false;

// Flashlight
document.addEventListener('keydown', (e) => {
  if (e.key === 'r') spotLight.visible = !spotLight.visible;
});

// Map - compact house
const floorGeo = new THREE.BoxGeometry(20, 0.2, 30);
const wallMat = new THREE.MeshStandardMaterial({ color: 0x4b5563 });
const floorMat = new THREE.MeshStandardMaterial({ color: 0x1e293b });

const floor = new THREE.Mesh(floorGeo, floorMat);
floor.position.y = -0.1;
floor.receiveShadow = true;
scene.add(floor);

// Walls
const walls = [];
function createWall(x, y, z, rx, ry, rz, sx, sy, sz) {
  const geo = new THREE.BoxGeometry(sx, sy, sz);
  const mesh = new THREE.Mesh(geo, wallMat);
  mesh.position.set(x, y, z);
  mesh.rotation.set(rx, ry, rz);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  scene.add(mesh);
  walls.push(mesh);
}

// Outer walls
createWall(0, 5, -15, 0, 0, 0, 20, 10, 0.5); // back
createWall(0, 5, 15, 0, 0, 0, 20, 10, 0.5); // front (with door)
createWall(-10, 5, 0, 0, Math.PI/2, 0, 30, 10, 0.5); // left
createWall(10, 5, 0, 0, Math.PI/2, 0, 30, 10, 0.5); // right

// Door opening
const door = new THREE.Mesh(new THREE.BoxGeometry(4, 8, 0.5), wallMat);
door.position.set(0, 4, 15);
scene.add(door);

// Internal walls/hallways
createWall(0, 5, 0, 0, 0, 0, 20, 10, 0.5); // middle horizontal
createWall(0, 5, 5, 0, Math.PI/2, 0, 10, 10, 0.5); // vertical divider

// Stairs (simple boxes)
for (let i = 0; i < 8; i++) {
  const step = new THREE.Mesh(new THREE.BoxGeometry(4, 0.5, 1), wallMat);
  step.position.set(-6, i*0.5 + 0.25, -10 + i);
  scene.add(step);
}

// Cover objects
const coverGeo = new THREE.BoxGeometry(2, 2, 2);
const coverMat = new THREE.MeshStandardMaterial({ color: 0x64748b });
for (let i = 0; i < 8; i++) {
  const cover = new THREE.Mesh(coverGeo, coverMat);
  cover.position.set(Math.random()*16-8, 1, Math.random()*26-13);
  cover.castShadow = true;
  scene.add(cover);
}

// Bomb site
const bombSite = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 0.2, 32), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
bombSite.position.set(0, 0.1, -10);
scene.add(bombSite);

// Enemies
const enemies = [];
const enemyGeo = new THREE.Group();
const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 2, 8), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
const head = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
head.position.y = 1.2;
enemyGeo.add(body);
enemyGeo.add(head);

for (let i = 0; i < 6; i++) {
  const enemy = enemyGeo.clone();
  enemy.position.set(Math.random()*16-8, 1, Math.random()*26-13);
  enemy.hp = 100;
  scene.add(enemy);
  enemies.push(enemy);
}

// Player state
let velocity = new THREE.Vector3();
let direction = new THREE.Vector3();
let move = { forward: false, backward: false, left: false, right: false };
let canJump = true;
let crouch = false;
let lean = 0;
let health = 100;
let ammo = 30;
let reserve = 120;
let lives = 3;
let planting = false;
let plantTime = 0;

// Keys
document.addEventListener('keydown', (e) => {
  switch (e.code) {
    case 'KeyW': move.forward = true; break;
    case 'KeyS': move.backward = true; break;
    case 'KeyA': move.left = true; break;
    case 'KeyD': move.right = true; break;
    case 'ShiftLeft': crouch = true; break;
    case 'KeyQ': lean = -0.2; break;
    case 'KeyE': lean = 0.2; break;
    case 'KeyF': if (controls.isLocked && camera.position.distanceTo(bombSite.position) < 3) planting = true; break;
  }
});
document.addEventListener('keyup', (e) => {
  switch (e.code) {
    case 'KeyW': move.forward = false; break;
    case 'KeyS': move.backward = false; break;
    case 'KeyA': move.left = false; break;
    case 'KeyD': move.right = false; break;
    case 'ShiftLeft': crouch = false; break;
    case 'KeyQ':
    case 'KeyE': lean = 0; break;
    case 'KeyF': planting = false; plantTime = 0; break;
  }
});

// Shooting
const raycaster = new THREE.Raycaster();
const bulletPool = [];
for (let i = 0; i < 50; i++) {
  const bullet = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
  bullet.visible = false;
  scene.add(bullet);
  bulletPool.push(bullet);
}

function getBullet() {
  return bulletPool.find(b => !b.visible) || bulletPool[0];
}

document.addEventListener('mousedown', (e) => {
  if (controls.isLocked && e.button === 0 && ammo > 0) {
    ammo--;
    document.getElementById('ammo').textContent = `${ammo} / ${reserve}`;
    // Muzzle flash simple
    const flash = new THREE.PointLight(0xffaa00, 5, 5);
    flash.position.copy(camera.position);
    scene.add(flash);
    setTimeout(() => scene.remove(flash), 50);

    // Recoil
    controls.getObject().rotation.x -= 0.05;

    // Raycast bullet
    raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
    const intersects = raycaster.intersectObjects([...walls, ...enemies.flatMap(e => e.children)], true);
    if (intersects.length > 0) {
      const hit = intersects[0];
      if (enemies.some(e => e.children.includes(hit.object))) {
        const enemy = enemies.find(e => e.children.includes(hit.object));
        const damage = hit.object === enemy.children[1] ? 50 : 25; // headshot
        enemy.hp -= damage;
        // Floating damage
        const dmgText = document.createElement('div');
        dmgText.textContent = damage;
        dmgText.style.position = 'absolute';
        dmgText.style.color = '#ff0000';
        dmgText.style.fontSize = '24px';
        dmgText.style.pointerEvents = 'none';
        const pos = hit.point.clone().project(camera);
        dmgText.style.left = `${(pos.x + 1)/2 * window.innerWidth}px`;
        dmgText.style.top = `${(-pos.y + 1)/2 * window.innerHeight}px`;
        document.body.appendChild(dmgText);
        setTimeout(() => document.body.removeChild(dmgText), 1000);
        if (enemy.hp <= 0) {
          scene.remove(enemy);
          enemies.splice(enemies.indexOf(enemy), 1);
        }
      }
    }
  }
});

// Grenade (simple)
document.addEventListener('keydown', (e) => {
  if (e.key === 'g' && controls.isLocked) {
    const grenade = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 16), new THREE.MeshStandardMaterial({ color: 0x333333 }));
    grenade.position.copy(camera.position);
    grenade.velocity = camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(20).add(new THREE.Vector3(0, 5, 0));
    scene.add(grenade);
    const interval = setInterval(() => {
      grenade.velocity.y -= 0.5;
      grenade.position.add(grenade.velocity.clone().multiplyScalar(0.05));
      if (grenade.position.y < 0) {
        clearInterval(interval);
        // Explosion particles
        for (let i = 0; i < 50; i++) {
          const p = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshBasicMaterial({ color: 0xff5500 }));
          p.position.copy(grenade.position);
          p.velocity = new THREE.Vector3(Math.random()-0.5, Math.random(), Math.random()-0.5).multiplyScalar(10);
          scene.add(p);
          setTimeout(() => scene.remove(p), 1000);
        }
        scene.remove(grenade);
        // Damage enemies in radius
        enemies.forEach(enemy => {
          if (enemy.position.distanceTo(grenade.position) < 5) {
            enemy.hp -= 80;
            if (enemy.hp <= 0) {
              scene.remove(enemy);
              enemies.splice(enemies.indexOf(enemy), 1);
            }
          }
        });
      }
    }, 50);
  }
});

// Minimap
const miniCtx = document.getElementById('minimap').getContext('2d');
function drawMinimap() {
  miniCtx.clearRect(0,0,200,200);
  miniCtx.fillStyle = '#020617';
  miniCtx.fillRect(0,0,200,200);
  // Walls outline simple
  miniCtx.strokeStyle = '#4b5563';
  miniCtx.lineWidth = 4;
  miniCtx.strokeRect(20, 20, 160, 160);
  // Player
  const px = (controls.getObject().position.x + 10) / 20 * 160 + 20;
  const pz = (controls.getObject().position.z + 15) / 30 * 160 + 20;
  miniCtx.fillStyle = '#60a5fa';
  miniCtx.beginPath();
  miniCtx.arc(px, pz, 6, 0, Math.PI*2);
  miniCtx.fill();
  // Enemies
  miniCtx.fillStyle = '#ff0000';
  enemies.forEach(e => {
    const ex = (e.position.x + 10) / 20 * 160 + 20;
    const ez = (e.position.z + 15) / 30 * 160 + 20;
    miniCtx.beginPath();
    miniCtx.arc(ex, ez, 4, 0, Math.PI*2);
    miniCtx.fill();
  });
}

// Simple enemy AI - patrol then chase
enemies.forEach(enemy => {
  enemy.patrolDir = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize();
});
function updateEnemies(delta) {
  enemies.forEach(enemy => {
    const distToPlayer = enemy.position.distanceTo(controls.getObject().position);
    if (distToPlayer < 15) {
      // Chase
      const dir = controls.getObject().position.clone().sub(enemy.position).normalize();
      enemy.position.add(dir.multiplyScalar(delta * 3));
      enemy.lookAt(controls.getObject().position);
      // Simple shoot at player
      if (Math.random() < 0.01) {
        health -= 10;
        document.getElementById('health').textContent = health;
        if (health <= 0) {
          lives--;
          document.getElementById('lives').textContent = lives;
          health = 100;
          if (lives <= 0) alert('Defenders win!');
        }
      }
    } else {
      // Patrol
      enemy.position.add(enemy.patrolDir.clone().multiplyScalar(delta * 1));
      if (Math.random() < 0.05) enemy.patrolDir = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize();
    }
  });
}

// Animate
function animate() {
  requestAnimationFrame(animate);
  const delta = clock.getDelta();

  if (controls.isLocked) {
    direction.z = Number(move.forward) - Number(move.backward);
    direction.x = Number(move.right) - Number(move.left);
    direction.normalize();

    if (move.forward || move.backward) velocity.z -= direction.z * 20 * delta;
    if (move.left || move.right) velocity.x -= direction.x * 20 * delta;

    velocity.x *= 0.9;
    velocity.z *= 0.9;

    if (crouch) {
      camera.position.y = THREE.MathUtils.lerp(camera.position.y, 0.8, 0.1);
      velocity.multiplyScalar(0.5);
    } else {
      camera.position.y = THREE.MathUtils.lerp(camera.position.y, 1.6, 0.1);
    }

    controls.moveRight(-velocity.x * delta);
    controls.moveForward(-velocity.z * delta);

    // Lean
    camera.rotation.z = THREE.MathUtils.lerp(camera.rotation.z, lean, 0.1);

    // Gravity / jump
    velocity.y -= 9.8 * delta;
    controls.getObject().position.y += velocity.y * delta;
    if (controls.getObject().position.y < 1.6) {
      velocity.y = 0;
      controls.getObject().position.y = 1.6;
      canJump = true;
    }
    if (e.code === 'Space' && canJump) {
      velocity.y += 8;
      canJump = false;
    }

    // Planting
    if (planting && camera.position.distanceTo(bombSite.position) < 3) {
      plantTime += delta;
      if (plantTime >= 5) {
        alert('Bomb planted! Attackers win!');
        planting = false;
      }
    }

    // Win check
    if (enemies.length === 0) alert('All defenders eliminated! Attackers win!');
  }

  updateEnemies(delta);
  drawMinimap();
  composer.render();
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  composer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
