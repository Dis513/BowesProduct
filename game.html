
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D FPS Battle Arena</title>
    <link rel="stylesheet" href="style.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r168/three.min.js"></script>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        
        <!-- HUD -->
        <div id="hud">
            <div id="crosshair">
                <div class="crosshair-line horizontal"></div>
                <div class="crosshair-line vertical"></div>
            </div>
            
            <div id="health-bar">
                <div id="health-fill"></div>
            </div>
            
            <div id="ammo-display">30/90</div>
            
            <div id="score-display">Score: 0</div>
            
            <div id="wave-display">Wave: 1</div>
        </div>
        
        <!-- Wave Announcement -->
        <div id="wave-announcement">WAVE 1</div>
        
        <!-- Main Menu -->
        <div id="menu">
            <h1>3D FPS BATTLE ARENA</h1>
            <p>Survive the waves and become the ultimate champion!</p>
            
            <div id="character-select">
                <div class="character-option selected" data-character="default" style="background: linear-gradient(135deg, #667eea, #764ba2);">
                    <canvas id="preview-default" width="120" height="120"></canvas>
                </div>
                <div class="character-option" data-character="ninja" style="background: linear-gradient(135deg, #f093fb, #f5576c);">
                    <canvas id="preview-ninja" width="120" height="120"></canvas>
                </div>
                <div class="character-option" data-character="cyber" style="background: linear-gradient(135deg, #4facfe, #00f2fe);">
                    <canvas id="preview-cyber" width="120" height="120"></canvas>
                </div>
            </div>
            
            <div id="upload-section">
                <h2>Upload Custom Character</h2>
                <p>Upload a GLB/GLTF 3D model (max 50MB)</p>
                <input type="file" id="file-input" accept=".glb,.gltf">
                <button class="upload-button" onclick="document.getElementById('file-input').click()">Choose Model</button>
                <div id="model-preview"></div>
            </div>
            
            <button class="menu-button" id="start-button">START GAME</button>
            
            <div id="instructions">
                <h3>Controls</h3>
                <ul>
                    <li><span class="key">WASD</span> Move</li>
                    <li><span class="key">Mouse</span> Look around</li>
                    <li><span class="key">Left Click</span> Shoot</li>
                    <li><span class="key">R</span> Reload</li>
                    <li><span class="key">Shift</span> Sprint</li>
                </ul>
            </div>
        </div>
        
        <!-- Game Over Screen -->
        <div id="game-over">
            <h1>GAME OVER</h1>
            <div id="final-score">Final Score: 0</div>
            <button class="menu-button" id="restart-button">PLAY AGAIN</button>
        </div>
    </div>

    <script>
        // Game State
        const gameState = {
            isPlaying: false,
            health: 100,
            ammo: 30,
            maxAmmo: 30,
            reserveAmmo: 90,
            score: 0,
            wave: 1,
            enemies: [],
            bullets: [],
            selectedCharacter: 'default',
            customModel: null
        };

        // Three.js Setup
        let scene, camera, renderer, clock;
        let player, playerBody;
        let enemies = [];
        let bullets = [];
        let map = {};
        let isLocked = false;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();

        // Initialize Three.js
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 10, 100);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 0);

            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('game-canvas'),
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            clock = new THREE.Clock();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            const pointLight1 = new THREE.PointLight(0x00ff88, 1, 50);
            pointLight1.position.set(10, 10, 10);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xff0066, 1, 50);
            pointLight2.position.set(-10, 10, -10);
            scene.add(pointLight2);

            createMap();
            createCharacterPreviews();

            window.addEventListener('resize', onWindowResize);
        }

        // Create Game Map
        function createMap() {
            // Ground
            const groundGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2a2a4a,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            map.ground = ground;

            // Create arena walls
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3a3a6a,
                roughness: 0.6,
                metalness: 0.3
            });

            // Arena boundaries
            const wallGeometry = new THREE.BoxGeometry(200, 10, 2);
            
            // North wall
            const northWall = new THREE.Mesh(wallGeometry, wallMaterial);
            northWall.position.set(0, 5, -100);
            northWall.castShadow = true;
            northWall.receiveShadow = true;
            scene.add(northWall);

            // South wall
            const southWall = new THREE.Mesh(wallGeometry, wallMaterial);
            southWall.position.set(0, 5, 100);
            southWall.castShadow = true;
            southWall.receiveShadow = true;
            scene.add(southWall);

            // East wall
            const eastWall = new THREE.Mesh(new THREE.BoxGeometry(2, 10, 200), wallMaterial);
            eastWall.position.set(100, 5, 0);
            eastWall.castShadow = true;
            eastWall.receiveShadow = true;
            scene.add(eastWall);

            // West wall
            const westWall = new THREE.Mesh(new THREE.BoxGeometry(2, 10, 200), wallMaterial);
            westWall.position.set(-100, 5, 0);
            westWall.castShadow = true;
            westWall.receiveShadow = true;
            scene.add(westWall);

            // Add obstacles and cover
            addObstacles();

            // Add decorative elements
            addDecorations();
        }

        // Add obstacles
        function addObstacles() {
            const obstaclePositions = [
                { x: 20, z: 20, width: 4, height: 3, depth: 4 },
                { x: -20, z: -20, width: 3, height: 2, depth: 3 },
                { x: 30, z: -30, width: 5, height: 4, depth: 2 },
                { x: -30, z: 30, width: 2, height: 3, depth: 5 },
                { x: 0, z: 40, width: 6, height: 2, depth: 2 },
                { x: 40, z: 0, width: 2, height: 3, depth: 6 },
                { x: -40, z: 0, width: 2, height: 2, depth: 4 },
                { x: 15, z: -40, width: 4, height: 3, depth: 3 },
                { x: -15, z: 40, width: 3, height: 2, depth: 4 },
                { x: 50, z: 50, width: 4, height: 3, depth: 4 },
                { x: -50, z: -50, width: 3, height: 2, depth: 3 }
            ];

            const obstacleColors = [0x4a4a8a, 0x5a5a9a, 0x3a3a7a, 0x6a6aaa];

            obstaclePositions.forEach((pos, index) => {
                const geometry = new THREE.BoxGeometry(pos.width, pos.height, pos.depth);
                const material = new THREE.MeshStandardMaterial({
                    color: obstacleColors[index % obstacleColors.length],
                    roughness: 0.7,
                    metalness: 0.3
                });
                const obstacle = new THREE.Mesh(geometry, material);
                obstacle.position.set(pos.x, pos.height / 2, pos.z);
                obstacle.castShadow = true;
                obstacle.receiveShadow = true;
                scene.add(obstacle);
            });
        }

        // Add decorations
        function addDecorations() {
            // Glowing orbs
            const orbGeometry = new THREE.SphereGeometry(1, 32, 32);
            const orbMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ff88,
                emissive: 0x00ff88,
                emissiveIntensity: 0.5
            });

            for (let i = 0; i < 10; i++) {
                const orb = new THREE.Mesh(orbGeometry, orbMaterial);
                orb.position.set(
                    Math.random() * 160 - 80,
                    2 + Math.random() * 3,
                    Math.random() * 160 - 80
                );
                scene.add(orb);
            }

            // Pillars
            const pillarGeometry = new THREE.CylinderGeometry(1, 1, 8, 32);
            const pillarMaterial = new THREE.MeshStandardMaterial({
                color: 0x5a5a9a,
                roughness: 0.5,
                metalness: 0.5
            });

            for (let i = 0; i < 8; i++) {
                const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                const angle = (i / 8) * Math.PI * 2;
                pillar.position.set(
                    Math.cos(angle) * 40,
                    4,
                    Math.sin(angle) * 40
                );
                pillar.castShadow = true;
                pillar.receiveShadow = true;
                scene.add(pillar);
            }
        }

        // Create character previews
        function createCharacterPreviews() {
            const characters = ['default', 'ninja', 'cyber'];
            
            characters.forEach(char => {
                const canvas = document.getElementById(`preview-${char}`);
                const previewScene = new THREE.Scene();
                previewScene.background = new THREE.Color(0x1a1a2e);
                
                const previewCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
                previewCamera.position.set(0, 1.5, 3);
                previewCamera.lookAt(0, 1, 0);
                
                const previewRenderer = new THREE.WebGLRenderer({ 
                    canvas: canvas,
                    antialias: true 
                });
                previewRenderer.setSize(120, 120);
                
                const light = new THREE.DirectionalLight(0xffffff, 1);
                light.position.set(5, 10, 5);
                previewScene.add(light);
                
                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                previewScene.add(ambientLight);
                
                // Create character mesh based on type
                const characterMesh = createCharacterMesh(char);
                previewScene.add(characterMesh);
                
                // Add ground
                const groundGeometry = new THREE.PlaneGeometry(10, 10);
                const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x2a2a4a });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                previewScene.add(ground);
                
                // Animate preview
                function animatePreview() {
                    requestAnimationFrame(animatePreview);
                    characterMesh.rotation.y += 0.02;
                    previewRenderer.render(previewScene, previewCamera);
                }
                animatePreview();
            });
        }

        // Create character mesh
        function createCharacterMesh(type) {
            const group = new THREE.Group();
            
            let color = 0x667eea;
            let accentColor = 0x764ba2;
            
            switch(type) {
                case 'ninja':
                    color = 0x1a1a1a;
                    accentColor = 0xff0066;
                    break;
                case 'cyber':
                    color = 0x00f2fe;
                    accentColor = 0x4facfe;
                    break;
            }
            
            // Body
            const bodyGeometry = new THREE.CapsuleGeometry(0.3, 0.8, 4, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.5,
                metalness: 0.5
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1;
            group.add(body);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: accentColor,
                roughness: 0.3,
                metalness: 0.7
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.7;
            group.add(head);
            
            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00ff88,
                emissive: 0x00ff88,
                emissiveIntensity: 1
            });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(0.1, 1.75, 0.2);
            group.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(-0.1, 1.75, 0.2);
            group.add(rightEye);
            
            return group;
        }

        // Create custom character from uploaded model
        function createCustomCharacter(gltf) {
            const model = gltf.scene;
            model.scale.set(0.5, 0.5, 0.5);
            model.position.y = 0.5;
            return model;
        }

        // Enemy creation
        function createEnemy(position) {
            const enemyGroup = new THREE.Group();
            
            // Enemy body
            const bodyGeometry = new THREE.CapsuleGeometry(0.4, 1, 8, 16);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff0044,
                roughness: 0.6,
                metalness: 0.4
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1;
            body.castShadow = true;
            enemyGroup.add(body);
            
            // Enemy head
            const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff0066,
                roughness: 0.4,
                metalness: 0.6
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2;
            head.castShadow = true;
            enemyGroup.add(head);
            
            // Glowing eyes
            const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 1
            });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(0.12, 2.05, 0.25);
            enemyGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(-0.12, 2.05, 0.25);
            enemyGroup.add(rightEye);
            
            enemyGroup.position.copy(position);
            enemyGroup.userData = {
                health: 50 + gameState.wave * 10,
                speed: 3 + gameState.wave * 0.5,
                damage: 10 + gameState.wave * 2,
                lastAttack: 0,
                type: 'enemy'
            };
            
            scene.add(enemyGroup);
            enemies.push(enemyGroup);
            
            return enemyGroup;
        }

        // Spawn wave of enemies
        function spawnWave() {
            const enemyCount = 3 + gameState.wave * 2;
            const announcement = document.getElementById('wave-announcement');
            announcement.textContent = `WAVE ${gameState.wave}`;
            announcement.classList.add('show');
            
            setTimeout(() => {
                announcement.classList.remove('show');
            }, 2000);
            
            for (let i = 0; i < enemyCount; i++) {
                setTimeout(() => {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 30 + Math.random() * 20;
                    const position = new THREE.Vector3(
                        Math.cos(angle) * distance,
                        0,
                        Math.sin(angle) * distance
                    );
                    createEnemy(position);
                }, i * 500);
            }
        }

        // Update enemies
        function updateEnemies(delta) {
            const playerPosition = camera.position.clone();
            
            enemies.forEach((enemy, index) => {
                if (!enemy.parent) return;
                
                // Move towards player
                const direction = new THREE.Vector3()
                    .subVectors(playerPosition, enemy.position)
                    .normalize();
                
                // Keep enemy at ground level
                direction.y = 0;
                
                enemy.position.add(direction.multiplyScalar(enemy.userData.speed * delta));
                enemy.lookAt(playerPosition.x, enemy.position.y, playerPosition.z);
                
                // Check if enemy can attack
                const distanceToPlayer = enemy.position.distanceTo(playerPosition);
                if (distanceToPlayer < 2 && Date.now() - enemy.userData.lastAttack > 1000) {
                    // Attack player
                    gameState.health -= enemy.userData.damage;
                    enemy.userData.lastAttack = Date.now();
                    updateHealthBar();
                    
                    // Screen shake effect
                    shakeScreen();
                    
                    if (gameState.health <= 0) {
                        gameOver();
                    }
                }
            });
        }

        // Screen shake effect
        function shakeScreen() {
            const intensity = 0.5;
            camera.position.x += (Math.random() - 0.5) * intensity;
            camera.position.y += (Math.random() - 0.5) * intensity;
            camera.position.z += (Math.random() - 0.5) * intensity;
        }

        // Shooting mechanics
        function shoot() {
            if (gameState.ammo <= 0) {
                reload();
                return;
            }
            
            gameState.ammo--;
            updateAmmoDisplay();
            
            // Create bullet
            const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const bulletMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00ff88,
                emissive: 0x00ff88,
                emissiveIntensity: 1
            });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            // Set bullet position at camera
            bullet.position.copy(camera.position);
            
            // Set bullet direction
            const bulletDirection = new THREE.Vector3();
            camera.getWorldDirection(bulletDirection);
            
            bullet.userData = {
                direction: bulletDirection,
                speed: 100,
                lifetime: 2
            };
            
            scene.add(bullet);
            bullets.push(bullet);
            
            // Muzzle flash effect
            createMuzzleFlash();
        }

        // Create muzzle flash
        function createMuzzleFlash() {
            const flashGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const flashMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffff00,
                transparent: true,
                opacity: 1
            });
            const flash = new THREE.Mesh(flashGeometry, flashMaterial);
            
            const flashDirection = new THREE.Vector3();
            camera.getWorldDirection(flashDirection);
            flash.position.copy(camera.position).add(flashDirection.multiplyScalar(1));
            
            scene.add(flash);
            
            setTimeout(() => {
                scene.remove(flash);
            }, 50);
        }

        // Update bullets
        function updateBullets(delta) {
            bullets.forEach((bullet, index) => {
                bullet.position.add(
                    bullet.userData.direction.clone().multiplyScalar(bullet.userData.speed * delta)
                );
                
                bullet.userData.lifetime -= delta;
                
                // Check collision with enemies
                enemies.forEach((enemy) => {
                    if (!enemy.parent) return;
                    
                    const distance = bullet.position.distanceTo(enemy.position);
                    if (distance < 1.5) {
                        // Hit enemy
                        enemy.userData.health -= 25;
                        
                        // Hit effect
                        createHitEffect(bullet.position);
                        
                        // Remove bullet
                        scene.remove(bullet);
                        bullets.splice(bullets.indexOf(bullet), 1);
                        
                        // Check if enemy is dead
                        if (enemy.userData.health <= 0) {
                            scene.remove(enemy);
                            enemies.splice(enemies.indexOf(enemy), 1);
                            gameState.score += 100 * gameState.wave;
                            updateScoreDisplay();
                            
                            // Check if wave is complete
                            if (enemies.length === 0) {
                                gameState.wave++;
                                updateWaveDisplay();
                                setTimeout(spawnWave, 3000);
                            }
                        }
                    }
                });
                
                // Remove bullet if lifetime expired
                if (bullet.userData.lifetime <= 0) {
                    scene.remove(bullet);
                    bullets.splice(bullets.indexOf(bullet), 1);
                }
            });
        }

        // Create hit effect
        function createHitEffect(position) {
            const particleCount = 10;
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.1, 8, 8);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xff0044,
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 5,
                        Math.random() * 5,
                        (Math.random() - 0.5) * 5
                    ),
                    lifetime: 0.5
                };
                scene.add(particle);
                particles.push(particle);
            }
            
            setTimeout(() => {
                particles.forEach(particle => scene.remove(particle));
            }, 500);
        }

        // Reload
        function reload() {
            if (gameState.reserveAmmo > 0 && gameState.ammo < gameState.maxAmmo) {
                const needed = gameState.maxAmmo - gameState.ammo;
                const available = Math.min(needed, gameState.reserveAmmo);
                gameState.ammo += available;
                gameState.reserveAmmo -= available;
                updateAmmoDisplay();
            }
        }

        // Update UI displays
        function updateHealthBar() {
            const healthFill = document.getElementById('health-fill');
            healthFill.style.width = `${gameState.health}%`;
        }

        function updateAmmoDisplay() {
            document.getElementById('ammo-display').textContent = `${gameState.ammo}/${gameState.reserveAmmo}`;
        }

        function updateScoreDisplay() {
            document.getElementById('score-display').textContent = `Score: ${gameState.score}`;
        }

        function updateWaveDisplay() {
            document.getElementById('wave-display').textContent = `Wave: ${gameState.wave}`;
        }

        // Player movement
        function updatePlayerMovement(delta) {
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            
            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();
            
            const speed = 50;
            if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;
            
            camera.translateX(-velocity.x * delta);
            camera.translateZ(-velocity.z * delta);
            
            // Keep player on ground
            camera.position.y = 2;
            
            // Keep player in bounds
            camera.position.x = Math.max(-95, Math.min(95, camera.position.x));
            camera.position.z = Math.max(-95, Math.min(95, camera.position.z));
        }

        // Mouse look
        let euler = new THREE.Euler(0, 0, 0, 'YXZ');
        
        function onMouseMove(event) {
            if (!isLocked) return;
            
            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;
            
            euler.setFromQuaternion(camera.quaternion);
            euler.y -= movementX * 0.002;
            euler.x -= movementY * 0.002;
            euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
            
            camera.quaternion.setFromEuler(euler);
        }

        // Window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Pointer lock
        function onPointerLockChange() {
            isLocked = document.pointerLockElement === document.getElementById('game-canvas');
        }

        // Game loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (!gameState.isPlaying) {
                renderer.render(scene, camera);
                return;
            }
            
            const delta = (performance.now() - prevTime) / 1000;
            
            updatePlayerMovement(delta);
            updateEnemies(delta);
            updateBullets(delta);
            
            renderer.render(scene, camera);
            prevTime = performance.now();
        }

        // Start game
        function startGame() {
            gameState.isPlaying = true;
            gameState.health = 100;
            gameState.ammo = 30;
            gameState.reserveAmmo = 90;
            gameState.score = 0;
            gameState.wave = 1;
            
            // Reset camera position
            camera.position.set(0, 2, 0);
            camera.rotation.set(0, 0, 0);
            
            // Clear existing enemies
            enemies.forEach(enemy => scene.remove(enemy));
            enemies = [];
            
            // Clear existing bullets
            bullets.forEach(bullet => scene.remove(bullet));
            bullets = [];
            
            // Update UI
            updateHealthBar();
            updateAmmoDisplay();
            updateScoreDisplay();
            updateWaveDisplay();
            
            // Hide menu
            document.getElementById('menu').style.display = 'none';
            document.getElementById('game-over').style.display = 'none';
            
            // Lock pointer
            document.getElementById('game-canvas').requestPointerLock();
            
            // Spawn first wave
            setTimeout(spawnWave, 2000);
        }

        // Game over
        function gameOver() {
            gameState.isPlaying = false;
            document.exitPointerLock();
            
            document.getElementById('final-score').textContent = `Final Score: ${gameState.score}`;
            document.getElementById('game-over').style.display = 'flex';
        }

        // File upload handler
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const contents = e.target.result;
                
                // Try to load as GLB/GLTF
                try {
                    const loader = new THREE.GLTFLoader();
                    loader.parse(contents, '', function(gltf) {
                        gameState.customModel = gltf;
                        showCustomModelPreview(gltf);
                    }, function(error) {
                        console.error('Error loading model:', error);
                        alert('Failed to load model. Please upload a valid GLB/GLTF file.');
                    });
                } catch (error) {
                    console.error('Error parsing model:', error);
                    alert('Failed to parse model. Please upload a valid GLB/GLTF file.');
                }
            };
            reader.readAsArrayBuffer(file);
        }

        // Show custom model preview
        function showCustomModelPreview(gltf) {
            const previewContainer = document.getElementById('model-preview');
            previewContainer.style.display = 'block';
            previewContainer.innerHTML = '';
            
            const previewCanvas = document.createElement('canvas');
            previewCanvas.width = previewContainer.clientWidth;
            previewCanvas.height = previewContainer.clientHeight;
            previewContainer.appendChild(previewCanvas);
            
            const previewScene = new THREE.Scene();
            previewScene.background = new THREE.Color(0x1a1a2e);
            
            const previewCamera = new THREE.PerspectiveCamera(50, previewCanvas.clientWidth / previewCanvas.clientHeight, 0.1, 100);
            previewCamera.position.set(0, 1.5, 3);
            previewCamera.lookAt(0, 1, 0);
            
            const previewRenderer = new THREE.WebGLRenderer({ canvas: previewCanvas, antialias: true });
            previewRenderer.setSize(previewCanvas.clientWidth, previewCanvas.clientHeight);
            
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(5, 10, 5);
            previewScene.add(light);
            
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            previewScene.add(ambientLight);
            
            const model = gltf.scene.clone();
            model.scale.set(0.5, 0.5, 0.5);
            model.position.y = 0.5;
            previewScene.add(model);
            
            // Add ground
            const groundGeometry = new THREE.PlaneGeometry(10, 10);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x2a2a4a });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            previewScene.add(ground);
            
            function animatePreview() {
                requestAnimationFrame(animatePreview);
                model.rotation.y += 0.01;
                previewRenderer.render(previewScene, previewCamera);
            }
            animatePreview();
            
            // Add custom character option
            const customOption = document.createElement('div');
            customOption.className = 'character-option';
            customOption.dataset.character = 'custom';
            customOption.style.background = 'linear-gradient(135deg, #ffd700, #ff8c00)';
            customOption.innerHTML = `<canvas id="preview-custom" width="120" height="120"></canvas>`;
            
            document.getElementById('character-select').appendChild(customOption);
            
            // Create preview for custom option
            setTimeout(() => {
                const customCanvas = document.getElementById('preview-custom');
                if (customCanvas) {
                    const customPreviewScene = new THREE.Scene();
                    customPreviewScene.background = new THREE.Color(0x1a1a2e);
                    
                    const customPreviewCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
                    customPreviewCamera.position.set(0, 1.5, 3);
                    customPreviewCamera.lookAt(0, 1, 0);
                    
                    const customPreviewRenderer = new THREE.WebGLRenderer({ canvas: customCanvas, antialias: true });
                    customPreviewRenderer.setSize(120, 120);
                    
                    const customLight = new THREE.DirectionalLight(0xffffff, 1);
                    customLight.position.set(5, 10, 5);
                    customPreviewScene.add(customLight);
                    
                    const customAmbientLight = new THREE.AmbientLight(0x404040, 0.5);
                    customPreviewScene.add(customAmbientLight);
                    
                    const customModel = gltf.scene.clone();
                    customModel.scale.set(0.5, 0.5, 0.5);
                    customModel.position.y = 0.5;
                    customPreviewScene.add(customModel);
                    
                    const customGround = new THREE.Mesh(
                        new THREE.PlaneGeometry(10, 10),
                        new THREE.MeshStandardMaterial({ color: 0x2a2a4a })
                    );
                    customGround.rotation.x = -Math.PI / 2;
                    customPreviewScene.add(customGround);
                    
                    function animateCustomPreview() {
                        requestAnimationFrame(animateCustomPreview);
                        customModel.rotation.y += 0.02;
                        customPreviewRenderer.render(customPreviewScene, customPreviewCamera);
                    }
                    animateCustomPreview();
                }
            }, 100);
        }

        // Character selection
        function setupCharacterSelection() {
            const options = document.querySelectorAll('.character-option');
            options.forEach(option => {
                option.addEventListener('click', function() {
                    options.forEach(opt => opt.classList.remove('selected'));
                    this.classList.add('selected');
                    gameState.selectedCharacter = this.dataset.character;
                });
            });
        }

        // Event listeners
        function setupEventListeners() {
            // Keyboard controls
            document.addEventListener('keydown', (event) => {
                switch (event.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'KeyR': reload(); break;
                    case 'Space': 
                        if (canJump) {
                            velocity.y += 10;
                            canJump = false;
                        }
                        break;
                }
            });
            
            document.addEventListener('keyup', (event) => {
                switch (event.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyD': moveRight = false; break;
                }
            });
            
            // Mouse controls
            document.addEventListener('mousemove', onMouseMove);
            document.getElementById('game-canvas').addEventListener('click', () => {
                if (gameState.isPlaying && !isLocked) {
                    document.getElementById('game-canvas').requestPointerLock();
                } else if (gameState.isPlaying && isLocked) {
                    shoot();
                }
            });
            
            document.addEventListener('mousedown', (event) => {
                if (gameState.isPlaying && isLocked && event.button === 0) {
                    shoot();
                }
            });
            
            document.addEventListener('pointerlockchange', onPointerLockChange);
            
            // Menu buttons
            document.getElementById('start-button').addEventListener('click', startGame);
            document.getElementById('restart-button').addEventListener('click', startGame);
            
            // File upload
            document.getElementById('file-input').addEventListener('change', handleFileUpload);
            
            // Character selection
            setupCharacterSelection();
        }

        // Initialize game
        function init() {
            initThreeJS();
            setupEventListeners();
            animate();
        }

<script>
// Dynamically load GLTFLoader and initialize the game
const gltfScript = document.createElement('script');
gltfScript.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js';
gltfScript.onload = function () {
    init();  // Start everything once the loader is ready
};
gltfScript.onerror = function () {
    console.error('Failed to load GLTFLoader');
    alert('Could not load the 3D model loader. Check your internet connection or try a different browser.');
};
document.head.appendChild(gltfScript);
</script>
</body>
</html>




