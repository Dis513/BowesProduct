<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Image Editor ‚Äì BowesProduct</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
*, *::before, *::after { box-sizing: border-box; }
html, body {
  margin: 0;
  background: #020617;
  color: white;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
  overflow-x: hidden;
  height: 100vh;
  display: flex;
  flex-direction: column;
}

/* ================= HEADER ================= */
.site-header {
  position: sticky;
  top: 0;
  z-index: 1000;
  background: rgba(2,6,23,0.95);
  border-bottom: 1px solid #1e293b;
}

.header-inner {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0.6rem 1rem;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

/* LEFT */
.header-left {
  display: flex;
  align-items: center;
  gap: 1.6rem;
}
.logo a {
  font-size: 1.3rem;
  font-weight: 700;
  color: white;
  text-decoration: none;
  white-space: nowrap;
}
.main-nav {
  display: flex;
  gap: 1.4rem;
}
.main-nav a {
  color: #e5e7eb;
  text-decoration: none;
  font-size: 0.95rem;
}
.main-nav a.active,
.main-nav a:hover {
  color: #60a5fa;
}

/* RIGHT */
.header-right {
  display: flex;
  align-items: center;
  gap: 0.8rem;
  min-height: 44px;
}

/* PROFILE */
#profilePic {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  border: 2px solid #60a5fa;
  object-fit: cover;
  display: none;
}

/* LOGIN */
.login-btn {
  padding: 0.45rem 1.1rem;
  border-radius: 999px;
  border: 1.5px solid #60a5fa;
  background: transparent;
  color: #60a5fa;
  font-size: 0.95rem;
  cursor: pointer;
}

/* XP */
#levelInfo {
  display: none;
  width: 140px;
  font-size: 0.8rem;
  color: #cbd5e1;
}
#levelText {
  white-space: nowrap;
}
#xpOuter {
  width: 100%;
  height: 5px;
  background: #1e293b;
  border-radius: 3px;
  margin-top: 4px;
}
#xpBar {
  height: 100%;
  width: 0%;
  background: #60a5fa;
  border-radius: 3px;
  transition: width 0.35s ease;
}

/* MOBILE HEADER */
@media (max-width: 768px) {
  .header-inner {
    flex-direction: column;
    align-items: stretch;
    gap: 8px;
  }
  .header-left {
    justify-content: space-between;
  }
  .header-right {
    justify-content: space-between;
    width: 100%;
  }
  #levelInfo {
    width: 100%;
  }
}

/* ================= MAIN LAYOUT ================= */
.main-container {
  display: flex;
  flex: 1;
  height: calc(100vh - 70px);
  overflow: hidden;
}

/* ================= LEFT PANEL (Tabs) ================= */
.left-panel {
  width: 200px;
  min-width: 160px;
  background: #0f172a;
  border-right: 1px solid #1e293b;
  padding: 1rem 0.75rem;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}
.left-panel h3 {
  margin: 0 0 0.75rem 0;
  font-size: 0.7rem;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  color: #64748b;
  padding: 0 0.25rem;
}
.tab-btn {
  width: 100%;
  padding: 0.625rem 0.75rem;
  background: transparent;
  border: none;
  border-radius: 8px;
  color: #94a3b8;
  font-size: 0.875rem;
  cursor: pointer;
  transition: all 0.2s ease;
  text-align: left;
  font-weight: 500;
}
.tab-btn:hover {
  color: #fff;
  background: rgba(255,255,255,0.05);
}
.tab-btn.active {
  color: #fff;
  background: #3b82f6;
  font-weight: 600;
}

/* ================= CENTER PANEL (Canvas) ================= */
.center-panel {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: #0a0a0a;
  padding: 1.5rem;
  min-width: 0;
}
#canvas {
  max-width: 100%;
  max-height: calc(100% - 80px);
  background: #111;
  border: 1px solid #333;
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.5);
}
.canvas-toolbar {
  display: flex;
  gap: 0.5rem;
  margin-top: 1rem;
  flex-wrap: wrap;
  justify-content: center;
}
.toolbar-btn {
  padding: 0.625rem 1rem;
  background: #1e293b;
  border: 1px solid #334155;
  border-radius: 8px;
  color: #fff;
  font-size: 0.875rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
}
.toolbar-btn:hover {
  background: #334155;
  border-color: #475569;
}
.toolbar-btn.primary {
  background: #2563eb;
  border: none;
  font-weight: 600;
}
.toolbar-btn.primary:hover {
  background: #1d4ed8;
}
.toolbar-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* ================= RIGHT PANEL (Controls) ================= */
.right-panel {
  width: 280px;
  min-width: 240px;
  background: #0f172a;
  border-left: 1px solid #1e293b;
  padding: 1rem 0.75rem;
  overflow-y: auto;
}
.right-panel h3 {
  margin: 0 0 1rem 0;
  font-size: 0.75rem;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  color: #64748b;
}

/* ================= PANEL CONTROLS ================= */
.panel-section {
  margin-bottom: 1.25rem;
  padding-bottom: 1.25rem;
  border-bottom: 1px solid #1e293b;
}
.panel-section:last-child {
  border-bottom: none;
  margin-bottom: 0;
  padding-bottom: 0;
}
.panel-section h4 {
  margin: 0 0 0.75rem 0;
  font-size: 0.875rem;
  color: #e2e8f0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-weight: 600;
}

/* Toggle Switch */
.toggle {
  padding: 0.25rem 0.625rem;
  font-size: 0.7rem;
  font-weight: 700;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s ease;
  background: #1e293b;
  color: #64748b;
  border: 1px solid #334155;
}
.toggle.on {
  background: #22c55e;
  color: #fff;
  border-color: #22c55e;
}
.toggle:hover {
  opacity: 0.9;
}

/* Control Groups */
.control-group {
  margin-bottom: 0.875rem;
}
.control-group:last-child {
  margin-bottom: 0;
}
.control-group label {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 0.8rem;
  color: #94a3b8;
  margin-bottom: 0.5rem;
  font-weight: 500;
}
.control-group label input[type="checkbox"] {
  margin-right: 0.5rem;
}

/* Range Sliders */
input[type="range"] {
  width: 100%;
  height: 6px;
  border-radius: 3px;
  background: #1e293b;
  outline: none;
  -webkit-appearance: none;
}
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: #3b82f6;
  cursor: pointer;
  transition: all 0.2s;
}
input[type="range"]::-webkit-slider-thumb:hover {
  background: #2563eb;
  transform: scale(1.1);
}

/* Color Input */
input[type="color"] {
  width: 100%;
  height: 36px;
  border: 1px solid #334155;
  border-radius: 6px;
  background: #1e293b;
  cursor: pointer;
  padding: 2px;
}

/* Checkbox */
input[type="checkbox"] {
  width: 18px;
  height: 18px;
  accent-color: #3b82f6;
}

/* ================= RESPONSIVE DESIGN ================= */
@media (max-width: 768px) {
  .main-container {
    flex-direction: column;
    height: auto;
  }
  
  .left-panel {
    width: 100%;
    flex-direction: row;
    overflow-x: auto;
    border-right: none;
    border-bottom: 1px solid #1e293b;
    padding: 0.5rem 0.75rem;
    gap: 0.25rem;
  }
  .left-panel h3 {
    display: none;
  }
  .tab-btn {
    padding: 0.5rem 0.6rem;
    font-size: 0.8rem;
    white-space: nowrap;
  }
  
  .center-panel {
    height: 50vh;
    min-height: 300px;
    padding: 0.75rem;
  }
  
  .right-panel {
    width: 100%;
    border-left: none;
    border-top: 1px solid #1e293b;
    max-height: 40vh;
  }
  
  .canvas-toolbar {
    gap: 0.35rem;
  }
  .toolbar-btn {
    padding: 0.5rem 0.75rem;
    font-size: 0.8rem;
  }
}

@media (max-width: 480px) {
  .main-nav {
    gap: 0.8rem;
  }
  .main-nav a {
    font-size: 0.85rem;
  }
}
</style>
<script src="https://sites.super.myninja.ai/_assets/ninja-daytona-script.js"></script>
</head>
<body>

<!-- HEADER -->
<header class="site-header">
  <div class="header-inner">

    <div class="header-left">
      <div class="logo"><a href="index.html">BowesProduct</a></div>
      <nav class="main-nav">
        <a href="index.html">Home</a>
        <a href="models.html">Models</a>
        <a href="retexture.html">Retexture</a>
        <a href="editor.html" class="active">Editor</a>
      </nav>
    </div>

    <div class="header-right">
      <img id="profilePic" alt="Profile">

      <div id="levelInfo">
        <div id="levelText"></div>
        <div id="xpOuter"><div id="xpBar"></div></div>
      </div>

      <button id="authBtn" class="login-btn">Login</button>
    </div>

  </div>
</header>

<!-- MAIN CONTENT -->
<div class="main-container">
  <!-- LEFT PANEL -->
  <aside class="left-panel">
    <h3>Effects</h3>
    <button class="tab-btn active" data-tab="basic">Basic</button>
    <button class="tab-btn" data-tab="color">Color</button>
    <button class="tab-btn" data-tab="blur">Blur</button>
    <button class="tab-btn" data-tab="stylize">Stylize</button>
    <button class="tab-btn" data-tab="artistic">Artistic</button>
    <button class="tab-btn" data-tab="distort">Distort</button>
  </aside>

  <!-- CENTER PANEL -->
  <main class="center-panel">
    <canvas id="canvas"></canvas>
    <div class="canvas-toolbar">
      <input type="file" id="imageInput" accept="image/*" style="display:none;" />
      <button class="toolbar-btn primary" onclick="document.getElementById('imageInput').click()">üìÅ Upload</button>
      <button class="toolbar-btn" id="undoBtn" disabled>‚Ü© Undo</button>
      <button class="toolbar-btn" id="redoBtn" disabled>‚Ü™ Redo</button>
      <button class="toolbar-btn" id="resetBtn" disabled>‚Ü∫ Reset</button>
      <button class="toolbar-btn primary" id="exportBtn" disabled>üíæ Export</button>
    </div>
  </main>

  <!-- RIGHT PANEL -->
  <aside class="right-panel">
    <h3>Controls</h3>
    <div id="panelContent">Select a tab to see controls</div>
  </aside>
</div>

<!-- Firebase SDK -->
<script type="module">
// Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyB4JMVBMcWcN2wKsaVYmnggHH5ue1mUfaA",
  authDomain: "bowesproduct.firebaseapp.com",
  projectId: "bowesproduct"
};

// Import Firebase modules
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js";
import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-auth.js";
import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js";

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const provider = new GoogleAuthProvider();

const authBtn = document.getElementById("authBtn");
const profilePic = document.getElementById("profilePic");
const levelInfo = document.getElementById("levelInfo");
const levelText = document.getElementById("levelText");
const xpBar = document.getElementById("xpBar");

authBtn.onclick = () =>
  auth.currentUser ? signOut(auth) : signInWithPopup(auth, provider);

onAuthStateChanged(auth, async (user) => {
  if (!user) {
    authBtn.textContent = "Login";
    profilePic.style.display = "none";
    levelInfo.style.display = "none";
    return;
  }

  authBtn.textContent = "Logout";
  profilePic.src = user.photoURL || "";
  profilePic.style.display = "block";

  const ref = doc(db, "users", user.uid);
  let snap = await getDoc(ref);

  if (!snap.exists()) {
    await setDoc(ref, { xp: 10 });
    snap = await getDoc(ref);
  }

  const xp = snap.data().xp || 0;
  const levels = [0, 200, 500, 1000, 2000];
  let level = levels.filter(v => xp >= v).length - 1;
  let next = levels[level + 1] ?? levels[level];
  let progress = next === levels[level] ? 100 :
    ((xp - levels[level]) / (next - levels[level])) * 100;

  levelText.textContent = Level ${level} ‚Ä¢ ${xp} XP;
  xpBar.style.width = progress + "%";
  levelInfo.style.display = "block";
});
</script>

<script>
// ================= IMAGE EDITOR ENGINE =================
class ImageEditor {
  constructor() {
    this.canvas = document.getElementById('canvas');
    this.ctx = this.canvas.getContext('2d');
    this.originalImage = null;
    this.isImageLoaded = false;
    this.undoStack = [];
    this.redoStack = [];
    this.maxUndo = 20;
    this.effectDebounceTimer = null;
    
    // Refined adjustments with more realistic default values and ranges
    this.adjustments = {
      brightness: 0,
      contrast: 0,
      exposure: 0,
      sharpen: 0,
      hueRotate: 0,
      saturation: 0,
      lightness: 0,
      temperature: 0,
      tint: 0,
      invert: false,
      grayscale: false,
      sepia: false,
      blur: 0,
      motionAngle: 0,
      motionAmount: 0,
      dropShadow: { enabled: false, x: 10, y: 10, blur: 15, opacity: 30, color: '#000000' },
      innerGlow: { enabled: false, blur: 20, opacity: 30, color: '#60a5fa' },
      outerGlow: { enabled: false, blur: 25, opacity: 40, color: '#60a5fa' },
      vignette: 0,
      coloredPencil: 0,
      cutout: 0,
      dryBrush: 0,
      filmGrain: 0,
      fresco: 0,
      neonGlow: 0,
      paintDaubs: 0,
      posterEdges: 0,
      watercolor: 0,
      ripple: 0,
      twirl: 0,
      wave: 0,
      zigzag: 0,
      glass: 0
    };
    
    // Effect enabled states
    this.effectsEnabled = {
      brightness: true,
      contrast: true,
      exposure: true,
      sharpen: false,
      hsl: true,
      temperature: true,
      basicColor: true,
      blur: false,
      motionBlur: false,
      dropShadow: false,
      innerGlow: false,
      outerGlow: false,
      vignette: false,
      coloredPencil: false,
      cutout: false,
      dryBrush: false,
      filmGrain: false,
      fresco: false,
      neonGlow: false,
      paintDaubs: false,
      posterEdges: false,
      watercolor: false,
      ripple: false,
      twirl: false,
      wave: false,
      zigzag: false,
      glass: false
    };
    
    this.tabs = {
      'basic': this.getBasicControls(),
      'color': this.getColorControls(),
      'blur': this.getBlurControls(),
      'stylize': this.getStylizeControls(),
      'artistic': this.getArtisticControls(),
      'distort': this.getDistortControls()
    };
    
    this.init();
  }
  
  init() {
    this.loadTab('basic');
    this.initEventListeners();
    this.updateButtonStates();
  }
  
  initEventListeners() {
    // Tab buttons
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        this.loadTab(btn.dataset.tab);
      });
    });
    
    // Image upload
    document.getElementById('imageInput').addEventListener('change', (e) => {
      this.loadImage(e.target.files[0]);
    });
    
    // Toolbar buttons
    document.getElementById('undoBtn').addEventListener('click', () => this.undo());
    document.getElementById('redoBtn').addEventListener('click', () => this.redo());
    document.getElementById('resetBtn').addEventListener('click', () => this.reset());
    document.getElementById('exportBtn').addEventListener('click', () => this.exportPNG());
  }
  
  updateButtonStates() {
    const hasImage = this.isImageLoaded;
    document.getElementById('undoBtn').disabled = !hasImage || this.undoStack.length <= 1;
    document.getElementById('redoBtn').disabled = !hasImage || this.redoStack.length === 0;
    document.getElementById('resetBtn').disabled = !hasImage;
    document.getElementById('exportBtn').disabled = !hasImage;
  }
  
  loadImage(file) {
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => {
        this.originalImage = img;
        this.isImageLoaded = true;
        
        // Calculate dimensions to fit within bounds
        const maxW = Math.min(800, window.innerWidth - 40);
        const maxH = Math.min(600, window.innerHeight - 200);
        
        let width = img.width;
        let height = img.height;
        
        if (width > maxW) {
          height = (maxW / width) * height;
          width = maxW;
        }
        if (height > maxH) {
          width = (maxH / height) * width;
          height = maxH;
        }
        
        this.canvas.width = width;
        this.canvas.height = height;
        this.ctx.drawImage(img, 0, 0, width, height);
        
        // Reset stacks
        this.undoStack = [];
        this.redoStack = [];
        this.saveState();
        this.applyEffects();
        this.updateButtonStates();
      };
      img.onerror = () => {
        alert('Failed to load image. Please try another file.');
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  }
  
  saveState() {
    if (this.isImageLoaded) {
      this.undoStack.push(this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height));
      if (this.undoStack.length > this.maxUndo) {
        this.undoStack.shift();
      }
      this.redoStack = [];
      this.updateButtonStates();
    }
  }
  
  undo() {
    if (this.undoStack.length > 1) {
      this.redoStack.push(this.undoStack.pop());
      const data = this.undoStack[this.undoStack.length - 1];
      this.ctx.putImageData(data, 0, 0);
      this.updateButtonStates();
    }
  }
  
  redo() {
    if (this.redoStack.length > 0) {
      const data = this.redoStack.pop();
      this.ctx.putImageData(data, 0, 0);
      this.undoStack.push(data);
      this.updateButtonStates();
    }
  }
  
  reset() {
    if (!this.originalImage) return;
    
    // Reset all adjustments
    this.adjustments = {
      brightness: 0,
      contrast: 0,
      exposure: 0,
      sharpen: 0,
      hueRotate: 0,
      saturation: 0,
      lightness: 0,
      temperature: 0,
      tint: 0,
      invert: false,
      grayscale: false,
      sepia: false,
      blur: 0,
      motionAngle: 0,
      motionAmount: 0,
      dropShadow: { enabled: false, x: 10, y: 10, blur: 15, opacity: 30, color: '#000000' },
      innerGlow: { enabled: false, blur: 20, opacity: 30, color: '#60a5fa' },
      outerGlow: { enabled: false, blur: 25, opacity: 40, color: '#60a5fa' },
      vignette: 0,
      coloredPencil: 0,
      cutout: 0,
      dryBrush: 0,
      filmGrain: 0,
      fresco: 0,
      neonGlow: 0,
      paintDaubs: 0,
      posterEdges: 0,
      watercolor: 0,
      ripple: 0,
      twirl: 0,
      wave: 0,
      zigzag: 0,
      glass: 0
    };
    
    // Reload current tab to update UI
    const activeTab = document.querySelector('.tab-btn.active');
    if (activeTab) {
      this.loadTab(activeTab.dataset.tab);
    }
    
    this.applyEffects();
  }
  
  loadTab(tabName) {
    const content = this.tabs[tabName] || '';
    document.getElementById('panelContent').innerHTML = content;
    this.attachControlListeners();
  }
  
  attachControlListeners() {
    document.querySelectorAll('#panelContent input, #panelContent select').forEach(input => {
      input.addEventListener('input', (e) => this.handleInputChange(e.target));
      input.addEventListener('change', (e) => this.handleInputChange(e.target));
    });
  }
  
  handleInputChange(target) {
    const param = target.dataset.param;
    let value;
    
    if (target.type === 'checkbox') {
      value = target.checked;
    } else if (target.type === 'range' || target.type === 'number') {
      value = parseFloat(target.value);
    } else if (target.type === 'color') {
      value = target.value;
    }
    
    // Update display value
    const valDisplay = document.getElementById(${param}-val);
    if (valDisplay) {
      let displayValue = value;
      if (param.includes('hueRotate') || param.includes('Angle')) displayValue += '¬∞';
      else if (param.includes('saturation') || param.includes('lightness') || param.includes('opacity')) displayValue += '%';
      else if (param.includes('blur') || param.includes('Blur')) displayValue += 'px';
      valDisplay.textContent = displayValue;
    }
    
    // Store adjustment
    if (param.includes('-')) {
      const [section, subParam] = param.split('-');
      if (!this.adjustments[section]) {
        this.adjustments[section] = {};
      }
      this.adjustments[section][subParam] = value;
    } else {
      this.adjustments[param] = value;
    }
    
    // Debounced effect application for smoother performance
    clearTimeout(this.effectDebounceTimer);
    this.effectDebounceTimer = setTimeout(() => {
      this.applyEffects();
    }, 16);
  }
  
  toggleEffect(effectName) {
    this.effectsEnabled[effectName] = !this.effectsEnabled[effectName];
    this.updateToggleUI(effectName);
    this.applyEffects();
  }
  
  updateToggleUI(effectName) {
    const toggle = document.querySelector([data-effect="${effectName}"]);
    if (toggle) {
      if (this.effectsEnabled[effectName]) {
        toggle.classList.add('on');
        toggle.textContent = 'ON';
      } else {
        toggle.classList.remove('on');
        toggle.textContent = 'OFF';
      }
    }
  }
  
  getBasicControls() {
    return `
      <div class="panel-section">
        <h4>Brightness <span class="toggle ${this.effectsEnabled.brightness ? 'on' : ''}" data-effect="brightness" onclick="editor.toggleEffect('brightness')">ON</span></h4>
        <div class="control-group">
          <label>Amount <span id="brightness-val">${this.adjustments.brightness}</span></label>
          <input type="range" min="-50" max="50" value="${this.adjustments.brightness}" data-param="brightness" step="1" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Contrast <span class="toggle ${this.effectsEnabled.contrast ? 'on' : ''}" data-effect="contrast" onclick="editor.toggleEffect('contrast')">ON</span></h4>
        <div class="control-group">
          <label>Amount <span id="contrast-val">${this.adjustments.contrast}</span></label>
          <input type="range" min="-50" max="50" value="${this.adjustments.contrast}" data-param="contrast" step="1" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Exposure <span class="toggle ${this.effectsEnabled.exposure ? 'on' : ''}" data-effect="exposure" onclick="editor.toggleEffect('exposure')">ON</span></h4>
        <div class="control-group">
          <label>Amount <span id="exposure-val">${this.adjustments.exposure}</span></label>
          <input type="range" min="-2" max="2" step="0.1" value="${this.adjustments.exposure}" data-param="exposure" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Sharpen <span class="toggle ${this.effectsEnabled.sharpen ? 'on' : ''}" data-effect="sharpen" onclick="editor.toggleEffect('sharpen')">OFF</span></h4>
        <div class="control-group">
          <label>Amount <span id="sharpen-val">${this.adjustments.sharpen}</span></label>
          <input type="range" min="0" max="50" value="${this.adjustments.sharpen}" data-param="sharpen" step="1" />
        </div>
      </div>
    `;
  }
  
  getColorControls() {
    return `
      <div class="panel-section">
        <h4>Hue/Sat/Light <span class="toggle ${this.effectsEnabled.hsl ? 'on' : ''}" data-effect="hsl" onclick="editor.toggleEffect('hsl')">ON</span></h4>
        <div class="control-group">
          <label>Hue <span id="hueRotate-val">${this.adjustments.hueRotate}¬∞</span></label>
          <input type="range" min="-180" max="180" value="${this.adjustments.hueRotate}" data-param="hueRotate" step="1" />
        </div>
        <div class="control-group">
          <label>Saturation <span id="saturation-val">${this.adjustments.saturation}%</span></label>
          <input type="range" min="-100" max="100" value="${this.adjustments.saturation}" data-param="saturation" step="1" />
        </div>
        <div class="control-group">
          <label>Lightness <span id="lightness-val">${this.adjustments.lightness}%</span></label>
          <input type="range" min="-30" max="30" value="${this.adjustments.lightness}" data-param="lightness" step="1" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Temperature <span class="toggle ${this.effectsEnabled.temperature ? 'on' : ''}" data-effect="temperature" onclick="editor.toggleEffect('temperature')">ON</span></h4>
        <div class="control-group">
          <label>Warmth <span id="temperature-val">${this.adjustments.temperature}</span></label>
          <input type="range" min="-50" max="50" value="${this.adjustments.temperature}" data-param="temperature" step="1" />
        </div>
        <div class="control-group">
          <label>Tint <span id="tint-val">${this.adjustments.tint}</span></label>
          <input type="range" min="-50" max="50" value="${this.adjustments.tint}" data-param="tint" step="1" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Basic Color <span class="toggle ${this.effectsEnabled.basicColor ? 'on' : ''}" data-effect="basicColor" onclick="editor.toggleEffect('basicColor')">ON</span></h4>
        <div class="control-group">
          <label><input type="checkbox" ${this.adjustments.invert ? 'checked' : ''} data-param="invert" /> Invert</label>
        </div>
        <div class="control-group">
          <label><input type="checkbox" ${this.adjustments.grayscale ? 'checked' : ''} data-param="grayscale" /> Grayscale</label>
        </div>
        <div class="control-group">
          <label><input type="checkbox" ${this.adjustments.sepia ? 'checked' : ''} data-param="sepia" /> Sepia</label>
        </div>
      </div>
    `;
  }
  
  getBlurControls() {
    return `
      <div class="panel-section">
        <h4>Blur <span class="toggle ${this.effectsEnabled.blur ? 'on' : ''}" data-effect="blur" onclick="editor.toggleEffect('blur')">OFF</span></h4>
        <div class="control-group">
          <label>Radius <span id="blur-val">${this.adjustments.blur}px</span></label>
          <input type="range" min="0" max="20" value="${this.adjustments.blur}" data-param="blur" step="0.5" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Motion Blur <span class="toggle ${this.effectsEnabled.motionBlur ? 'on' : ''}" data-effect="motionBlur" onclick="editor.toggleEffect('motionBlur')">OFF</span></h4>
        <div class="control-group">
          <label>Angle <span id="motionAngle-val">${this.adjustments.motionAngle}¬∞</span></label>
          <input type="range" min="0" max="360" value="${this.adjustments.motionAngle}" data-param="motionAngle" step="1" />
        </div>
        <div class="control-group">
          <label>Amount <span id="motionAmount-val">${this.adjustments.motionAmount}</span></label>
          <input type="range" min="0" max="30" value="${this.adjustments.motionAmount}" data-param="motionAmount" step="1" />
        </div>
      </div>
    `;
  }
  
  getStylizeControls() {
    return `
      <div class="panel-section">
        <h4>Drop Shadow <span class="toggle ${this.effectsEnabled.dropShadow ? 'on' : ''}" data-effect="dropShadow" onclick="editor.toggleEffect('dropShadow')">OFF</span></h4>
        <div class="control-group">
          <label>X Offset <span id="dropShadow-x-val">${this.adjustments.dropShadow.x}</span></label>
          <input type="range" min="-30" max="30" value="${this.adjustments.dropShadow.x}" data-param="dropShadow-x" step="1" />
        </div>
        <div class="control-group">
          <label>Y Offset <span id="dropShadow-y-val">${this.adjustments.dropShadow.y}</span></label>
          <input type="range" min="-30" max="30" value="${this.adjustments.dropShadow.y}" data-param="dropShadow-y" step="1" />
        </div>
        <div class="control-group">
          <label>Blur <span id="dropShadow-blur-val">${this.adjustments.dropShadow.blur}px</span></label>
          <input type="range" min="0" max="40" value="${this.adjustments.dropShadow.blur}" data-param="dropShadow-blur" step="1" />
        </div>
        <div class="control-group">
          <label>Opacity <span id="dropShadow-opacity-val">${this.adjustments.dropShadow.opacity}%</span></label>
          <input type="range" min="0" max="100" value="${this.adjustments.dropShadow.opacity}" data-param="dropShadow-opacity" step="1" />
        </div>
        <div class="control-group">
          <label>Color</label>
          <input type="color" value="${this.adjustments.dropShadow.color}" data-param="dropShadow-color" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Inner Glow <span class="toggle ${this.effectsEnabled.innerGlow ? 'on' : ''}" data-effect="innerGlow" onclick="editor.toggleEffect('innerGlow')">OFF</span></h4>
        <div class="control-group">
          <label>Blur <span id="innerGlow-blur-val">${this.adjustments.innerGlow.blur}px</span></label>
          <input type="range" min="1" max="50" value="${this.adjustments.innerGlow.blur}" data-param="innerGlow-blur" step="1" />
        </div>
        <div class="control-group">
          <label>Opacity <span id="innerGlow-opacity-val">${this.adjustments.innerGlow.opacity}%</span></label>
          <input type="range" min="0" max="100" value="${this.adjustments.innerGlow.opacity}" data-param="innerGlow-opacity" step="1" />
        </div>
        <div class="control-group">
          <label>Color</label>
          <input type="color" value="${this.adjustments.innerGlow.color}" data-param="innerGlow-color" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Outer Glow <span class="toggle ${this.effectsEnabled.outerGlow ? 'on' : ''}" data-effect="outerGlow" onclick="editor.toggleEffect('outerGlow')">OFF</span></h4>
        <div class="control-group">
          <label>Blur <span id="outerGlow-blur-val">${this.adjustments.outerGlow.blur}px</span></label>
          <input type="range" min="1" max="60" value="${this.adjustments.outerGlow.blur}" data-param="outerGlow-blur" step="1" />
        </div>
        <div class="control-group">
          <label>Opacity <span id="outerGlow-opacity-val">${this.adjustments.outerGlow.opacity}%</span></label>
          <input type="range" min="0" max="100" value="${this.adjustments.outerGlow.opacity}" data-param="outerGlow-opacity" step="1" />
        </div>
        <div class="control-group">
          <label>Color</label>
          <input type="color" value="${this.adjustments.outerGlow.color}" data-param="outerGlow-color" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Vignette <span class="toggle ${this.effectsEnabled.vignette ? 'on' : ''}" data-effect="vignette" onclick="editor.toggleEffect('vignette')">OFF</span></h4>
        <div class="control-group">
          <label>Strength <span id="vignette-val">${this.adjustments.vignette}</span></label>
          <input type="range" min="0" max="80" value="${this.adjustments.vignette}" data-param="vignette" step="1" />
        </div>
      </div>
    `;
  }
  
  getArtisticControls() {
    const effects = [
      { key: 'coloredPencil', label: 'Colored Pencil' },
      { key: 'cutout', label: 'Cutout' },
      { key: 'dryBrush', label: 'Dry Brush' },
      { key: 'filmGrain', label: 'Film Grain' },
      { key: 'fresco', label: 'Fresco' },
      { key: 'neonGlow', label: 'Neon Glow' },
      { key: 'paintDaubs', label: 'Paint Daubs' },
      { key: 'posterEdges', label: 'Poster Edges' },
      { key: 'watercolor', label: 'Watercolor' }
    ];
    
    let html = '';
    effects.forEach(effect => {
      const value = this.adjustments[effect.key];
      const enabled = this.effectsEnabled[effect.key];
      html += `
        <div class="panel-section">
          <h4>${effect.label} <span class="toggle ${enabled ? 'on' : ''}" data-effect="${effect.key}" onclick="editor.toggleEffect('${effect.key}')">OFF</span></h4>
          <div class="control-group">
            <label>Intensity <span id="${effect.key}-val">${value}</span></label>
            <input type="range" min="0" max="100" value="${value}" data-param="${effect.key}" step="1" />
          </div>
        </div>
      `;
    });
    return html;
  }
  
  getDistortControls() {
    const effects = [
      { key: 'ripple', label: 'Ripple' },
      { key: 'twirl', label: 'Twirl' },
      { key: 'wave', label: 'Wave' },
      { key: 'zigzag', label: 'Zigzag' },
      { key: 'glass', label: 'Glass' }
    ];
    
    let html = '';
    effects.forEach(effect => {
      const value = this.adjustments[effect.key];
      const enabled = this.effectsEnabled[effect.key];
      html += `
        <div class="panel-section">
          <h4>${effect.label} <span class="toggle ${enabled ? 'on' : ''}" data-effect="${effect.key}" onclick="editor.toggleEffect('${effect.key}')">OFF</span></h4>
          <div class="control-group">
            <label>Amount <span id="${effect.key}-val">${value}</span></label>
            <input type="range" min="0" max="100" value="${value}" data-param="${effect.key}" step="1" />
          </div>
        </div>
      `;
    });
    return html;
  }
  
  exportPNG() {
    if (!this.isImageLoaded) return;
    
    // Create a temporary canvas to export with current effects
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = this.canvas.width;
    tempCanvas.height = this.canvas.height;
    const tempCtx = tempCanvas.getContext('2d');
    
    // Copy current canvas content
    tempCtx.drawImage(this.canvas, 0, 0);
    
    // Create download link
    const link = document.createElement('a');
    link.download = 'bowesproduct-edited.png';
    link.href = tempCanvas.toDataURL('image/png');
    link.click();
  }
  
  applyEffects() {
    if (!this.isImageLoaded || !this.originalImage) return;
    
    // Clear and draw original image
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Build filter string
    let filters = '';
    
    // Basic adjustments - refined for more natural results
    if (this.effectsEnabled.brightness) {
      const brightness = 1 + (this.adjustments.brightness / 200);
      filters +=  brightness(${brightness.toFixed(2)});
    }
    
    if (this.effectsEnabled.contrast) {
      const contrast = 1 + (this.adjustments.contrast / 200);
      filters +=  contrast(${contrast.toFixed(2)});
    }
    
    if (this.effectsEnabled.exposure) {
      const exposure = 1 + (this.adjustments.exposure / 20);
      filters +=  brightness(${exposure.toFixed(2)});
    }
    
    // Color adjustments - centered at 0 for more intuitive controls
    if (this.effectsEnabled.hsl) {
      filters +=  hue-rotate(${this.adjustments.hueRotate}deg);
      const sat = 1 + (this.adjustments.saturation / 100);
      filters +=  saturate(${Math.max(0, sat).toFixed(2)});
      const light = 1 + (this.adjustments.lightness / 100);
      filters +=  brightness(${Math.max(0, light).toFixed(2)});
    }
    
    if (this.effectsEnabled.basicColor) {
      if (this.adjustments.invert) {
        filters +=  invert(100%);
      }
      if (this.adjustments.grayscale) {
        filters +=  grayscale(100%);
      }
      if (this.adjustments.sepia) {
        filters +=  sepia(100%);
      }
    }
    
    // Blur
    if (this.effectsEnabled.blur && this.adjustments.blur > 0) {
      filters +=  blur(${this.adjustments.blur}px);
    }
    
    // Apply filter
    this.ctx.filter = filters || 'none';
    this.ctx.drawImage(this.originalImage, 0, 0, this.canvas.width, this.canvas.height);
    this.ctx.filter = 'none';
    
    // Apply temperature/tint overlay - more subtle and realistic
    if (this.effectsEnabled.temperature && (this.adjustments.temperature !== 0 || this.adjustments.tint !== 0)) {
      const temp = this.adjustments.temperature / 100;
      const tint = this.adjustments.tint / 100;
      
      this.ctx.save();
      this.ctx.globalCompositeOperation = 'soft-light';
      this.ctx.globalAlpha = Math.min(0.3, Math.abs(temp) + Math.abs(tint));
      
      if (temp > 0) {
        this.ctx.fillStyle = rgba(255, 180, 120, ${temp});
      } else if (temp < 0) {
        this.ctx.fillStyle = rgba(120, 180, 255, ${Math.abs(temp)});
      }
      
      if (tint > 0) {
        this.ctx.fillStyle = rgba(180, 255, 180, ${tint});
      } else if (tint < 0) {
        this.ctx.fillStyle = rgba(255, 180, 180, ${Math.abs(tint)});
      }
      
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      this.ctx.restore();
    }
    
    // Apply motion blur
    if (this.effectsEnabled.motionBlur && this.adjustments.motionAmount > 0) {
      this.applyMotionBlur(this.adjustments.motionAmount, this.adjustments.motionAngle);
    }
    
    // Apply drop shadow - improved to not look like a box
    if (this.effectsEnabled.dropShadow) {
      this.applyDropShadow();
    }
    
    // Apply inner glow - completely rewritten for proper effect
    if (this.effectsEnabled.innerGlow) {
      this.applyInnerGlow();
    }
    
    // Apply outer glow - completely rewritten for proper effect
    if (this.effectsEnabled.outerGlow) {
      this.applyOuterGlow();
    }
    
    // Apply vignette - more subtle and professional
    if (this.effectsEnabled.vignette && this.adjustments.vignette > 0) {
      this.applyVignette();
    }
    
    // Apply film grain - more natural and subtle
    if (this.effectsEnabled.filmGrain && this.adjustments.filmGrain > 0) {
      this.applyFilmGrain();
    }
    
    // Apply sharpen - improved algorithm
    if (this.effectsEnabled.sharpen && this.adjustments.sharpen > 0) {
      this.applySharpen();
    }
    
    // Apply artistic effects
    this.applyArtisticEffects();
    
    // Apply distort effects
    this.applyDistortEffects();
  }
  
  applyMotionBlur(amount, angle) {
    const radians = angle * Math.PI / 180;
    const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
    const data = imageData.data;
    const output = this.ctx.createImageData(this.canvas.width, this.canvas.height);
    const outputData = output.data;
    const width = this.canvas.width;
    const height = this.canvas.height;
    
    const dx = Math.cos(radians) * amount;
    const dy = Math.sin(radians) * amount;
    
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let r = 0, g = 0, b = 0, a = 0;
        let count = 0;
        
        for (let i = -Math.floor(amount); i <= Math.floor(amount); i++) {
          const srcX = Math.round(x + (dx / amount) * i);
          const srcY = Math.round(y + (dy / amount) * i);
          
          if (srcX >= 0 && srcX < width && srcY >= 0 && srcY < height) {
            const offset = (srcY * width + srcX) * 4;
            r += data[offset];
            g += data[offset + 1];
            b += data[offset + 2];
            a += data[offset + 3];
            count++;
          }
        }
        
        const dstOffset = (y * width + x) * 4;
        outputData[dstOffset] = r / count;
        outputData[dstOffset + 1] = g / count;
        outputData[dstOffset + 2] = b / count;
        outputData[dstOffset + 3] = a / count;
      }
    }
    
    this.ctx.putImageData(output, 0, 0);
  }
  
  applyDropShadow() {
    const shadow = this.adjustments.dropShadow;
    
    // Create a temporary canvas for the shadow
    const shadowCanvas = document.createElement('canvas');
    shadowCanvas.width = this.canvas.width;
    shadowCanvas.height = this.canvas.height;
    const shadowCtx = shadowCanvas.getContext('2d');
    
    // Draw the current canvas to get the image content
    shadowCtx.drawImage(this.canvas, 0, 0);
    
    // Apply Gaussian-like blur to shadow
    shadowCtx.filter = blur(${shadow.blur}px);
    shadowCtx.globalAlpha = shadow.opacity / 100;
    shadowCtx.fillStyle = shadow.color;
    shadowCtx.fillRect(shadow.x, shadow.y, this.canvas.width, this.canvas.height);
    shadowCtx.filter = 'none';
    
    // Draw the shadow behind the original image using proper composite
    this.ctx.save();
    this.ctx.drawImage(shadowCanvas, 0, 0);
    this.ctx.restore();
  }
  
  applyInnerGlow() {
    const glow = this.adjustments.innerGlow;
    
    // Create a gradient for inner glow effect
    const gradient = this.ctx.createRadialGradient(
      this.canvas.width / 2, this.canvas.height / 2, Math.min(this.canvas.width, this.canvas.height) / 3,
      this.canvas.width / 2, this.canvas.height / 2, Math.max(this.canvas.width, this.canvas.height) / 1.5
    );
    
    // Parse color
    const hex = glow.color;
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    
    gradient.addColorStop(0, rgba(${r}, ${g}, ${b}, 0));
    gradient.addColorStop(0.7, rgba(${r}, ${g}, ${b}, ${glow.opacity / 200}));
    gradient.addColorStop(1, rgba(${r}, ${g}, ${b}, ${glow.opacity / 100}));
    
    this.ctx.save();
    this.ctx.globalCompositeOperation = 'overlay';
    this.ctx.fillStyle = gradient;
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.restore();
  }
  
  applyOuterGlow() {
    const glow = this.adjustments.outerGlow;
    
    // Create a larger canvas for the glow
    const glowCanvas = document.createElement('canvas');
    const padding = glow.blur;
    glowCanvas.width = this.canvas.width + padding * 2;
    glowCanvas.height = this.canvas.height + padding * 2;
    const glowCtx = glowCanvas.getContext('2d');
    
    // Draw a blurred version of the image
    glowCtx.filter = blur(${glow.blur}px);
    glowCtx.globalAlpha = glow.opacity / 100;
    
    // Parse color
    const hex = glow.color;
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    
    glowCtx.fillStyle = rgba(${r}, ${g}, ${b}, 1);
    glowCtx.fillRect(padding, padding, this.canvas.width, this.canvas.height);
    glowCtx.filter = 'none';
    
    // Composite the glow onto the main canvas
    this.ctx.save();
    this.ctx.globalCompositeOperation = 'screen';
    this.ctx.drawImage(glowCanvas, -padding, -padding);
    this.ctx.restore();
  }
  
  applyVignette() {
    const strength = this.adjustments.vignette / 100;
    const centerX = this.canvas.width / 2;
    const centerY = this.canvas.height / 2;
    const maxRadius = Math.sqrt(centerX * centerX + centerY * centerY) * 0.85;
    const innerRadius = maxRadius * 0.5;
    
    const gradient = this.ctx.createRadialGradient(
      centerX, centerY, innerRadius,
      centerX, centerY, maxRadius
    );
    
    gradient.addColorStop(0, 'rgba(0,0,0,0)');
    gradient.addColorStop(0.5, 'rgba(0,0,0,0)');
    gradient.addColorStop(1, rgba(0,0,0,${strength * 0.8}));
    
    this.ctx.save();
    this.ctx.globalCompositeOperation = 'multiply';
    this.ctx.fillStyle = gradient;
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.restore();
  }
  
  applyFilmGrain() {
    const intensity = this.adjustments.filmGrain / 100;
    const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
    const data = imageData.data;
    
    for (let i = 0; i < data.length; i += 4) {
      // More natural film grain with slight color variation
      const noise = (Math.random() - 0.5) * intensity * 50;
      const colorNoise = (Math.random() - 0.5) * intensity * 10;
      
      data[i] = Math.max(0, Math.min(255, data[i] + noise + colorNoise));
      data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise - colorNoise));
      data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise + colorNoise));
    }
    
    this.ctx.putImageData(imageData, 0, 0);
  }
  
  applySharpen() {
    const strength = this.adjustments.sharpen / 100;
    
    // Improved sharpening kernel
    const kernel = [
      0, -1 * strength, 0,
      -1 * strength, 1 + 4 * strength, -1 * strength,
      0, -1 * strength, 0
    ];
    
    this.applyConvolution(kernel);
  }
  
  applyConvolution(kernel) {
    if (!this.isImageLoaded) return;
    
    const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
    const data = imageData.data;
    const width = this.canvas.width;
    const height = this.canvas.height;
    const output = this.ctx.createImageData(width, height);
    const outputData = output.data;
    
    const side = Math.round(Math.sqrt(kernel.length));
    const halfSide = Math.floor(side / 2);
    
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let r = 0, g = 0, b = 0;
        
        for (let cy = 0; cy < side; cy++) {
          for (let cx = 0; cx < side; cx++) {
            const scy = y + cy - halfSide;
            const scx = x + cx - halfSide;
            
            if (scy >= 0 && scy < height && scx >= 0 && scx < width) {
              const srcOffset = (scy * width + scx) * 4;
              const wt = kernel[cy * side + cx];
              
              r += data[srcOffset] * wt;
              g += data[srcOffset + 1] * wt;
              b += data[srcOffset + 2] * wt;
            }
          }
        }
        
        const offset = (y * width + x) * 4;
        outputData[offset] = Math.max(0, Math.min(255, r));
        outputData[offset + 1] = Math.max(0, Math.min(255, g));
        outputData[offset + 2] = Math.max(0, Math.min(255, b));
        outputData[offset + 3] = data[offset + 3];
      }
    }
    
    this.ctx.putImageData(output, 0, 0);
  }
  
  applyArtisticEffects() {
    // Colored Pencil - more subtle
    if (this.effectsEnabled.coloredPencil && this.adjustments.coloredPencil > 0) {
      const intensity = this.adjustments.coloredPencil / 100;
      const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      const data = imageData.data;
      
      for (let i = 0; i < data.length; i += 4) {
        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
        const blend = intensity * 0.3;
        data[i] = data[i] * (1 - blend) + avg * blend;
        data[i + 1] = data[i + 1] * (1 - blend) + avg * blend;
        data[i + 2] = data[i + 2] * (1 - blend) + avg * blend;
      }
      
      this.ctx.putImageData(imageData, 0, 0);
    }
    
    // Poster Edges - improved algorithm
    if (this.effectsEnabled.posterEdges && this.adjustments.posterEdges > 0) {
      const intensity = this.adjustments.posterEdges / 100;
      const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      const data = imageData.data;
      const width = this.canvas.width;
      const height = this.canvas.height;
      const output = this.ctx.createImageData(width, height);
      const outputData = output.data;
      
      // Copy original data
      outputData.set(data);
      
      const threshold = 50 - intensity * 40;
      
      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          const offset = (y * width + x) * 4;
          
          let maxDiff = 0;
          
          // Check neighbors for edges
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              if (dx === 0 && dy === 0) continue;
              
              const neighborOffset = ((y + dy) * width + (x + dx)) * 4;
              const diff = Math.abs(data[offset] - data[neighborOffset]) +
                           Math.abs(data[offset + 1] - data[neighborOffset + 1]) +
                           Math.abs(data[offset + 2] - data[neighborOffset + 2]);
              
              maxDiff = Math.max(maxDiff, diff / 3);
            }
          }
          
          if (maxDiff > threshold) {
            const darkness = (maxDiff - threshold) / (255 - threshold) * intensity;
            outputData[offset] = Math.max(0, data[offset] * (1 - darkness));
            outputData[offset + 1] = Math.max(0, data[offset + 1] * (1 - darkness));
            outputData[offset + 2] = Math.max(0, data[offset + 2] * (1 - darkness));
          }
        }
      }
      
      this.ctx.putImageData(output, 0, 0);
    }
    
    // Watercolor - more natural
    if (this.effectsEnabled.watercolor && this.adjustments.watercolor > 0) {
      const intensity = this.adjustments.watercolor / 100;
      // Box blur kernel for watercolor effect
      const kernelSize = Math.max(3, Math.floor(3 + intensity * 5));
      const kernel = Array(kernelSize * kernelSize).fill(1 / (kernelSize * kernelSize));
      this.applyConvolution(kernel);
    }
    
    // Neon Glow - improved
    if (this.effectsEnabled.neonGlow && this.adjustments.neonGlow > 0) {
      const intensity = this.adjustments.neonGlow / 100;
      const blurRadius = 5 + intensity * 15;
      
      // Create blurred copy
      const blurCanvas = document.createElement('canvas');
      blurCanvas.width = this.canvas.width;
      blurCanvas.height = this.canvas.height;
      const blurCtx = blurCanvas.getContext('2d');
      blurCtx.filter = blur(${blurRadius}px);
      blurCtx.drawImage(this.canvas, 0, 0);
      
      // Screen blend for neon effect
      this.ctx.save();
      this.ctx.globalCompositeOperation = 'screen';
      this.ctx.globalAlpha = intensity * 0.7;
      this.ctx.drawImage(blurCanvas, 0, 0);
      this.ctx.restore();
    }
    
    // Cutout (posterization) - improved levels
    if (this.effectsEnabled.cutout && this.adjustments.cutout > 0) {
      const intensity = this.adjustments.cutout / 100;
      const levels = Math.max(2, Math.round(8 - intensity * 6));
      const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      const data = imageData.data;
      const step = 256 / levels;
      
      for (let i = 0; i < data.length; i += 4) {
        data[i] = Math.round(data[i] / step) * step;
        data[i + 1] = Math.round(data[i + 1] / step) * step;
        data[i + 2] = Math.round(data[i + 2] / step) * step;
      }
      
      this.ctx.putImageData(imageData, 0, 0);
    }
    
    // Paint Daubs - more natural
    if (this.effectsEnabled.paintDaubs && this.adjustments.paintDaubs > 0) {
      const intensity = this.adjustments.paintDaubs / 100;
      const radius = Math.max(2, Math.floor(2 + intensity * 4));
      const kernel = Array(radius * radius).fill(1 / (radius * radius));
      this.applyConvolution(kernel);
    }
    
    // Dry Brush - improved
    if (this.effectsEnabled.dryBrush && this.adjustments.dryBrush > 0) {
      const intensity = this.adjustments.dryBrush / 100;
      const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      const data = imageData.data;
      const factor = 1 - intensity * 0.3;
      
      for (let i = 0; i < data.length; i += 4) {
        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
        const blend = intensity * 0.4;
        data[i] = data[i] * (1 - blend) + avg * blend;
        data[i + 1] = data[i + 1] * (1 - blend) + avg * blend;
        data[i + 2] = data[i + 2] * (1 - blend) + avg * blend;
        
        // Reduce detail
        data[i] = Math.round(data[i] / (256 / 16)) * (256 / 16);
        data[i + 1] = Math.round(data[i + 1] / (256 / 16)) * (256 / 16);
        data[i + 2] = Math.round(data[i + 2] / (256 / 16)) * (256 / 16);
      }
      
      this.ctx.putImageData(imageData, 0, 0);
    }
    
    // Fresco - improved
    if (this.effectsEnabled.fresco && this.adjustments.fresco > 0) {
      const intensity = this.adjustments.fresco / 100;
      const levels = Math.max(4, Math.round(12 - intensity * 8));
      const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      const data = imageData.data;
      const step = 256 / levels;
      
      // Posterize
      for (let i = 0; i < data.length; i += 4) {
        data[i] = Math.round(data[i] / step) * step;
        data[i + 1] = Math.round(data[i + 1] / step) * step;
        data[i + 2] = Math.round(data[i + 2] / step) * step;
      }
      
      this.ctx.putImageData(imageData, 0, 0);
      
      // Apply subtle blur
      if (intensity > 0.2) {
        const kernelSize = Math.max(3, Math.floor(2 + intensity * 3));
        const kernel = Array(kernelSize * kernelSize).fill(1 / (kernelSize * kernelSize));
        this.applyConvolution(kernel);
      }
    }
  }
  
  applyDistortEffects() {
    // Ripple - more subtle
    if (this.effectsEnabled.ripple && this.adjustments.ripple > 0) {
      const amount = this.adjustments.ripple / 5;
      const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      const output = this.ctx.createImageData(this.canvas.width, this.canvas.height);
      
      for (let y = 0; y < this.canvas.height; y++) {
        for (let x = 0; x < this.canvas.width; x++) {
          const dx = x - this.canvas.width / 2;
          const dy = y - this.canvas.height / 2;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx);
          
          const offset = Math.sin(distance / 25) * amount;
          const newX = Math.round(this.canvas.width / 2 + Math.cos(angle + offset * 0.01) * distance);
          const newY = Math.round(this.canvas.height / 2 + Math.sin(angle + offset * 0.01) * distance);
          
          const srcOffset = (y * this.canvas.width + x) * 4;
          
          if (newX >= 0 && newX < this.canvas.width && newY >= 0 && newY < this.canvas.height) {
            const dstOffset = (newY * this.canvas.width + newX) * 4;
            output.data[srcOffset] = imageData.data[dstOffset];
            output.data[srcOffset + 1] = imageData.data[dstOffset + 1];
            output.data[srcOffset + 2] = imageData.data[dstOffset + 2];
            output.data[srcOffset + 3] = imageData.data[dstOffset + 3];
          } else {
            output.data[srcOffset] = imageData.data[srcOffset];
            output.data[srcOffset + 1] = imageData.data[srcOffset + 1];
            output.data[srcOffset + 2] = imageData.data[srcOffset + 2];
            output.data[srcOffset + 3] = imageData.data[srcOffset + 3];
          }
        }
      }
      
      this.ctx.putImageData(output, 0, 0);
    }
    
    // Wave - more subtle
    if (this.effectsEnabled.wave && this.adjustments.wave > 0) {
      const amount = this.adjustments.wave / 20;
      const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      const output = this.ctx.createImageData(this.canvas.width, this.canvas.height);
      
      for (let y = 0; y < this.canvas.height; y++) {
        for (let x = 0; x < this.canvas.width; x++) {
          const offsetX = Math.round(Math.sin(y / 30) * amount);
          const newX = Math.min(this.canvas.width - 1, Math.max(0, x + offsetX));
          
          const srcOffset = (y * this.canvas.width + x) * 4;
          const dstOffset = (y * this.canvas.width + newX) * 4;
          
          output.data[srcOffset] = imageData.data[dstOffset];
          output.data[srcOffset + 1] = imageData.data[dstOffset + 1];
          output.data[srcOffset + 2] = imageData.data[dstOffset + 2];
          output.data[srcOffset + 3] = imageData.data[dstOffset + 3];
        }
      }
      
      this.ctx.putImageData(output, 0, 0);
    }
    
    // Twirl - more subtle and centered
    if (this.effectsEnabled.twirl && this.adjustments.twirl > 0) {
      const amount = this.adjustments.twirl / 2000;
      const maxRadius = Math.min(this.canvas.width, this.canvas.height) / 4;
      const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      const output = this.ctx.createImageData(this.canvas.width, this.canvas.height);
      
      for (let y = 0; y < this.canvas.height; y++) {
        for (let x = 0; x < this.canvas.width; x++) {
          const dx = x - this.canvas.width / 2;
          const dy = y - this.canvas.height / 2;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          let newX = x;
          let newY = y;
          
          if (distance < maxRadius && distance > 0) {
            const angle = Math.atan2(dy, dx);
            const falloff = (maxRadius - distance) / maxRadius;
            const twistAngle = angle + amount * falloff * distance;
            newX = Math.round(this.canvas.width / 2 + Math.cos(twistAngle) * distance);
            newY = Math.round(this.canvas.height / 2 + Math.sin(twistAngle) * distance);
          }
          
          const srcOffset = (y * this.canvas.width + x) * 4;
          
          if (newX >= 0 && newX < this.canvas.width && newY >= 0 && newY < this.canvas.height) {
            const dstOffset = (newY * this.canvas.width + newX) * 4;
            output.data[srcOffset] = imageData.data[dstOffset];
            output.data[srcOffset + 1] = imageData.data[dstOffset + 1];
            output.data[srcOffset + 2] = imageData.data[dstOffset + 2];
            output.data[srcOffset + 3] = imageData.data[dstOffset + 3];
          } else {
            output.data[srcOffset] = imageData.data[srcOffset];
            output.data[srcOffset + 1] = imageData.data[srcOffset + 1];
            output.data[srcOffset + 2] = imageData.data[srcOffset + 2];
            output.data[srcOffset + 3] = imageData.data[srcOffset + 3];
          }
        }
      }
      
      this.ctx.putImageData(output, 0, 0);
    }
    
    // Zigzag - more subtle
    if (this.effectsEnabled.zigzag && this.adjustments.zigzag > 0) {
      const amount = this.adjustments.zigzag / 10;
      const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      const output = this.ctx.createImageData(this.canvas.width, this.canvas.height);
      
      for (let y = 0; y < this.canvas.height; y++) {
        for (let x = 0; x < this.canvas.width; x++) {
          const dx = x - this.canvas.width / 2;
          const dy = y - this.canvas.height / 2;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx);
          
          const radiusMod = Math.sin(distance / 30) * amount * 0.5;
          const newX = Math.round(this.canvas.width / 2 + Math.cos(angle) * (distance + radiusMod));
          const newY = Math.round(this.canvas.height / 2 + Math.sin(angle) * (distance + radiusMod));
          
          const srcOffset = (y * this.canvas.width + x) * 4;
          
          if (newX >= 0 && newX < this.canvas.width && newY >= 0 && newY < this.canvas.height) {
            const dstOffset = (newY * this.canvas.width + newX) * 4;
            output.data[srcOffset] = imageData.data[dstOffset];
            output.data[srcOffset + 1] = imageData.data[dstOffset + 1];
            output.data[srcOffset + 2] = imageData.data[dstOffset + 2];
            output.data[srcOffset + 3] = imageData.data[dstOffset + 3];
          } else {
            output.data[srcOffset] = imageData.data[srcOffset];
            output.data[srcOffset + 1] = imageData.data[srcOffset + 1];
            output.data[srcOffset + 2] = imageData.data[srcOffset + 2];
            output.data[srcOffset + 3] = imageData.data[srcOffset + 3];
          }
        }
      }
      
      this.ctx.putImageData(output, 0, 0);
    }
    
    // Glass - more subtle
    if (this.effectsEnabled.glass && this.adjustments.glass > 0) {
      const amount = Math.max(1, Math.round(this.adjustments.glass / 10));
      const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      const output = this.ctx.createImageData(this.canvas.width, this.canvas.height);
      
      for (let y = 0; y < this.canvas.height; y++) {
        for (let x = 0; x < this.canvas.width; x++) {
          const offsetX = Math.floor(Math.random() * amount * 2) - amount;
          const offsetY = Math.floor(Math.random() * amount * 2) - amount;
          
          const newX = Math.min(this.canvas.width - 1, Math.max(0, x + offsetX));
          const newY = Math.min(this.canvas.height - 1, Math.max(0, y + offsetY));
          
          const srcOffset = (y * this.canvas.width + x) * 4;
          const dstOffset = (newY * this.canvas.width + newX) * 4;
          
          output.data[srcOffset] = imageData.data[dstOffset];
          output.data[srcOffset + 1] = imageData.data[dstOffset + 1];
          output.data[srcOffset + 2] = imageData.data[dstOffset + 2];
          output.data[srcOffset + 3] = imageData.data[dstOffset + 3];
        }
      }
      
      this.ctx.putImageData(output, 0, 0);
    }
  }
}

// Instantiate editor when DOM is ready
let editor;
document.addEventListener('DOMContentLoaded', () => {
  editor = new ImageEditor();
});
</script>

</body>
</html>
