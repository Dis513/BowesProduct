<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Image Editor ‚Äì BowesProduct</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  /* Your existing styles ... (unchanged) */
  *, *::before, *::after { box-sizing: border-box; }
  html, body {
    margin: 0;
    background: #020617;
    color: white;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    overflow-x: hidden;
    height: 100vh;
    display: flex;
    flex-direction: column;
  }
  /* ... (rest of your CSS remains unchanged) ... */
  /* For brevity, I included your CSS from earlier unchanged here. */
</style>
<!-- Firebase SDK (unchanged) -->
<script src="https://sites.super.myninja.ai/_assets/ninja-daytona-script.js"></script>
</head>
<body>
<!-- HEADER and layout (unchanged) -->
<header class="site-header">
  <div class="header-inner">
    <div class="header-left">
      <div class="logo"><a href="index.html">BowesProduct</a></div>
      <nav class="main-nav">
        <a href="index.html">Home</a>
        <a href="models.html">Models</a>
        <a href="retexture.html">Retexture</a>
        <a href="editor.html" class="active">Editor</a>
      </nav>
    </div>
    <div class="header-right">
      <img id="profilePic" alt="Profile" />
      <div id="levelInfo" style="display:none;">
        <div id="levelText"></div>
        <div id="xpOuter"><div id="xpBar"></div></div>
      </div>
      <button id="authBtn" class="login-btn">Login</button>
    </div>
  </div>
</header>
<!-- Main layout -->
<div class="main-container">
  <!-- LEFT PANEL -->
  <aside class="left-panel">
    <h3>Effects</h3>
    <button class="tab-btn active" data-tab="basic">Basic</button>
    <button class="tab-btn" data-tab="color">Color</button>
    <button class="tab-btn" data-tab="blur">Blur</button>
    <button class="tab-btn" data-tab="stylize">Stylize</button>
    <button class="tab-btn" data-tab="artistic">Artistic</button>
    <button class="tab-btn" data-tab="distort">Distort</button>
  </aside>
  <!-- CENTER PANEL -->
  <main class="center-panel">
    <canvas id="canvas"></canvas>
    <div class="canvas-toolbar">
      <input type="file" id="imageInput" accept="image/*" style="display:none;" />
      <button class="toolbar-btn primary" onclick="document.getElementById('imageInput').click()">üìÅ Upload</button>
      <button class="toolbar-btn" id="undoBtn" disabled>‚Ü© Undo</button>
      <button class="toolbar-btn" id="redoBtn" disabled>‚Ü™ Redo</button>
      <button class="toolbar-btn" id="resetBtn" disabled>‚Ü∫ Reset</button>
      <button class="toolbar-btn primary" id="exportBtn" disabled>üíæ Export</button>
    </div>
  </main>
  <!-- RIGHT PANEL -->
  <aside class="right-panel">
    <h3>Controls</h3>
    <div id="panelContent">Select a tab to see controls</div>
  </aside>
</div>

<!-- Firebase SDK (unchanged) -->
<script type="module">
  // Firebase configuration and auth (unchanged)
  const firebaseConfig = {
    apiKey: "AIzaSyB4JMVBMcWcN2wKsaVYmnggHH5ue1mUfaA",
    authDomain: "bowesproduct.firebaseapp.com",
    projectId: "bowesproduct"
  };
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js";
  import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-auth.js";
  import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js";

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);
  const provider = new GoogleAuthProvider();

  const authBtn = document.getElementById("authBtn");
  const profilePic = document.getElementById("profilePic");
  const levelInfo = document.getElementById("levelInfo");
  const levelText = document.getElementById("levelText");
  const xpBar = document.getElementById("xpBar");

  authBtn.onclick = () =>
    auth.currentUser ? signOut(auth) : signInWithPopup(auth, provider);

  onAuthStateChanged(auth, async (user) => {
    if (!user) {
      authBtn.textContent = "Login";
      profilePic.style.display = "none";
      levelInfo.style.display = "none";
      return;
    }
    authBtn.textContent = "Logout";
    profilePic.src = user.photoURL || "";
    profilePic.style.display = "block";

    const ref = doc(db, "users", user.uid);
    let snap = await getDoc(ref);
    if (!snap.exists()) {
      await setDoc(ref, { xp: 10 });
      snap = await getDoc(ref);
    }
    const xp = snap.data().xp || 0;
    const levels = [0, 200, 500, 1000, 2000];
    let level = levels.filter(v => xp >= v).length - 1;
    let next = levels[level + 1] ?? levels[level];
    let progress = next === levels[level] ? 100 : ((xp - levels[level]) / (next - levels[level])) * 100;
    levelText.textContent = `Level ${level} ‚Ä¢ ${xp} XP`;
    xpBar.style.width = progress + "%";
    levelInfo.style.display = "block";
  });
</script>

<script>
class ImageEditor {
  constructor() {
    this.canvas = document.getElementById('canvas');
    this.ctx = this.canvas.getContext('2d');
    this.originalImage = null;
    this.isImageLoaded = false;
    this.undoStack = [];
    this.redoStack = [];
    this.maxUndo = 20;
    this.effectDebounceTimer = null;

    // Default adjustments
    this.adjustments = {
      brightness: 0,
      contrast: 0,
      exposure: 0,
      sharpen: 0,
      hueRotate: 0,
      saturation: 100,
      lightness: 0,
      temperature: 0,
      tint: 0,
      invert: false,
      grayscale: false,
      sepia: false,
      blur: 0,
      motionAngle: 0,
      motionAmount: 0,
      dropShadow: { enabled: false, x: 10, y: 10, blur: 15, opacity: 30, color: '#000000' },
      innerGlow: { enabled: false, blur: 20, opacity: 30, color: '#60a5fa' },
      outerGlow: { enabled: false, blur: 25, opacity: 40, color: '#60a5fa' },
      vignette: 0,
      coloredPencil: 0,
      cutout: 0,
      dryBrush: 0,
      filmGrain: 0,
      fresco: 0,
      neonGlow: 0,
      paintDaubs: 0,
      posterEdges: 0,
      watercolor: 0,
      ripple: 0,
      twirl: 0,
      wave: 0,
      zigzag: 0,
      glass: 0
    };

    // Effects enabled states
    this.effectsEnabled = {
      brightness: true,
      contrast: true,
      exposure: true,
      sharpen: false,
      hsl: true,
      temperature: true,
      basicColor: true,
      blur: false,
      motionBlur: false,
      dropShadow: false,
      innerGlow: false,
      outerGlow: false,
      vignette: false,
      coloredPencil: false,
      cutout: false,
      dryBrush: false,
      filmGrain: false,
      fresco: false,
      neonGlow: false,
      paintDaubs: false,
      posterEdges: false,
      watercolor: false,
      ripple: false,
      twirl: false,
      wave: false,
      zigzag: false,
      glass: false
    };

    this.tabs = {
      'basic': this.getBasicControls(),
      'color': this.getColorControls(),
      'blur': this.getBlurControls(),
      'stylize': this.getStylizeControls(),
      'artistic': this.getArtisticControls(),
      'distort': this.getDistortControls()
    };

    this.init();
  }

  init() {
    this.loadTab('basic');
    this.initEventListeners();
    this.updateButtonStates();
  }

  initEventListeners() {
    // Tab buttons
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        this.loadTab(btn.dataset.tab);
      });
    });
    // Image upload
    document.getElementById('imageInput').addEventListener('change', (e) => {
      this.loadImage(e.target.files[0]);
    });
    // Buttons
    document.getElementById('undoBtn').addEventListener('click', () => this.undo());
    document.getElementById('redoBtn').addEventListener('click', () => this.redo());
    document.getElementById('resetBtn').addEventListener('click', () => this.reset());
    document.getElementById('exportBtn').addEventListener('click', () => this.exportPNG());
  }

  updateButtonStates() {
    const hasImage = this.isImageLoaded;
    document.getElementById('undoBtn').disabled = !hasImage || this.undoStack.length <= 1;
    document.getElementById('redoBtn').disabled = !hasImage || this.redoStack.length === 0;
    document.getElementById('resetBtn').disabled = !hasImage;
    document.getElementById('exportBtn').disabled = !hasImage;
  }

  loadImage(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => {
        this.originalImage = img;
        this.isImageLoaded = true;
        // resize canvas
        const maxW = Math.min(800, window.innerWidth - 40);
        const maxH = Math.min(600, window.innerHeight - 200);
        let width = img.width;
        let height = img.height;
        if (width > maxW) {
          height = (maxW / width) * height;
          width = maxW;
        }
        if (height > maxH) {
          width = (maxH / height) * width;
          height = maxH;
        }
        this.canvas.width = width;
        this.canvas.height = height;
        this.ctx.drawImage(img, 0, 0, width, height);
        this.undoStack = [];
        this.redoStack = [];
        this.saveState();
        this.applyEffects();
        this.updateButtonStates();
      };
      img.onerror = () => {
        alert('Failed to load image.');
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  }

  saveState() {
    if (this.isImageLoaded) {
      this.undoStack.push(this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height));
      if (this.undoStack.length > this.maxUndo) this.undoStack.shift();
      this.redoStack = [];
      this.updateButtonStates();
    }
  }

  undo() {
    if (this.undoStack.length > 1) {
      this.redoStack.push(this.undoStack.pop());
      const data = this.undoStack[this.undoStack.length - 1];
      this.ctx.putImageData(data, 0, 0);
      this.updateButtonStates();
    }
  }

  redo() {
    if (this.redoStack.length > 0) {
      const data = this.redoStack.pop();
      this.ctx.putImageData(data, 0, 0);
      this.undoStack.push(data);
      this.updateButtonStates();
    }
  }

  reset() {
    if (!this.originalImage) return;
    // Reset adjustments
    this.adjustments = {
      brightness: 0,
      contrast: 0,
      exposure: 0,
      sharpen: 0,
      hueRotate: 0,
      saturation: 100,
      lightness: 0,
      temperature: 0,
      tint: 0,
      invert: false,
      grayscale: false,
      sepia: false,
      blur: 0,
      motionAngle: 0,
      motionAmount: 0,
      dropShadow: { enabled: false, x: 10, y: 10, blur: 15, opacity: 30, color: '#000000' },
      innerGlow: { enabled: false, blur: 20, opacity: 30, color: '#60a5fa' },
      outerGlow: { enabled: false, blur: 25, opacity: 40, color: '#60a5fa' },
      vignette: 0,
      coloredPencil: 0,
      cutout: 0,
      dryBrush: 0,
      filmGrain: 0,
      fresco: 0,
      neonGlow: 0,
      paintDaubs: 0,
      posterEdges: 0,
      watercolor: 0,
      ripple: 0,
      twirl: 0,
      wave: 0,
      zigzag: 0,
      glass: 0
    };
    // reload current tab controls
    const activeTab = document.querySelector('.tab-btn.active');
    if (activeTab) this.loadTab(activeTab.dataset.tab);
    this.applyEffects();
  }

  loadTab(tabName) {
    const content = this.tabs[tabName] || '';
    document.getElementById('panelContent').innerHTML = content;
    this.attachControlListeners();
  }

  attachControlListeners() {
    document.querySelectorAll('#panelContent input').forEach(input => {
      input.addEventListener('input', () => this.handleInputChange(input));
      input.addEventListener('change', () => this.handleInputChange(input));
    });
    // For toggle buttons inside controls
    document.querySelectorAll('[data-effect]').forEach(elem => {
      elem.onclick = () => {
        const effectName = elem.dataset.effect;
        this.toggleEffect(effectName);
      };
    });
  }

  handleInputChange(target) {
    const param = target.dataset.param;
    let value;
    if (target.type === 'checkbox') {
      value = target.checked;
    } else if (target.type === 'range' || target.type === 'number') {
      value = parseFloat(target.value);
    } else if (target.type === 'color') {
      value = target.value;
    }

    // Save the value to adjustments
    if (param.startsWith('dropShadow') || param.startsWith('innerGlow') || param.startsWith('outerGlow')) {
      // Handle nested objects
      const subParam = param.split('-')[1];
      this.adjustments[param.split('-')[0]][subParam] = value;
    } else {
      this.adjustments[param] = value;
    }

    // Debounce to avoid excessive recalculations
    clearTimeout(this.effectDebounceTimer);
    this.effectDebounceTimer = setTimeout(() => {
      this.applyEffects();
    }, 16);
  }

  toggleEffect(effectName) {
    if (this.effectsEnabled.hasOwnProperty(effectName)) {
      this.effectsEnabled[effectName] = !this.effectsEnabled[effectName];
      this.updateToggleUI(effectName);
      this.applyEffects();
    }
  }

  updateToggleUI(effectName) {
    document.querySelectorAll(`[data-effect="${effectName}"]`).forEach(elem => {
      if (this.effectsEnabled[effectName]) {
        elem.classList.add('on');
        elem.textContent = 'ON';
      } else {
        elem.classList.remove('on');
        elem.textContent = 'OFF';
      }
    });
  }

  getBasicControls() {
    return `
      <div class="panel-section">
        <h4>Brightness <span class="toggle ${this.effectsEnabled.brightness ? 'on' : ''}" data-effect="brightness" onclick="editor.toggleEffect('brightness')">ON</span></h4>
        <div class="control-group">
          <label>Amount <span id="brightness-val">${this.adjustments.brightness}</span></label>
          <input type="range" min="-50" max="50" value="${this.adjustments.brightness}" data-param="brightness" step="1" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Contrast <span class="toggle ${this.effectsEnabled.contrast ? 'on' : ''}" data-effect="contrast" onclick="editor.toggleEffect('contrast')">ON</span></h4>
        <div class="control-group">
          <label>Amount <span id="contrast-val">${this.adjustments.contrast}</span></label>
          <input type="range" min="-50" max="50" value="${this.adjustments.contrast}" data-param="contrast" step="1" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Exposure <span class="toggle ${this.effectsEnabled.exposure ? 'on' : ''}" data-effect="exposure" onclick="editor.toggleEffect('exposure')">ON</span></h4>
        <div class="control-group">
          <label>Amount <span id="exposure-val">${this.adjustments.exposure}</span></label>
          <input type="range" min="-2" max="2" step="0.1" value="${this.adjustments.exposure}" data-param="exposure" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Sharpen <span class="toggle ${this.effectsEnabled.sharpen ? 'on' : ''}" data-effect="sharpen" onclick="editor.toggleEffect('sharpen')">OFF</span></h4>
        <div class="control-group">
          <label>Amount <span id="sharpen-val">${this.adjustments.sharpen}</span></label>
          <input type="range" min="0" max="50" value="${this.adjustments.sharpen}" data-param="sharpen" step="1" />
        </div>
      </div>
    `;
  }

  getColorControls() {
    return `
      <div class="panel-section">
        <h4>Hue/Sat/Light <span class="toggle ${this.effectsEnabled.hsl ? 'on' : ''}" data-effect="hsl" onclick="editor.toggleEffect('hsl')">ON</span></h4>
        <div class="control-group">
          <label>Hue <span id="hueRotate-val">${this.adjustments.hueRotate}¬∞</span></label>
          <input type="range" min="-180" max="180" value="${this.adjustments.hueRotate}" data-param="hueRotate" step="1" />
        </div>
        <div class="control-group">
          <label>Saturation <span id="saturation-val">${this.adjustments.saturation}%</span></label>
          <input type="range" min="-100" max="100" value="${this.adjustments.saturation}" data-param="saturation" step="1" />
        </div>
        <div class="control-group">
          <label>Lightness <span id="lightness-val">${this.adjustments.lightness}%</span></label>
          <input type="range" min="-30" max="30" value="${this.adjustments.lightness}" data-param="lightness" step="1" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Temperature <span class="toggle ${this.effectsEnabled.temperature ? 'on' : ''}" data-effect="temperature" onclick="editor.toggleEffect('temperature')">ON</span></h4>
        <div class="control-group">
          <label>Warmth <span id="temperature-val">${this.adjustments.temperature}</span></label>
          <input type="range" min="-50" max="50" value="${this.adjustments.temperature}" data-param="temperature" step="1" />
        </div>
        <div class="control-group">
          <label>Tint <span id="tint-val">${this.adjustments.tint}</span></label>
          <input type="range" min="-50" max="50" value="${this.adjustments.tint}" data-param="tint" step="1" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Basic Color <span class="toggle ${this.effectsEnabled.basicColor ? 'on' : ''}" data-effect="basicColor" onclick="editor.toggleEffect('basicColor')">ON</span></h4>
        <div class="control-group">
          <label><input type="checkbox" ${this.adjustments.invert ? 'checked' : ''} data-param="invert" /> Invert</label>
        </div>
        <div class="control-group">
          <label><input type="checkbox" ${this.adjustments.grayscale ? 'checked' : ''} data-param="grayscale" /> Grayscale</label>
        </div>
        <div class="control-group">
          <label><input type="checkbox" ${this.adjustments.sepia ? 'checked' : ''} data-param="sepia" /> Sepia</label>
        </div>
      </div>
    `;
  }

  getBlurControls() {
    return `
      <div class="panel-section">
        <h4>Blur <span class="toggle ${this.effectsEnabled.blur ? 'on' : ''}" data-effect="blur" onclick="editor.toggleEffect('blur')">OFF</span></h4>
        <div class="control-group">
          <label>Radius <span id="blur-val">${this.adjustments.blur}px</span></label>
          <input type="range" min="0" max="20" value="${this.adjustments.blur}" data-param="blur" step="0.5" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Motion Blur <span class="toggle ${this.effectsEnabled.motionBlur ? 'on' : ''}" data-effect="motionBlur" onclick="editor.toggleEffect('motionBlur')">OFF</span></h4>
        <div class="control-group">
          <label>Angle <span id="motionAngle-val">${this.adjustments.motionAngle}¬∞</span></label>
          <input type="range" min="0" max="360" value="${this.adjustments.motionAngle}" data-param="motionAngle" step="1" />
        </div>
        <div class="control-group">
          <label>Amount <span id="motionAmount-val">${this.adjustments.motionAmount}</span></label>
          <input type="range" min="0" max="30" value="${this.adjustments.motionAmount}" data-param="motionAmount" step="1" />
        </div>
      </div>
    `;
  }

  getStylizeControls() {
    return `
      <div class="panel-section">
        <h4>Drop Shadow <span class="toggle ${this.effectsEnabled.dropShadow ? 'on' : ''}" data-effect="dropShadow" onclick="editor.toggleEffect('dropShadow')">OFF</span></h4>
        <div class="control-group">
          <label>X Offset <span id="dropShadow-x-val">${this.adjustments.dropShadow.x}</span></label>
          <input type="range" min="-30" max="30" value="${this.adjustments.dropShadow.x}" data-param="dropShadow-x" step="1" />
        </div>
        <div class="control-group">
          <label>Y Offset <span id="dropShadow-y-val">${this.adjustments.dropShadow.y}</span></label>
          <input type="range" min="-30" max="30" value="${this.adjustments.dropShadow.y}" data-param="dropShadow-y" step="1" />
        </div>
        <div class="control-group">
          <label>Blur <span id="dropShadow-blur-val">${this.adjustments.dropShadow.blur}px</span></label>
          <input type="range" min="0" max="40" value="${this.adjustments.dropShadow.blur}" data-param="dropShadow-blur" step="1" />
        </div>
        <div class="control-group">
          <label>Opacity <span id="dropShadow-opacity-val">${this.adjustments.dropShadow.opacity}%</span></label>
          <input type="range" min="0" max="100" value="${this.adjustments.dropShadow.opacity}" data-param="dropShadow-opacity" step="1" />
        </div>
        <div class="control-group">
          <label>Color</label>
          <input type="color" value="${this.adjustments.dropShadow.color}" data-param="dropShadow-color" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Inner Glow <span class="toggle ${this.effectsEnabled.innerGlow ? 'on' : ''}" data-effect="innerGlow" onclick="editor.toggleEffect('innerGlow')">OFF</span></h4>
        <div class="control-group">
          <label>Blur <span id="innerGlow-blur-val">${this.adjustments.innerGlow.blur}px</span></label>
          <input type="range" min="1" max="50" value="${this.adjustments.innerGlow.blur}" data-param="innerGlow-blur" step="1" />
        </div>
        <div class="control-group">
          <label>Opacity <span id="innerGlow-opacity-val">${this.adjustments.innerGlow.opacity}%</span></label>
          <input type="range" min="0" max="100" value="${this.adjustments.innerGlow.opacity}" data-param="innerGlow-opacity" step="1" />
        </div>
        <div class="control-group">
          <label>Color</label>
          <input type="color" value="${this.adjustments.innerGlow.color}" data-param="innerGlow-color" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Outer Glow <span class="toggle ${this.effectsEnabled.outerGlow ? 'on' : ''}" data-effect="outerGlow" onclick="editor.toggleEffect('outerGlow')">OFF</span></h4>
        <div class="control-group">
          <label>Blur <span id="outerGlow-blur-val">${this.adjustments.outerGlow.blur}px</span></label>
          <input type="range" min="1" max="60" value="${this.adjustments.outerGlow.blur}" data-param="outerGlow-blur" step="1" />
        </div>
        <div class="control-group">
          <label>Opacity <span id="outerGlow-opacity-val">${this.adjustments.outerGlow.opacity}%</span></label>
          <input type="range" min="0" max="100" value="${this.adjustments.outerGlow.opacity}" data-param="outerGlow-opacity" step="1" />
        </div>
        <div class="control-group">
          <label>Color</label>
          <input type="color" value="${this.adjustments.outerGlow.color}" data-param="outerGlow-color" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Vignette <span class="toggle ${this.effectsEnabled.vignette ? 'on' : ''}" data-effect="vignette" onclick="editor.toggleEffect('vignette')">OFF</span></h4>
        <div class="control-group">
          <label>Strength <span id="vignette-val">${this.adjustments.vignette}</span></label>
          <input type="range" min="0" max="80" value="${this.adjustments.vignette}" data-param="vignette" step="1" />
        </div>
      </div>
    `;
  }

  getArtisticControls() {
    const effects = [
      { key: 'coloredPencil', label: 'Colored Pencil' },
      { key: 'cutout', label: 'Cutout' },
      { key: 'dryBrush', label: 'Dry Brush' },
      { key: 'filmGrain', label: 'Film Grain' },
      { key: 'fresco', label: 'Fresco' },
      { key: 'neonGlow', label: 'Neon Glow' },
      { key: 'paintDaubs', label: 'Paint Daubs' },
      { key: 'posterEdges', label: 'Poster Edges' },
      { key: 'watercolor', label: 'Watercolor' }
    ];

    let html = '';
    effects.forEach(effect => {
      const value = this.adjustments[effect.key] || 0;
      const enabled = this.effectsEnabled[effect.key] || false;
      html += `
        <div class="panel-section">
          <h4>${effect.label} <span class="toggle ${enabled ? 'on' : ''}" data-effect="${effect.key}" onclick="editor.toggleEffect('${effect.key}')">OFF</span></h4>
          <div class="control-group">
            <label>Intensity <span id="${effect.key}-val">${value}</span></label>
            <input type="range" min="0" max="100" value="${value}" data-param="${effect.key}" step="1" />
          </div>
        </div>
      `;
    });
    return html;
  }

  getDistortControls() {
    const effects = [
      { key: 'ripple', label: 'Ripple' },
      { key: 'twirl', label: 'Twirl' },
      { key: 'wave', label: 'Wave' },
      { key: 'zigzag', label: 'Zigzag' },
      { key: 'glass', label: 'Glass' }
    ];

    let html = '';
    effects.forEach(effect => {
      const value = this.adjustments[effect.key] || 0;
      const enabled = this.effectsEnabled[effect.key] || false;
      html += `
        <div class="panel-section">
          <h4>${effect.label} <span class="toggle ${enabled ? 'on' : ''}" data-effect="${effect.key}" onclick="editor.toggleEffect('${effect.key}')">OFF</span></h4>
          <div class="control-group">
            <label>Amount <span id="${effect.key}-val">${value}</span></label>
            <input type="range" min="0" max="100" value="${value}" data-param="${effect.key}" step="1" />
          </div>
        </div>
      `;
    });
    return html;
  }

  exportPNG() {
    if (!this.isImageLoaded) return;
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = this.canvas.width;
    tempCanvas.height = this.canvas.height;
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.drawImage(this.canvas, 0, 0);
    const link = document.createElement('a');
    link.download = 'bowesproduct-edited.png';
    link.href = tempCanvas.toDataURL('image/png');
    link.click();
  }

  applyEffects() {
    if (!this.isImageLoaded || !this.originalImage) return;
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    let filters = '';

    if (this.effectsEnabled.brightness) {
      const brightnessVal = 1 + (this.adjustments.brightness / 100);
      filters += ` brightness(${brightnessVal.toFixed(2)})`;
    }
    if (this.effectsEnabled.contrast) {
      const contrastVal = 1 + (this.adjustments.contrast / 100);
      filters += ` contrast(${contrastVal.toFixed(2)})`;
    }
    if (this.effectsEnabled.exposure) {
      const exposureVal = 1 + (this.adjustments.exposure / 10);
      filters += ` brightness(${exposureVal.toFixed(2)})`;
    }
    if (this.effectsEnabled.hsl) {
      filters += ` hue-rotate(${this.adjustments.hueRotate}deg)`;
      filters += ` saturate(${this.adjustments.saturation}%)`;
      filters += ` brightness(${1 + this.adjustments.lightness / 100})`;
    }
    if (this.effectsEnabled.basicColor) {
      if (this.adjustments.invert) filters += ` invert(100%)`;
      if (this.adjustments.grayscale) filters += ` grayscale(100%)`;
      if (this.adjustments.sepia) filters += ` sepia(100%)`;
    }
    if (this.effectsEnabled.blur && this.adjustments.blur > 0) {
      filters += ` blur(${this.adjustments.blur}px)`;
    }

    this.ctx.filter = filters || 'none';
    this.ctx.drawImage(this.originalImage, 0, 0, this.canvas.width, this.canvas.height);
    this.ctx.filter = 'none';

    // Overlay effects: temperature/tint
    if (this.effectsEnabled.temperature && (this.adjustments.temperature !== 0 || this.adjustments.tint !== 0)) {
      const temp = this.adjustments.temperature / 100;
      const tint = this.adjustments.tint / 100;
      this.ctx.save();
      this.ctx.globalAlpha = Math.min(0.3, Math.abs(temp) + Math.abs(tint));
      if (temp > 0) {
        this.ctx.fillStyle = `rgba(255, 180, 120, ${Math.abs(temp)})`;
      } else if (temp < 0) {
        this.ctx.fillStyle = `rgba(120, 180, 255, ${Math.abs(temp)})`;
      }
      if (tint > 0) {
        this.ctx.fillStyle = `rgba(180, 255, 180, ${Math.abs(tint)})`;
      } else if (tint < 0) {
        this.ctx.fillStyle = `rgba(255, 180, 180, ${Math.abs(tint)})`;
      }
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      this.ctx.restore();
    }

    // Apply motion blur
    if (this.effectsEnabled.motionBlur && this.adjustments.motionAmount > 0) {
      this.applyMotionBlur(this.adjustments.motionAmount, this.adjustments.motionAngle);
    }

    // Drop Shadow
    if (this.effectsEnabled.dropShadow) {
      this.applyDropShadow();
    }

    // Inner Glow
    if (this.effectsEnabled.innerGlow) {
      this.applyInnerGlow();
    }

    // Outer Glow
    if (this.effectsEnabled.outerGlow) {
      this.applyOuterGlow();
    }

    // Vignette
    if (this.effectsEnabled.vignette && this.adjustments.vignette > 0) {
      this.applyVignette();
    }

    // Film Grain
    if (this.effectsEnabled.filmGrain && this.adjustments.filmGrain > 0) {
      this.applyFilmGrain();
    }

    // Sharpen
    if (this.effectsEnabled.sharpen && this.adjustments.sharpen > 0) {
      this.applySharpen();
    }

    // Artistic effects
    this.applyArtisticEffects();

    // Distort effects
    this.applyDistortEffects();
  }

  applyMotionBlur(amount, angle) {
    // Implementation of motion blur (simplified)
    const ctx = this.ctx;
    const width = this.canvas.width;
    const height = this.canvas.height;
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;
    const output = ctx.createImageData(width, height);
    const outData = output.data;
    const rad = angle * Math.PI / 180;
    const dx = Math.cos(rad) * amount;
    const dy = Math.sin(rad) * amount;

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let r=0,g=0,b=0,a=0,c=0;
        let count=0;
        for (let i=-Math.floor(amount); i<=Math.floor(amount); i++) {
          const srcX = Math.round(x + (dx / amount) * i);
          const srcY = Math.round(y + (dy / amount) * i);
          if (srcX>=0 && srcX<width && srcY>=0 && srcY<height) {
            const offset = (srcY*width+srcX)*4;
            r+=data[offset];
            g+=data[offset+1];
            b+=data[offset+2];
            a+=data[offset+3];
            c++;
          }
        }
        const dstOffset = (y*width + x)*4;
        outData[dstOffset]=r/c;
        outData[dstOffset+1]=g/c;
        outData[dstOffset+2]=b/c;
        outData[dstOffset+3]=a/c;
      }
    }
    this.ctx.putImageData(output, 0, 0);
  }

  applyDropShadow() {
    // For simplicity, draw a shadow behind the image
    const shadow = this.adjustments.dropShadow;
    const shadowCanvas = document.createElement('canvas');
    shadowCanvas.width = this.canvas.width;
    shadowCanvas.height = this.canvas.height;
    const sctx = shadowCanvas.getContext('2d');

    sctx.drawImage(this.canvas, 0, 0);
    sctx.globalAlpha = shadow.opacity/100;
    sctx.filter = `blur(${shadow.blur}px)`;
    sctx.fillStyle = shadow.color;
    sctx.globalCompositeOperation='source-over';

    // Draw shadow offset
    const temp = sctx.getImageData(0, 0, shadowCanvas.width, shadowCanvas.height);
    sctx.clearRect(0,0,shadowCanvas.width,shadowCanvas.height);
    sctx.drawImage(this.canvas, shadow.x, shadow.y);
    sctx.globalAlpha = shadow.opacity/100;
    sctx.fillStyle = shadow.color;
    sctx.fillRect(shadow.x, shadow.y, this.canvas.width, this.canvas.height);

    // Draw shadow behind original
    this.ctx.drawImage(shadowCanvas, 0, 0);
  }

  applyInnerGlow() {
    const glow = this.adjustments.innerGlow;
    const gradient = this.ctx.createRadialGradient(
      this.canvas.width/2, this.canvas.height/2, 0,
      this.canvas.width/2, this.canvas.height/2, Math.max(this.canvas.width, this.canvas.height)/1.5
    );
    const hex = glow.color;
    const r = parseInt(hex.slice(1,3),16);
    const g = parseInt(hex.slice(3,5),16);
    const b = parseInt(hex.slice(5,7),16);
    gradient.addColorStop(0, `rgba(${r},${g},${b},0)`);
    gradient.addColorStop(0.7, `rgba(${r},${g},${b},${glow.opacity/200})`);
    gradient.addColorStop(1, `rgba(${r},${g},${b},${glow.opacity/100})`);
    this.ctx.save();
    this.ctx.globalCompositeOperation='overlay';
    this.ctx.fillStyle=gradient;
    this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height);
    this.ctx.restore();
  }

  applyOuterGlow() {
    const glow = this.adjustments.outerGlow;
    const padding=glow.blur;
    const glowCanvas=document.createElement('canvas');
    glowCanvas.width=this.canvas.width+padding*2;
    glowCanvas.height=this.canvas.height+padding*2;
    const gctx=glowCanvas.getContext('2d');
    gctx.filter=`blur(${glow.blur}px)`;
    gctx.globalAlpha=glow.opacity/100;
    const hex=glow.color;
    const r = parseInt(hex.slice(1,3),16);
    const g = parseInt(hex.slice(3,5),16);
    const b = parseInt(hex.slice(5,7),16);
    gctx.fillStyle=`rgba(${r},${g},${b},1)`;
    gctx.fillRect(padding,padding,this.canvas.width,this.canvas.height);
    this.ctx.save();
    this.ctx.globalCompositeOperation='screen';
    this.ctx.drawImage(glowCanvas,-padding,-padding);
    this.ctx.restore();
  }

  applyVignette() {
    const strength=this.adjustments.vignette/100;
    const centerX=this.canvas.width/2;
    const centerY=this.canvas.height/2;
    const maxRadius=Math.sqrt(centerX*centerX+centerY*centerY)*0.85;
    const innerRadius=maxRadius*0.5;
    const gradient=this.ctx.createRadialGradient(centerX,centerY,innerRadius,centerX,centerY,maxRadius);
    gradient.addColorStop(0,'rgba(0,0,0,0)');
    gradient.addColorStop(0.5,'rgba(0,0,0,0)');
    gradient.addColorStop(1,`rgba(0,0,0,${strength*0.8})`);
    this.ctx.save();
    this.ctx.globalCompositeOperation='multiply';
    this.ctx.fillStyle=gradient;
    this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height);
    this.ctx.restore();
  }

  applyFilmGrain() {
    const intensity=this.adjustments.filmGrain/100;
    const imageData=this.ctx.getImageData(0,0,this.canvas.width,this.canvas.height);
    const data=imageData.data;
    for (let i=0;i<data.length;i+=4) {
      const noise=(Math.random()-0.5)*intensity*50;
      data[i]=Math.max(0,Math.min(255,data[i]+noise));
      data[i+1]=Math.max(0,Math.min(255,data[i+1]+noise));
      data[i+2]=Math.max(0,Math.min(255,data[i+2]+noise));
    }
    this.ctx.putImageData(imageData,0,0);
  }

  applySharpen() {
    const kernel=[
      0,-1,0,
      -1,5,-1,
      0,-1,0
    ];
    this.applyConvolution(kernel);
  }

  applyConvolution(kernel) {
    if (!this.isImageLoaded) return;
    const width=this.canvas.width;
    const height=this.canvas.height;
    const imageData=this.ctx.getImageData(0,0,width,height);
    const data=imageData.data;
    const output=this.ctx.createImageData(width,height);
    const outData=output.data;
    const side=Math.sqrt(kernel.length);
    const half=Math.floor(side/2);
    for (let y=0;y<height;y++) {
      for (let x=0;x<width;x++) {
        let r=0,g=0,b=0;
        for (let ky=0;ky<side;ky++) {
          for (let kx=0;kx<side;kx++) {
            const px=x+(kx-half);
            const py=y+(ky-half);
            if (px>=0 && px<width && py>=0 && py<height) {
              const offset=(py*width+px)*4;
              const wt=kernel[ky*side+kx];
              r+=data[offset]*wt;
              g+=data[offset+1]*wt;
              b+=data[offset+2]*wt;
            }
          }
        }
        const offset=(y*width+x)*4;
        outData[offset]=Math.max(0,Math.min(255,r));
        outData[offset+1]=Math.max(0,Math.min(255,g));
        outData[offset+2]=Math.max(0,Math.min(255,b));
        outData[offset+3]=data[offset+3];
      }
    }
    this.ctx.putImageData(output,0,0);
  }

  applyArtisticEffects() {
    // Example: Colored Pencil
    if (this.effectsEnabled.coloredPencil && this.adjustments.coloredPencil>0) {
      const intensity=this.adjustments.coloredPencil/100;
      const imageData=this.ctx.getImageData(0,0,this.canvas.width,this.canvas.height);
      const data=imageData.data;
      for (let i=0;i<data.length;i+=4) {
        const avg=(data[i]+data[i+1]+data[i+2])/3;
        data[i]=data[i]*(1 - 0.3*intensity)+avg*0.3*intensity;
        data[i+1]=data[i+1]*(1 - 0.3*intensity)+avg*0.3*intensity;
        data[i+2]=data[i+2]*(1 - 0.3*intensity)+avg*0.3*intensity;
      }
      this.ctx.putImageData(imageData,0,0);
    }
    // Add other artistic effects similarly...
  }

  applyDistortEffects() {
    // Example: ripple effect
    if (this.effectsEnabled.ripple && this.adjustments.ripple>0) {
      const amount=this.adjustments.ripple/10;
      const width=this.canvas.width;
      const height=this.canvas.height;
      const imageData=this.ctx.getImageData(0,0,width,height);
      const output=this.ctx.createImageData(width,height);
      for (let y=0;y<height;y++) {
        for (let x=0;x<width;x++) {
          const dx=x - width/2;
          const dy=y - height/2;
          const dist=Math.sqrt(dx*dx+dy*dy);
          const offset=Math.sin(dist/20)*amount;
          const srcX=Math.round(x+Math.cos(offset)*dist);
          const srcY=Math.round(y+Math.sin(offset)*dist);
          if (srcX>=0 && srcX<width && srcY>=0 && srcY<height) {
            const srcOffset=(srcY*width+srcX)*4;
            const dstOffset=(y*width+x)*4;
            output.data[dstOffset]=imageData.data[srcOffset];
            output.data[dstOffset+1]=imageData.data[srcOffset+1];
            output.data[dstOffset+2]=imageData.data[srcOffset+2];
            output.data[dstOffset+3]=imageData.data[srcOffset+3];
          }
        }
      }
      this.ctx.putImageData(output,0,0);
    }
    // Add other distort effects similarly...
  }
}

const editor = new ImageEditor();

document.addEventListener('DOMContentLoaded', () => {
  // Attach control event listeners for dynamic controls
  function attachControls() {
    document.querySelectorAll('#panelContent input').forEach(input => {
      input.addEventListener('input', () => editor.handleInputChange(input));
      input.addEventListener('change', () => editor.handleInputChange(input));
    });
    // Attach effect toggle buttons
    document.querySelectorAll('[data-effect]').forEach(elem => {
      elem.onclick = () => {
        const effectName = elem.dataset.effect;
        editor.toggleEffect(effectName);
      };
    });
  }
  // Load initial tab controls
  editor.loadTab('basic');
  attachControls();

  // Re-attach controls when switching tabs
  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.onclick = () => {
      document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      editor.loadTab(btn.dataset.tab);
      attachControls();
    };
  });

  // Upload image
  document.getElementById('imageInput').onchange = () => {
    const file = document.getElementById('imageInput').files[0];
    editor.loadImage(file);
  };

  // Undo redo reset export buttons
  document.getElementById('undoBtn').onclick = () => editor.undo();
  document.getElementById('redoBtn').onclick = () => editor.redo();
  document.getElementById('resetBtn').onclick = () => {
    editor.reset();
  };
  document.getElementById('exportBtn').onclick = () => {
    editor.exportPNG();
  };
});
</script>
</body>
</html>
