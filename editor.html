<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Vector Editor Pro ‚Äì BowesProduct (Illustrator 2026)</title>
  <style>
  *, *::before, *::after { box-sizing: border-box; }
  html, body { margin: 0; height: 100%; background: #020617; color: white; font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif; overflow: hidden; -webkit-font-smoothing: antialiased; }
  
  /* ================= HEADER ================= */
  .site-header {
    position: sticky; top: 0; z-index: 1000; background: rgba(2,6,23,0.95); border-bottom: 1px solid #1e293b; backdrop-filter: blur(10px);
  }
  .header-inner { max-width: 1400px; margin: 0 auto; padding: 0.6rem 1rem; display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 0.5rem; }
  .header-left { display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; }
  .logo a { font-size: 1.3rem; font-weight: 700; color: white; text-decoration: none; white-space: nowrap; }
  .main-nav { display: flex; gap: 1rem; flex-wrap: wrap; }
  .main-nav a { color: #e5e7eb; text-decoration: none; font-size: 0.9rem; white-space: nowrap; }
  .main-nav a:hover, .main-nav a.active { color: #60a5fa; }
  .header-right { display: flex; align-items: center; gap: 0.8rem; min-height: 44px; flex-wrap: wrap; }
  #profilePic { width: 32px; height: 32px; border-radius: 50%; border: 2px solid #60a5fa; object-fit: cover; display: none; }
  .login-btn { padding: 0.45rem 1.1rem; border-radius: 999px; border: 1.5px solid #60a5fa; background: transparent; color: #60a5fa; font-size: 0.95rem; cursor: pointer; }
  #levelInfo { display: none; font-size: 0.8rem; color: #cbd5e1; }
  #levelText { white-space: nowrap; font-size: 0.75rem; }
  #xpOuter { width: 100px; height: 5px; background: #1e293b; border-radius: 3px; margin-top: 4px; }
  #xpBar { height: 100%; width: 0%; background: #60a5fa; border-radius: 3px; transition: width 0.35s ease; }

  @media (max-width: 900px) {
    .header-inner { padding: 0.5rem; }
    .header-left { width: 100%; justify-content: space-between; }
    .main-nav { gap: 0.8rem; order: 3; width: 100%; }
    .main-nav a { font-size: 0.85rem; }
    .header-right { width: 100%; justify-content: space-between; }
    #levelInfo { flex: 1; }
    #xpOuter { width: 100%; }
  }

  /* ================= APPLICATION MENU BAR ================= */
  .app-menu-bar {
    background: rgba(15,23,42,0.98);
    border-bottom: 1px solid #1e293b;
    padding: 0;
    padding-left: 150px;
    display: flex;
    gap: 0;
    font-size: 0.85rem;
    position: sticky;
    top: 70px;
    z-index: 999;
    backdrop-filter: blur(10px);
    flex-wrap: wrap;
    height: 36px;
    align-items: center;
  }
  .menu-bar { display: flex; height: 100%; }
  .menu-bar > div {
    position: relative; cursor: pointer; padding: 0.5rem 1rem; height: 100%; display: flex; align-items: center; user-select: none;
  }
  .menu-bar > div:hover { color: #60a5fa; background: rgba(96, 165, 250, 0.1); }
  .dropdown {
    position: absolute; top: 100%; left: 0; background: #0f172a; border: 1px solid #1e293b; min-width: 260px; display: none; flex-direction: column; box-shadow: 0 8px 25px rgba(0,0,0,0.6); border-radius: 6px; overflow: hidden; z-index: 10000; margin-top: 2px;
  }
  .dropdown div { padding: 0.6rem 1.2rem; text-align: left; white-space: nowrap; transition: background 0.15s; font-size: 0.85rem; cursor: pointer; }
  .dropdown div:hover { background: #1e293b; }
  .dropdown div:active { background: #334155; }
  .dropdown .shortcut { float: right; color: #64748b; font-size: 0.75rem; margin-left: 2rem; }
  .dropdown hr { border: none; border-top: 1px solid #1e293b; margin: 0.4rem 0; }
  .dropdown .submenu { position: absolute; left: 100%; top: 0; min-width: 220px; display: none; }
  .dropdown div:hover .submenu { display: flex; }
  .menu-bar > div:hover .dropdown, .dropdown:hover { display: flex; }

  /* ================= MAIN LAYOUT ================= */
  #container { position: relative; width: 100%; height: 100%; padding-top: 106px; padding-bottom: 0; display: flex; }
  
  /* ================= CANVAS AREA ================= */
  #canvas-container {
    flex: 1; position: relative; background: #1a1a2e; overflow: hidden; display: flex; flex-direction: column;
  }
  
  /* Rulers */
  .ruler { position: absolute; background: #1e293b; color: #64748b; font-size: 10px; z-index: 10; }
  .ruler-h { top: 0; left: 60px; right: 0; height: 20px; border-bottom: 1px solid #334155; }
  .ruler-v { top: 20px; left: 0; width: 60px; bottom: 0; border-right: 1px solid #334155; }
  .ruler-corner { position: absolute; top: 0; left: 0; width: 60px; height: 20px; background: #1e293b; border-right: 1px solid #334155; border-bottom: 1px solid #334155; z-index: 11; }
  
  #canvas { display: block; width: 100%; height: 100%; touch-action: none; outline: none; margin-top: 20px; margin-left: 60px; background: #1a1a2e; }
  
  /* Artboard */
  .artboard {
    position: absolute; background: white; box-shadow: 0 0 0 1px #334155, 0 4px 20px rgba(0,0,0,0.5);
  }
  .artboard-label {
    position: absolute; bottom: -25px; left: 0; color: #64748b; font-size: 11px; white-space: nowrap;
  }

  /* ================= LEFT TOOLBAR ================= */
  #floatingToolbar {
    position: fixed; left: 20px; top: 116px; background: rgba(30, 41, 59, 0.95); padding: 10px; border-radius: 12px; border: 1px solid #1e293b; backdrop-filter: blur(8px); z-index: 1150; display: flex; flex-direction: column; gap: 8px; max-height: calc(100vh - 180px); overflow-y: auto;
  }
  .tool-group { display: flex; flex-direction: column; gap: 2px; padding: 4px 0; border-bottom: 1px solid #1e293b; }
  .tool-group:last-child { border-bottom: none; }
  .tool-btn {
    width: 42px; height: 42px; border-radius: 6px; border: 1px solid transparent; background: transparent; color: #94a3b8; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.15s; font-size: 1.3rem; position: relative;
  }
  .tool-btn:hover { background: rgba(51, 65, 85, 1); color: white; }
  .tool-btn.active { color: #22c55e; background: rgba(34, 197, 94, 0.1); border-color: #22c55e; }
  .tool-btn.deactivated { border: 1px solid #ef4444 !important; color: #ef4444; opacity: 0.6; }
  .tool-btn.panel-open { box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.5); }
  .tool-panel-indicator {
    position: absolute; top: 2px; right: 2px; font-size: 8px; background: #22c55e; color: #020617; padding: 1px 3px; border-radius: 2px; display: none;
  }
  .tool-btn.panel-open .tool-panel-indicator { display: block; }

  /* ================= RIGHT PANEL DOCK ================= */
  .panel-dock {
    position: fixed; right: 20px; top: 116px; width: 320px; max-height: calc(100vh - 140px); background: rgba(2, 6, 23, 0.95); border: 1px solid #1e293b; border-radius: 12px; overflow: hidden; z-index: 20; backdrop-filter: blur(10px); box-shadow: 0 10px 30px rgba(0,0,0,0.4); display: flex; flex-direction: column;
  }
  
  #dockToggle { 
    position: absolute; left: -50px; top: 50%; transform: translateY(-50%); width: 50px; height: 100px; background: rgba(2, 6, 23, 0.98); border: 1px solid #1e293b; border-right: none; border-radius: 12px 0 0 12px; color: #60a5fa; font-size: 2rem; cursor: pointer; display: flex; align-items: center; justify-content: center; z-index: 21; backdrop-filter: blur(12px); box-shadow: 0 6px 30px rgba(0,0,0,0.5); transition: all 0.3s ease;
  }
  #dockToggle:hover { background: rgba(30, 41, 59, 0.98); color: white; transform: translateY(-50%) translateX(-4px); }

  .panel-tabs { display: flex; background: #0f172a; border-bottom: 1px solid #1e293b; overflow-x: auto; position: relative; }
  .panel-tab {
    padding: 0.6rem 1rem; background: transparent; border: none; color: #94a3b8; cursor: pointer; font-size: 0.8rem; white-space: nowrap; transition: all 0.2s; flex-shrink: 0;
  }
  .panel-tab:hover { color: #e5e7eb; }
  .panel-tab.active { color: #60a5fa; background: rgba(96, 165, 250, 0.1); border-bottom: 2px solid #60a5fa; }
  .panel-close-btn {
    position: absolute; right: 8px; top: 50%; transform: translateY(-50%); width: 28px; height: 28px; border-radius: 6px; border: 1px solid #334155; background: #1e293b; color: #94a3b8; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; transition: all 0.2s;
  }
  .panel-close-btn:hover { background: #334155; color: #e5e7eb; }

  .panel-content { padding: 1rem; overflow-y: auto; flex: 1; }
  .panel-section { display: none; }
  .panel-section.active { display: block; }

  .panel-section h3 { 
    color: #60a5fa; margin: 1rem 0 0.8rem; font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid #1e293b; padding-bottom: 0.4rem; font-weight: 600;
  }
  .panel-section h3:first-child { margin-top: 0; }

  .control-group { margin-bottom: 1rem; }
  .control-group label { display: block; font-size: 0.8rem; color: #94a3b8; margin-bottom: 0.4rem; }
  .control-row { display: flex; gap: 0.5rem; align-items: center; }
  
  input[type="text"], input[type="number"], select {
    width: 100%; padding: 0.4rem 0.6rem; border-radius: 4px; border: 1px solid #334155; background: #0f172a; color: #e5e7eb; font-size: 0.85rem;
  }
  input[type="text"]:focus, input[type="number"]:focus, select:focus { outline: none; border-color: #60a5fa; }
  
  input[type="range"] { width: 100%; accent-color: #60a5fa; }
  input[type="color"] { width: 100%; height: 36px; padding: 2px; border: 1px solid #334155; border-radius: 4px; background: #0f172a; cursor: pointer; }
  
  .btn {
    padding: 0.5rem 1rem; border-radius: 6px; border: 1px solid #334155; background: #1e293b; color: #e5e7eb; cursor: pointer; font-size: 0.85rem; transition: all 0.2s;
  }
  .btn:hover { background: #334155; border-color: #475569; }
  .btn-primary { background: #60a5fa; border-color: #60a5fa; color: white; }
  .btn-primary:hover { background: #3b82f6; border-color: #3b82f6; }
  .btn-sm { padding: 0.3rem 0.6rem; font-size: 0.75rem; }
  .btn-group { display: flex; gap: 0.25rem; }
  .btn-group .btn { flex: 1; }

  /* Tool-specific Control Panels */
  .tool-panel {
    display: none;
    position: fixed;
    left: 80px;
    top: 116px;
    width: 260px;
    background: rgba(15, 23, 42, 0.98);
    border: 1px solid #22c55e;
    border-radius: 12px;
    padding: 1rem;
    z-index: 1200;
    box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    backdrop-filter: blur(10px);
  }
  .tool-panel.active {
    display: block;
  }
  .tool-panel h4 {
    margin: 0 0 1rem 0;
    color: #22c55e;
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    border-bottom: 1px solid #22c55e;
    padding-bottom: 0.5rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .tool-panel-close {
    cursor: pointer;
    font-size: 1.2rem;
    color: #94a3b8;
    transition: color 0.2s;
  }
  .tool-panel-close:hover {
    color: #ef4444;
  }

  /* Layers Panel */
  .layer-item { 
    display: flex; align-items: center; gap: 8px; padding: 0.5rem; background: #0f172a; border-radius: 6px; margin-bottom: 0.4rem; cursor: pointer; transition: all 0.15s;
  }
  .layer-item:hover { background: #1e293b; }
  .layer-item.active { background: #1e293b; border: 1px solid #60a5fa; }
  .layer-item .layer-icon { width: 20px; text-align: center; font-size: 0.9rem; }
  .layer-item .layer-name { flex: 1; font-size: 0.85rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .layer-item .layer-actions { display: flex; gap: 4px; }
  .layer-item .layer-actions button { padding: 2px 6px; font-size: 0.75rem; }

  /* Color Picker Panel */
  .color-picker-wrapper {
    background: #0f172a;
    border-radius: 8px;
    padding: 1rem;
  }
  
  .color-preview-large {
    width: 100%;
    height: 60px;
    border-radius: 6px;
    border: 2px solid #334155;
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.9rem;
    font-weight: 600;
    text-transform: uppercase;
  }
  
  .color-sliders {
    display: flex;
    flex-direction: column;
    gap: 0.8rem;
  }
  
  .color-slider-row {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }
  
  .color-slider-row label {
    width: 20px;
    font-weight: 600;
    font-size: 0.85rem;
  }
  
  .color-slider-row input[type="range"] {
    flex: 1;
    accent-color: var(--slider-color, #60a5fa);
  }
  
  .color-slider-row input[type="number"] {
    width: 60px;
  }
  
  /* Opacity slider */
  .opacity-control {
    margin-top: 1rem;
    padding-top: 1rem;
    border-top: 1px solid #1e293b;
  }
  
  /* Appearance Panel */
  .appearance-item { 
    padding: 0.6rem; background: #0f172a; border-radius: 6px; margin-bottom: 0.4rem; display: flex; align-items: center; gap: 0.5rem;
  }
  .appearance-item .type { font-size: 0.75rem; color: #64748b; width: 40px; }
  .appearance-item .color-preview { width: 24px; height: 24px; border-radius: 4px; border: 1px solid #334155; }
  .appearance-item .value { flex: 1; font-size: 0.8rem; }

  /* Swatches */
  .swatch-grid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 4px; }
  .swatch { 
    width: 100%; aspect-ratio: 1; border-radius: 4px; cursor: pointer; border: 1px solid #334155; transition: all 0.15s;
  }
  .swatch:hover { transform: scale(1.1); }
  .swatch.selected { border: 2px solid #60a5fa; }

  /* Alignment */
  .align-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px; }
  .align-btn { aspect-ratio: 1; display: flex; align-items: center; justify-content: center; border: 1px solid #334155; background: #0f172a; border-radius: 4px; cursor: pointer; transition: all 0.15s; }
  .align-btn:hover { background: #1e293b; }

  /* Status Bar */
  .status-bar {
    position: fixed; bottom: 0; left: 0; right: 0; background: rgba(15, 23, 42, 0.95); border-top: 1px solid #1e293b; padding: 0.4rem 1rem; font-size: 0.75rem; color: #64748b; display: flex; justify-content: space-between; z-index: 1000; backdrop-filter: blur(10px);
  }
  .status-bar .left { display: flex; gap: 2rem; }
  .status-bar .right { display: flex; gap: 1rem; }

  /* Mobile */
  @media (max-width: 900px) {
    #floatingToolbar { 
      left: 10px; top: 111px; padding: 6px; max-height: calc(100vh - 160px);
    }
    .tool-btn { width: 38px; height: 38px; font-size: 1.1rem; }
    .tool-panel {
      left: 10px;
      top: auto;
      bottom: 0;
      right: 0;
      width: 100%;
      max-height: 50vh;
      border-radius: 12px 12px 0 0;
      z-index: 2100;
    }
    .panel-dock { 
      top: auto; 
      bottom: 0; 
      right: 0; 
      left: 0; 
      width: 100%; 
      height: 40vh;
      max-height: 40vh;
      border-radius: 12px 12px 0 0; 
      transform: none; 
      z-index: 2000;
      overflow-y: auto;
    }
    .panel-dock.hidden { transform: translateY(100%); }
    .panel-dock.visible { transform: translateY(0); }
    #dockToggle { 
      display: flex; 
      top: -50px; 
      left: 50%; 
      transform: translateX(-50%); 
      width: 100px; 
      height: 50px; 
      border-radius: 12px 12px 0 0; 
    }
    .ruler-h { left: 50px; }
    .ruler-v { display: none; }
    #canvas { margin-left: 50px; }
    .app-menu-bar { gap: 1rem; padding-left: 60px; z-index: 999; }
    .menu-bar > div { padding: 0.3rem 0.5rem; font-size: 0.8rem; }
    .status-bar { z-index: 1100; }
    .dropdown { z-index: 1900; }
  }

  /* Panel Backdrop/Overlay */
  .panel-backdrop {
    display: none !important;
  }

  /* Tool/Panel Name Notification */
  .tool-notification {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.8);
    background: linear-gradient(135deg, rgba(96, 165, 250, 0.95), rgba(59, 130, 246, 0.95));
    color: white;
    padding: 1.5rem 2.5rem;
    border-radius: 16px;
    font-size: 1.8rem;
    font-weight: 700;
    letter-spacing: 0.5px;
    z-index: 10000;
    pointer-events: none;
    opacity: 0;
    box-shadow: 0 20px 60px rgba(96, 165, 250, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
  }
  .tool-notification.show {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }
  .tool-notification.hide {
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.9);
  }

  /* Color Picker Popup */
  .color-picker-popup {
    position: fixed;
    left: 70px;
    top: 116px;
    width: 280px;
    background: rgba(15, 23, 42, 0.98);
    border: 1px solid #1e293b;
    border-radius: 12px;
    padding: 1rem;
    z-index: 1200;
    box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    backdrop-filter: blur(10px);
    display: none;
  }
  
  .color-picker-popup.active {
    display: block;
  }
  
  .color-picker-popup h4 {
    margin: 0 0 1rem 0;
    color: #60a5fa;
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    border-bottom: 1px solid #1e293b;
    padding-bottom: 0.5rem;
  }

  #loader { 
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #60a5fa; font-size: 1.2rem; font-weight: 600; pointer-events: none; z-index: 5;
  }

  /* Context Menu */
  .context-menu {
    position: fixed; background: #0f172a; border: 1px solid #1e293b; min-width: 180px; border-radius: 8px; box-shadow: 0 8px 20px rgba(0,0,0,0.5); z-index: 2000; display: none;
  }
  .context-menu div { padding: 0.6rem 1rem; cursor: pointer; font-size: 0.85rem; }
  .context-menu div:hover { background: #1e293b; }
  .context-menu hr { border: none; border-top: 1px solid #1e293b; margin: 0.3rem 0; }
  
 .selection-box {
    position: absolute;
    border: 1px dashed #22c55e !important;
    background: rgba(34, 197, 94, 0.15) !important;  /* Slight green tint */
    pointer-events: none;
    z-index: 100;
    display: none;
}
  </style>
  <!-- Paper.js for vector editing -->
  <script src="https://cdn.jsdelivr.net/npm/paper@0.12.17/dist/paper-full.min.js"></script>
<script src="https://sites.super.myninja.ai/_assets/ninja-daytona-script.js"></script>
</head>
<body>
<header class="site-header">
  <div class="header-inner">
    <div class="header-left">
      <div class="logo"><a href="index.html">BowesProduct</a></div>
      <nav class="main-nav">
        <a href="index.html">Home</a>
        <a href="models.html">Models</a>
        <a href="retexture.html">Retexture</a>
        <a href="editor-fixed.html" class="active">Editor</a>
      </nav>
    </div>
    <div class="header-right">
      <img id="profilePic" alt="Profile">
      <div id="levelInfo">
        <div id="levelText"></div>
        <div id="xpOuter"><div id="xpBar"></div></div>
      </div>
      <button id="authBtn" class="login-btn">Login</button>
    </div>
  </div>
</header>

<!-- Application Menu Bar -->
<div class="app-menu-bar">
  <div class="menu-bar">
    <div>File
      <div class="dropdown">
        <div onclick="newDocument()">New <span class="shortcut">Ctrl+Shift+N</span></div>
        <div onclick="document.getElementById('openFile').click()">Open... <span class="shortcut">Ctrl+Shift+O</span></div>
        <div onclick="saveDocument()">Save <span class="shortcut">Ctrl+Shift+S</span></div>
        <div onclick="saveDocumentAs()">Save As... <span class="shortcut">Ctrl+Shift+A</span></div>
        <hr>
        <div onclick="document.getElementById('placeImage').click()">Place... <span class="shortcut">Ctrl+Shift+I</span></div>
        <hr>
        <div onclick="exportSVG()">Export As SVG <span class="shortcut">Ctrl+Alt+S</span></div>
        <div onclick="exportPNG()">Export As PNG <span class="shortcut">Ctrl+Alt+P</span></div>
        <div onclick="exportPDF()">Export As PDF <span class="shortcut">Ctrl+Alt+E</span></div>
      </div>
    </div>
    <div>Edit
      <div class="dropdown">
        <div onclick="undo()">Undo <span class="shortcut">Ctrl+Z</span></div>
        <div onclick="redo()">Redo <span class="shortcut">Ctrl+Y</span></div>
        <hr>
        <div onclick="cut()">Cut <span class="shortcut">Ctrl+X</span></div>
        <div onclick="copy()">Copy <span class="shortcut">Ctrl+C</span></div>
        <div onclick="paste()">Paste <span class="shortcut">Ctrl+V</span></div>
        <div onclick="duplicate()">Duplicate <span class="shortcut">Ctrl+D</span></div>
        <div onclick="deleteSelection()">Delete <span class="shortcut">Del</span></div>
        <hr>
        <div onclick="selectAll()">Select All <span class="shortcut">Ctrl+A</span></div>
        <div onclick="deselectAll()">Deselect <span class="shortcut">Ctrl+Shift+A</span></div>
      </div>
    </div>
    <div>Object
      <div class="dropdown">
        <div onclick="groupSelection()">Group <span class="shortcut">Ctrl+G</span></div>
        <div onclick="ungroupSelection()">Ungroup <span class="shortcut">Ctrl+Shift+G</span></div>
        <hr>
        <div onclick="lockSelection()">Lock <span class="shortcut">Ctrl+2</span></div>
        <div onclick="unlockAll()">Unlock All <span class="shortcut">Ctrl+Alt+2</span></div>
        <hr>
        <div>Arrange &darr;
          <div class="submenu">
            <div onclick="bringToFront()">Bring to Front <span class="shortcut">Ctrl+Shift+]</span></div>
            <div onclick="sendToBack()">Send to Back <span class="shortcut">Ctrl+Shift+[</span></div>
            <hr>
            <div onclick="bringForward()">Bring Forward <span class="shortcut">Ctrl+]</span></div>
            <div onclick="sendBackward()">Send Backward <span class="shortcut">Ctrl+[</span></div>
          </div>
        </div>
        <div>Transform &darr;
          <div class="submenu">
            <div onclick="rotateSelection(-90)">Rotate 90¬∞ CW</div>
            <div onclick="rotateSelection(90)">Rotate 90¬∞ CCW</div>
            <hr>
            <div onclick="flipSelection('horizontal')">Flip Horizontal</div>
            <div onclick="flipSelection('vertical')">Flip Vertical</div>
            <hr>
            <div onclick="showTransformDialog()">Transform...</div>
          </div>
        </div>
        <hr>
        <div>Pathfinder &darr;
          <div class="submenu">
            <div onclick="pathfinder('unite')">Unite</div>
            <div onclick="pathfinder('subtract')">Minus Front</div>
            <div onclick="pathfinder('intersect')">Intersect</div>
            <div onclick="pathfinder('exclude')">Exclude</div>
            <hr>
            <div onclick="pathfinder('divide')">Divide</div>
            <div onclick="pathfinder('trim')">Trim</div>
            <div onclick="pathfinder('merge')">Merge</div>
            <hr>
            <div onclick="pathfinder('crop')">Crop</div>
            <div onclick="pathfinder('outline')">Outline</div>
          </div>
        </div>
      </div>
    </div>
    <div>Type
      <div class="dropdown">
        <div onclick="createOutlines()">Create Outlines <span class="shortcut">Ctrl+Shift+O</span></div>
        <div onclick="findFont()">Find Font...</div>
      </div>
    </div>
    <div>Select
      <div class="dropdown">
        <div onclick="selectAll()">All <span class="shortcut">Ctrl+A</span></div>
        <div onclick="deselectAll()">Deselect <span class="shortcut">Ctrl+Shift+A</span></div>
        <hr>
        <div onclick="selectSameFill()">Same Fill Color</div>
        <div onclick="selectSameStroke()">Same Stroke Color</div>
        <div onclick="selectSameStrokeWidth()">Same Stroke Width</div>
      </div>
    </div>
    <div>View
      <div class="dropdown">
        <div onclick="zoomIn()">Zoom In <span class="shortcut">Ctrl++</span></div>
        <div onclick="zoomOut()">Zoom Out <span class="shortcut">Ctrl+-</span></div>
        <div onclick="zoomToFit()">Fit to Screen <span class="shortcut">Ctrl+0</span></div>
        <div onclick="zoomTo100%">100% <span class="shortcut">Ctrl+1</span></div>
        <hr>
        <div onclick="toggleGrid()">Grid <span class="shortcut">Ctrl+'</span></div>
        <div onclick="toggleRulers()">Rulers <span class="shortcut">Ctrl+R</span></div>
        <div onclick="toggleSnap()">Snap to Grid <span class="shortcut">Ctrl+Shift+'</span></div>
        <hr>
        <div onclick="showArtboardOptions()">Artboard Options...</div>
        <div onclick="rotateArtboard(90)">Rotate Artboard 90¬∞</div>
        <div onclick="rotateArtboard(-90)">Rotate Artboard -90¬∞</div>
      </div>
    </div>
    <div>Window
      <div class="dropdown">
        <div onclick="showPanel('properties')">Properties</div>
        <div onclick="showPanel('layers')">Layers <span class="shortcut">F7</span></div>
        <div onclick="showPanel('appearance')">Appearance <span class="shortcut">Shift+F6</span></div>
        <div onclick="showPanel('swatches')">Swatches</div>
        <div onclick="showPanel('gradient')">Gradient</div>
        <div onclick="showPanel('stroke')">Stroke</div>
        <div onclick="showPanel('align')">Align <span class="shortcut">Shift+F7</span></div>
        <div onclick="showPanel('character')">Character</div>
        <div onclick="showPanel('paragraph')">Paragraph</div>
      </div>
    </div>
  </div>
</div>

<div id="container">
  <!-- Hidden file inputs -->
  <input type="file" id="openFile" accept=".svg,.json" style="display:none" onchange="handleOpen(event)">
  <input type="file" id="placeImage" accept="image/*" style="display:none" onchange="handlePlace(event)">

  <!-- Panel Backdrop -->
  <div class="panel-backdrop" id="panelBackdrop"></div>

  <!-- Tool/Panel Name Notification -->
  <div class="tool-notification" id="toolNotification"></div>

  <!-- Fill Color Picker Popup -->
  <div class="color-picker-popup" id="fillColorPicker">
    <h4>Fill Color</h4>
    <div class="color-preview-large" id="fillColorPreview">#FF0000</div>
    <div class="color-sliders">
      <div class="color-slider-row">
        <label style="color: #ff6b6b;">R</label>
        <input type="range" id="fillRed" min="0" max="255" value="255" oninput="updateFillColor()">
        <input type="number" id="fillRedNum" min="0" max="255" value="255" oninput="updateFillColorFromNum()">
      </div>
      <div class="color-slider-row">
        <label style="color: #4ecdc4;">G</label>
        <input type="range" id="fillGreen" min="0" max="255" value="0" oninput="updateFillColor()">
        <input type="number" id="fillGreenNum" min="0" max="255" value="0" oninput="updateFillColorFromNum()">
      </div>
      <div class="color-slider-row">
        <label style="color: #45b7d1;">B</label>
        <input type="range" id="fillBlue" min="0" max="255" value="0" oninput="updateFillColor()">
        <input type="number" id="fillBlueNum" min="0" max="255" value="0" oninput="updateFillColorFromNum()">
      </div>
      <div class="opacity-control">
        <label style="display: block; font-size: 0.8rem; color: #94a3b8; margin-bottom: 0.4rem;">Opacity</label>
        <input type="range" id="fillOpacity" min="0" max="100" value="100" oninput="updateFillColor()">
        <span id="fillOpacityVal" style="color: #94a3b8; font-size: 0.8rem; float: right;">100%</span>
      </div>
    </div>
    <button class="btn btn-primary" style="width: 100%; margin-top: 1rem;" onclick="applyFillColor()">Apply</button>
  </div>

  <!-- Stroke Color Picker Popup -->
  <div class="color-picker-popup" id="strokeColorPicker" style="top: 160px;">
    <h4>Stroke Color</h4>
    <div class="color-preview-large" id="strokeColorPreview">#000000</div>
    <div class="color-sliders">
      <div class="color-slider-row">
        <label style="color: #ff6b6b;">R</label>
        <input type="range" id="strokeRed" min="0" max="255" value="0" oninput="updateStrokeColor()">
        <input type="number" id="strokeRedNum" min="0" max="255" value="0" oninput="updateStrokeColorFromNum()">
      </div>
      <div class="color-slider-row">
        <label style="color: #4ecdc4;">G</label>
        <input type="range" id="strokeGreen" min="0" max="255" value="0" oninput="updateStrokeColor()">
        <input type="number" id="strokeGreenNum" min="0" max="255" value="0" oninput="updateStrokeColorFromNum()">
      </div>
      <div class="color-slider-row">
        <label style="color: #45b7d1;">B</label>
        <input type="range" id="strokeBlue" min="0" max="255" value="0" oninput="updateStrokeColor()">
        <input type="number" id="strokeBlueNum" min="0" max="255" value="0" oninput="updateStrokeColorFromNum()">
      </div>
      <div class="opacity-control">
        <label style="display: block; font-size: 0.8rem; color: #94a3b8; margin-bottom: 0.4rem;">Opacity</label>
        <input type="range" id="strokeOpacity" min="0" max="100" value="100" oninput="updateStrokeColor()">
        <span id="strokeOpacityVal" style="color: #94a3b8; font-size: 0.8rem; float: right;">100%</span>
      </div>
    </div>
    <button class="btn btn-primary" style="width: 100%; margin-top: 1rem;" onclick="applyStrokeColor()">Apply</button>
  </div>

  <div id="canvas-container">
    <div id="loader">Vector Editor Pro ‚Ä¢ Initializing...</div>
    
    <!-- Rulers -->
    <div class="ruler-corner" id="rulerCorner"></div>
    <div class="ruler ruler-h" id="rulerH"></div>
    <div class="ruler ruler-v" id="rulerV"></div>
    
    <canvas id="canvas" resize></canvas>
    
    <!-- Selection Box -->
    <div class="selection-box" id="selectionBox"></div>
    
    <!-- Artboard indicator -->
    <div id="artboardIndicator" class="artboard" style="display:none">
      <div class="artboard-label">Artboard 1</div>
    </div>
  </div>

  <!-- Left Toolbar -->
  <div id="floatingToolbar">
    <div class="tool-group">
      <div class="tool-btn active" id="selectTool" title="Selection Tool (V)">‚¨ö</div>
      <div class="tool-btn" id="directSelectTool" title="Direct Selection Tool (A)">‚Üñ</div>
      <div class="tool-btn" id="magicWandTool" title="Magic Wand Tool (Y)">‚ú¶</div>
    </div>
    <div class="tool-group">
      <div class="tool-btn" id="penTool" title="Pen Tool (P)">‚úí</div>
      <div class="tool-btn" id="pencilTool" title="Pencil Tool (N)">‚úé</div>
      <div class="tool-btn" id="brushTool" title="Brush Tool (B)">üñå</div>
    </div>
    <div class="tool-group">
      <div class="tool-btn" id="rectangleTool" title="Rectangle Tool (M)">‚ñ°</div>
      <div class="tool-btn" id="ellipseTool" title="Ellipse Tool (L)">‚óã</div>
      <div class="tool-btn" id="roundedRectangleTool" title="Rounded Rectangle Tool">‚ñ¢</div>
      <div class="tool-btn" id="polygonTool" title="Polygon Tool">‚¨°</div>
      <div class="tool-btn" id="starTool" title="Star Tool">‚òÖ</div>
      <div class="tool-btn" id="lineTool" title="Line Tool (/)">‚ï±</div>
    </div>
    <div class="tool-group">
      <div class="tool-btn" id="typeTool" title="Type Tool (T)">T</div>
      <div class="tool-btn" id="typeOnPathTool" title="Type on Path Tool">‚Üù</div>
      <div class="tool-btn" id="touchTypeTool" title="Touch Type Tool">ùì£</div>
    </div>
    <div class="tool-group">
      <div class="tool-btn" id="shapeBuilderTool" title="Shape Builder Tool (Shift+M)">‚ßÜ</div>
      <div class="tool-btn" id="perspectiveGridTool" title="Perspective Grid Tool">‚ñ¶</div>
      <div class="tool-btn" id="freeTransformTool" title="Free Transform Tool (E)">‚§°</div>
    </div>
    <div class="tool-group">
      <div class="tool-btn" id="eyedropperTool" title="Eyedropper Tool (I)">üíß</div>
      <div class="tool-btn" id="measureTool" title="Measure Tool">üìè</div>
    </div>
    <div class="tool-group">
      <div class="tool-btn" id="handTool" title="Hand Tool (H)">‚úã</div>
      <div class="tool-btn" id="zoomTool" title="Zoom Tool (Z)">üîç</div>
    </div>
    <div class="tool-group">
      <div class="tool-btn" id="fillColor" title="Fill Color">‚óê</div>
      <div class="tool-btn" id="strokeColor" title="Stroke Color">‚≠ò</div>
      <div class="tool-btn" id="defaultColors" title="Default Colors">‚ö¨</div>
    </div>
  </div>

  <!-- Right Panel Dock -->
  <div class="panel-dock visible" id="panelDock">
    <button id="dockToggle">‚óÄ</button>
    
    <div class="panel-tabs">
      <button class="panel-tab active" data-panel="properties">Properties</button>
      <button class="panel-tab" data-panel="layers">Layers</button>
      <button class="panel-tab" data-panel="appearance">Appearance</button>
      <button class="panel-tab" data-panel="swatches">Swatches</button>
      <button class="panel-tab" data-panel="gradient">Gradient</button>
      <button class="panel-tab" data-panel="stroke">Stroke</button>
      <button class="panel-tab" data-panel="align">Align</button>
      <button class="panel-tab" data-panel="character">Character</button>
      <button class="panel-tab" data-panel="paragraph">Paragraph</button>
      <button class="panel-close-btn" id="panelCloseBtn" title="Close Panel">√ó</button>
    </div>
    
    <div class="panel-content">
      <!-- Properties Panel -->
      <div id="panel-properties" class="panel-section active">
        <h3>Transform</h3>
        <div class="control-row">
          <div class="control-group" style="flex:1">
            <label>X</label>
            <input type="number" id="propX" onchange="updateTransform()">
          </div>
          <div class="control-group" style="flex:1">
            <label>Y</label>
            <input type="number" id="propY" onchange="updateTransform()">
          </div>
        </div>
        <div class="control-row">
          <div class="control-group" style="flex:1">
            <label>W</label>
            <input type="number" id="propW" onchange="updateTransform()">
          </div>
          <div class="control-group" style="flex:1">
            <label>H</label>
            <input type="number" id="propH" onchange="updateTransform()">
          </div>
        </div>
        <div class="control-row">
          <div class="control-group" style="flex:1">
            <label>Rotation</label>
            <input type="number" id="propRotation" onchange="updateTransform()">
          </div>
          <div class="control-group" style="flex:1">
            <label>Shear</label>
            <input type="number" id="propShear" onchange="updateTransform()">
          </div>
        </div>
        <div class="control-group">
          <label>Opacity <span id="opacityVal">100</span>%</label>
          <input type="range" id="propOpacity" min="0" max="100" value="100" oninput="updateOpacity()">
        </div>
        <div class="control-group">
          <label>Blend Mode</label>
          <select id="propBlendMode" onchange="updateBlendMode()">
            <option value="normal">Normal</option>
            <option value="multiply">Multiply</option>
            <option value="screen">Screen</option>
            <option value="overlay">Overlay</option>
            <option value="darken">Darken</option>
            <option value="lighten">Lighten</option>
            <option value="color-dodge">Color Dodge</option>
            <option value="color-burn">Color Burn</option>
            <option value="hard-light">Hard Light</option>
            <option value="soft-light">Soft Light</option>
            <option value="difference">Difference</option>
            <option value="exclusion">Exclusion</option>
            <option value="hue">Hue</option>
            <option value="saturation">Saturation</option>
            <option value="color">Color</option>
            <option value="luminosity">Luminosity</option>
          </select>
        </div>
        
        <h3>Geometry</h3>
        <div class="control-row">
          <button class="btn btn-sm" onclick="convertToPoint()">Convert to Point</button>
          <button class="btn btn-sm" onclick="convertToCurve()">Convert to Curve</button>
        </div>
      </div>

      <!-- Layers Panel -->
      <div id="panel-layers" class="panel-section">
        <div class="control-row" style="margin-bottom: 1rem;">
          <button class="btn btn-sm" onclick="addLayer()">+ New Layer</button>
          <button class="btn btn-sm" onclick="deleteLayer()">Delete Layer</button>
        </div>
        <div id="layersList">
          <!-- Layers will be populated dynamically -->
        </div>
      </div>

      <!-- Appearance Panel -->
      <div id="panel-appearance" class="panel-section">
        <div class="control-row" style="margin-bottom: 1rem;">
          <button class="btn btn-sm btn-primary" onclick="addFill()">+ Add Fill</button>
          <button class="btn btn-sm" onclick="addStroke()">+ Add Stroke</button>
        </div>
        <div id="appearanceList">
          <!-- Appearance items will be populated dynamically -->
        </div>
        <h3>Effects</h3>
        <button class="btn btn-sm" style="width:100%">+ Add Effect</button>
      </div>

      <!-- Swatches Panel -->
      <div id="panel-swatches" class="panel-section">
        <div class="control-row" style="margin-bottom: 1rem;">
          <button class="btn btn-sm" onclick="addSwatch()">+ New Swatch</button>
          <button class="btn btn-sm" onclick="clearSwatches()">Clear</button>
        </div>
        <div class="swatch-grid" id="swatchGrid">
          <!-- Swatches will be populated dynamically -->
        </div>
      </div>

      <!-- Gradient Panel -->
      <div id="panel-gradient" class="panel-section">
        <h3>Gradient Type</h3>
        <div class="btn-group" style="margin-bottom: 1rem;">
          <button class="btn" onclick="setGradientType('linear')">Linear</button>
          <button class="btn" onclick="setGradientType('radial')">Radial</button>
        </div>
        
        <h3>Gradient Stops</h3>
        <div id="gradientStops">
          <div class="control-row">
            <div class="control-group" style="flex:1">
              <label>Stop 1</label>
              <input type="color" id="gradientStop1" value="#60a5fa">
            </div>
            <div class="control-group" style="flex:1">
              <label>Position</label>
              <input type="range" id="gradientPos1" min="0" max="100" value="0">
            </div>
          </div>
          <div class="control-row">
            <div class="control-group" style="flex:1">
              <label>Stop 2</label>
              <input type="color" id="gradientStop2" value="#020617">
            </div>
            <div class="control-group" style="flex:1">
              <label>Position</label>
              <input type="range" id="gradientPos2" min="0" max="100" value="100">
            </div>
          </div>
        </div>
        
        <h3>Angle</h3>
        <div class="control-row">
          <input type="range" id="gradientAngle" min="0" max="360" value="0">
          <span id="gradientAngleVal">0¬∞</span>
        </div>
      </div>

      <!-- Stroke Panel -->
      <div id="panel-stroke" class="panel-section">
        <div class="control-group">
          <label>Weight</label>
          <input type="range" id="strokeWeight" min="0" max="100" value="1" oninput="updateStroke()">
          <span id="strokeWeightVal">1 px</span>
        </div>
        <div class="control-group">
          <label>Cap</label>
          <div class="btn-group">
            <button class="btn" onclick="setStrokeCap('butt')">Butt</button>
            <button class="btn" onclick="setStrokeCap('round')">Round</button>
            <button class="btn" onclick="setStrokeCap('square')">Square</button>
          </div>
        </div>
        <div class="control-group">
          <label>Join</label>
          <div class="btn-group">
            <button class="btn" onclick="setStrokeJoin('miter')">Miter</button>
            <button class="btn" onclick="setStrokeJoin('round')">Round</button>
            <button class="btn" onclick="setStrokeJoin('bevel')">Bevel</button>
          </div>
        </div>
        <div class="control-group">
          <label>Dash Array</label>
          <input type="text" id="strokeDash" placeholder="5,5" oninput="updateStroke()">
        </div>
        <div class="control-group">
          <label>Color</label>
          <input type="color" id="strokeColorInput" value="#000000" oninput="updateStroke()">
        </div>
      </div>

      <!-- Align Panel -->
      <div id="panel-align" class="panel-section">
        <h3>Align Objects</h3>
        <div class="align-grid">
          <button class="align-btn" onclick="align('left')" title="Align Left">‚¨Ö</button>
          <button class="align-btn" onclick="align('center-h')" title="Align Center">‚¨å</button>
          <button class="align-btn" onclick="align('right')" title="Align Right">‚û°</button>
          <button class="align-btn" onclick="align('top')" title="Align Top">‚¨Ü</button>
          <button class="align-btn" onclick="align('center-v')" title="Align Center">‚¨ç</button>
          <button class="align-btn" onclick="align('bottom')" title="Align Bottom">‚¨á</button>
        </div>
        
        <h3>Distribute Objects</h3>
        <div class="align-grid">
          <button class="align-btn" onclick="distribute('left')">‚´∑</button>
          <button class="align-btn" onclick="distribute('center-h')">‚´∏</button>
          <button class="align-btn" onclick="distribute('right')">‚´π</button>
          <button class="align-btn" onclick="distribute('top')">‚¨è</button>
          <button class="align-btn" onclick="distribute('center-v')">‚¨é</button>
          <button class="align-btn" onclick="distribute('bottom')">‚¨ê</button>
        </div>
      </div>

      <!-- Character Panel -->
      <div id="panel-character" class="panel-section">
        <div class="control-group">
          <label>Font Family</label>
          <select id="fontFamily" onchange="updateTypography()">
            <option value="Arial">Arial</option>
            <option value="Helvetica">Helvetica</option>
            <option value="Times New Roman">Times New Roman</option>
            <option value="Georgia">Georgia</option>
            <option value="Verdana">Verdana</option>
            <option value="Courier New">Courier New</option>
            <option value="Impact">Impact</option>
            <option value="Comic Sans MS">Comic Sans MS</option>
          </select>
        </div>
        <div class="control-row">
          <div class="control-group" style="flex:1">
            <label>Font Size</label>
            <input type="number" id="fontSize" value="32" onchange="updateTypography()">
          </div>
          <div class="control-group" style="flex:1">
            <label>Leading</label>
            <input type="number" id="lineHeight" value="40" onchange="updateTypography()">
          </div>
        </div>
        <div class="control-row">
          <div class="control-group" style="flex:1">
            <label>Tracking</label>
            <input type="number" id="letterSpacing" value="0" onchange="updateTypography()">
          </div>
        </div>
        <div class="btn-group" style="margin-bottom: 1rem;">
          <button class="btn" onclick="setFontStyle('bold')">B</button>
          <button class="btn" onclick="setFontStyle('italic')">I</button>
          <button class="btn" onclick="setFontStyle('underline')">U</button>
        </div>
        <div class="btn-group">
          <button class="btn" onclick="setTextAlign('left')">‚¨Ö</button>
          <button class="btn" onclick="setTextAlign('center')">‚¨å</button>
          <button class="btn" onclick="setTextAlign('right')">‚û°</button>
          <button class="btn" onclick="setTextAlign('justify')">‚â°</button>
        </div>
      </div>

      <!-- Paragraph Panel -->
      <div id="panel-paragraph" class="panel-section">
        <div class="control-group">
          <label>Alignment</label>
          <div class="btn-group">
            <button class="btn" onclick="setTextAlign('left')">Left</button>
            <button class="btn" onclick="setTextAlign('center')">Center</button>
            <button class="btn" onclick="setTextAlign('right')">Right</button>
            <button class="btn" onclick="setTextAlign('justify')">Justify</button>
          </div>
        </div>
        <div class="control-row">
          <div class="control-group" style="flex:1">
            <label>Left Indent</label>
            <input type="number" id="indentLeft" value="0" onchange="updateTypography()">
          </div>
          <div class="control-group" style="flex:1">
            <label>Right Indent</label>
            <input type="number" id="indentRight" value="0" onchange="updateTypography()">
          </div>
        </div>
        <div class="control-group">
          <label>First Line Indent</label>
          <input type="number" id="indentFirst" value="0" onchange="updateTypography()">
        </div>
        <div class="control-group">
          <label>Space Before</label>
          <input type="number" id="spaceBefore" value="0" onchange="updateTypography()">
        </div>
        <div class="control-group">
          <label>Space After</label>
          <input type="number" id="spaceAfter" value="0" onchange="updateTypography()">
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Firebase Auth -->
<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js";
import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-auth.js";
import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB4JMVBMcWcN2wKsaVYmnggHH5ue1mUfaA",
  authDomain: "bowesproduct.firebaseapp.com",
  projectId: "bowesproduct"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const provider = new GoogleAuthProvider();

const authBtn = document.getElementById("authBtn");
const profilePic = document.getElementById("profilePic");
const levelInfo = document.getElementById("levelInfo");
const levelText = document.getElementById("levelText");
const xpBar = document.getElementById("xpBar");

authBtn.onclick = () => auth.currentUser ? signOut(auth) : signInWithPopup(auth, provider);

onAuthStateChanged(auth, async (user) => {
  if (!user) {
    authBtn.textContent = "Login";
    profilePic.style.display = "none";
    levelInfo.style.display = "none";
    return;
  }
  authBtn.textContent = "Logout";
  profilePic.src = user.photoURL || "";
  profilePic.style.display = "block";

  const ref = doc(db, "users", user.uid);
  let snap = await getDoc(ref);
  if (!snap.exists()) {
    await setDoc(ref, { xp: 10 });
    snap = await getDoc(ref);
  }
  const xp = snap.data().xp || 0;
  const levels = [0, 200, 500, 1000, 2000];
  let level = levels.filter(v => xp >= v).length - 1;
  let next = levels[level + 1] ?? levels[level];
  let progress = next === levels[level] ? 100 :
    ((xp - levels[level]) / (next - levels[level])) * 100;

  levelText.textContent = `Level ${level} ‚Ä¢ ${xp} XP`;
  xpBar.style.width = progress + "%";
  levelInfo.style.display = "block";
});
</script>

<!-- Paper.js Vector Editor -->
<script type="text/javascript">
// Setup Paper.js manually
paper.setup(document.getElementById('canvas'));
paper.install(window);

  var longPressTimeout = null;
var isLongPress = false;
var dragStartPoint = null;

console.log('Paper.js script starting...');

// Global state
var tools = {};
var currentTool;
var fillColor = new Color(1, 0, 0);
var strokeColor = new Color(0, 0, 0);
var strokeWidth = 1;
var currentPath;
var isDrawing = false;
var startPoint;
var currentShape;
var clipboard = null;
var undoStack = [];
var redoStack = [];
var showGrid = false;
var showRulers = true;
var snapToGrid = false;
var gridSize = 20;
var layers = [];
var currentLayerIndex = 0;
var zoomLevel = 1;
var artboardRotation = 0;
var artboardSize = { width: 595, height: 842 };
var selectionStart = null;
var selectionBox = document.getElementById('selectionBox');
var isPanning = false;
var panStart = null;
var scrollWheelLocked = false;

// Tool settings
var brushSize = 5;
var brushSmoothing = 5;
var polygonSides = 6;
var starPoints = 5;
var starInnerRadius = 40;
var textFontSize = 32;
var textFontFamily = 'Arial';
var textAlignment = 'left';
var cornerRadius = 10;

console.log('Paper.js initialized, view size:', view.size);

function initLayers() {
    // Clear existing layers
    while (project.layers.length > 0) {
        project.layers[0].remove();
    }
    var backgroundLayer = new Layer();
    backgroundLayer.name = 'Background';
    backgroundLayer.locked = true;

    var layer1 = new Layer();
    layer1.name = 'Layer 1';
    layer1.visible = true;
    layer1.locked = false;
    layer1.activate();

    // Create artboard in background layer
    backgroundLayer.activate();
    createArtboard();
    layer1.activate();  // back to default

    updateLayersList();
}

// Create artboard (A4 page)
function createArtboard() {
  var artboard = new Path.Rectangle({
    point: [view.center.x - artboardSize.width / 2, view.center.y - artboardSize.height / 2],
    size: [artboardSize.width, artboardSize.height],
    fillColor: 'white',
    strokeColor: '#334155',
    strokeWidth: 1
  });
  artboard.name = 'Artboard';
  artboard.locked = true;
  return artboard;
}

// Tool/Panel Notification System
var notificationTimeout;

function showToolNotification(text) {
  var notification = document.getElementById('toolNotification');
  
  if (notificationTimeout) {
    clearTimeout(notificationTimeout);
  }
  
  notification.classList.remove('show', 'hide');
  notification.textContent = text;
  
  requestAnimationFrame(function() {
    notification.classList.add('show');
  });
  
  notificationTimeout = setTimeout(function() {
    notification.classList.remove('show');
    notification.classList.add('hide');
  }, 1500);
}

// Toggle tool panel
function toggleToolPanel(panelId) {
  var panel = document.getElementById(panelId);
  if (panel) {
    panel.classList.toggle('active');
    
    // Find the tool button and update its state
    var toolName = panelId.replace('ToolPanel', '');
    var toolBtn = document.getElementById(toolName + 'Tool');
    if (toolBtn) {
      toolBtn.classList.toggle('panel-open', panel.classList.contains('active'));
    }
  }
}

// Tool activation
function activateTool(name) {
  if (tools[name]) {
    currentTool = tools[name];
    currentTool.activate();
    console.log('Tool activated:', name);
    
    // Update all tool buttons
    document.querySelectorAll('.tool-btn').forEach(function(btn) {
      btn.classList.remove('active', 'deactivated', 'panel-open');
    });
    
    var btn = document.getElementById(name + 'Tool');
    if (btn) {
      btn.classList.add('active');
    }
    
    // Close all tool panels
    document.querySelectorAll('.tool-panel').forEach(function(panel) {
      panel.classList.remove('active');
    });
    
    // Open the corresponding tool panel
    var panel = document.getElementById(name + 'ToolPanel');
    if (panel) {
      panel.classList.add('active');
      if (btn) btn.classList.add('panel-open');
    }
    
    var toolNames = {
      'select': 'Selection Tool',
      'directSelect': 'Direct Selection Tool',
      'magicWand': 'Magic Wand Tool',
      'pen': 'Pen Tool',
      'pencil': 'Pencil Tool',
      'brush': 'Brush Tool',
      'rectangle': 'Rectangle Tool',
      'roundedRectangle': 'Rounded Rectangle Tool',
      'ellipse': 'Ellipse Tool',
      'polygon': 'Polygon Tool',
      'star': 'Star Tool',
      'line': 'Line Tool',
      'type': 'Type Tool',
      'typeOnPath': 'Type on Path Tool',
      'touchType': 'Touch Type Tool',
      'shapeBuilder': 'Shape Builder Tool',
      'perspectiveGrid': 'Perspective Grid Tool',
      'freeTransform': 'Free Transform Tool',
      'eyedropper': 'Eyedropper Tool',
      'measure': 'Measure Tool',
      'hand': 'Hand Tool',
      'zoom': 'Zoom Tool'
    };
    
    var statusTool = document.getElementById('statusTool');
    if (statusTool && toolNames[name]) {
      statusTool.textContent = toolNames[name];
    }
    
    if (toolNames[name]) {
      showToolNotification(toolNames[name]);
    }
  } else {
    console.warn('Tool not found:', name);
  }
}

// Selection Tool with FIXED selection box and proper movement
tools.select = new Tool();

var longPressTimeout = null;
var isLongPress = false;
var moveStartPoint = null;  // for arrow keys & middle click

tools.select.onMouseDown = function(event) {
    // Reset long-press state
    isLongPress = false;
    if (longPressTimeout) clearTimeout(longPressTimeout);

    var hit = project.hitTest(event.point, {
        fill: true,
        stroke: true,
        segments: true,
        tolerance: 12
    });

    if (hit && hit.item && !hit.item.locked && hit.item.name !== 'Artboard') {
        // Clicked on an object
        if (!Key.modifiers.shift) {
            project.deselectAll();
        }
        hit.item.selected = true;

        // Start long-press timer for mobile move
        longPressTimeout = setTimeout(() => {
            isLongPress = true;
        }, 400);  // 400ms hold ‚Üí allow move on mobile

        moveStartPoint = event.point;
    } else {
        // Clicked on empty space ‚Üí start marquee
        if (!Key.modifiers.shift) {
            project.deselectAll();
        }
        selectionStart = event.point;
    }

    updateProperties();
};

tools.select.onMouseDrag = function(event) {
    if (selectionStart) {
        // Marquee selection - always immediate
        var rect = new Rectangle(selectionStart, event.point);
        var screenStart = view.projectToView(selectionStart);
        var screenEnd = view.projectToView(event.point);

        selectionBox.style.display = 'block';
        selectionBox.style.left = (Math.min(screenStart.x, screenEnd.x) + 60) + 'px';
        selectionBox.style.top = (Math.min(screenStart.y, screenEnd.y) + 20) + 'px';
        selectionBox.style.width = Math.abs(screenEnd.x - screenStart.x) + 'px';
        selectionBox.style.height = Math.abs(screenEnd.y - screenStart.y) + 'px';

        // Select items inside marquee
        project.deselectAll();
        project.activeLayer.children.forEach(item => {
            if (item.name !== 'Artboard' && !item.locked && item.bounds.intersects(rect)) {
                item.selected = true;
            }
        });
    } else if (project.selectedItems.length > 0 && (isLongPress || !event.event.touches)) {
        // Move selected objects
        // On desktop: move immediately
        // On mobile: move only after long press (isLongPress = true)
        var delta = event.delta;
        if (snapToGrid) {
            delta.x = Math.round(delta.x / gridSize) * gridSize;
            delta.y = Math.round(delta.y / gridSize) * gridSize;
        }
        project.selectedItems.forEach(item => {
            if (!item.locked && item.name !== 'Artboard') {
                item.position += delta;
            }
        });
        updateProperties();
    }
};

tools.select.onMouseUp = function(event) {
    selectionBox.style.display = 'none';
    selectionStart = null;
    if (longPressTimeout) clearTimeout(longPressTimeout);
    isLongPress = false;
    saveState();
};

tools.directSelect.onMouseDrag = function(event) {
  var selectedSegments = [];
  project.activeLayer.children.forEach(function(item) {
    if (item.segments) {
      item.segments.forEach(function(segment) {
        if (segment.selected) {
          selectedSegments.push(segment);
        }
      });
    }
  });
  
  if (selectedSegments.length) {
    selectedSegments.forEach(function(segment) {
      segment.point += event.delta;
    });
  }
};

// Magic Wand Tool
tools.magicWand = new Tool();

tools.magicWand.onMouseDown = function(event) {
  var hit = project.hitTest(event.point, {
    fill: true,
    stroke: true,
    tolerance: 5
  });
  
  if (hit && hit.item) {
    var targetColor = null;
    if (hit.type === 'fill' && hit.item.fillColor) {
      targetColor = hit.item.fillColor;
    } else if (hit.type === 'stroke' && hit.item.strokeColor) {
      targetColor = hit.item.strokeColor;
    }
    
    if (targetColor) {
      if (!Key.modifiers.shift) {
        project.deselectAll();
      }
      
      project.activeLayer.children.forEach(function(item) {
        if (item.name !== 'Artboard' && !item.locked) {
          if (item.fillColor && item.fillColor.equals(targetColor)) {
            item.selected = true;
          } else if (item.strokeColor && item.strokeColor.equals(targetColor)) {
            item.selected = true;
          }
        }
      });
      
      showToolNotification('Selected matching colors');
    }
  }
};

// Pen Tool with bezier curve support
tools.pen = new Tool();
var penPoints = [];
var currentPath = null;

tools.pen.onMouseDown = function(event) {
  if (currentPath && penPoints.length > 0 && event.point.isClose(penPoints[0], 5)) {
    // Close path
    currentPath.closed = true;
    currentPath.fillColor = fillColor;
    currentPath.strokeColor = strokeColor;
    currentPath.strokeWidth = parseFloat(document.getElementById('penStrokeWidth').value);
    currentPath.simplify();
    currentPath.selected = true;
    penPoints = [];
    currentPath = null;
    saveState();
    return;
  }
  
  if (!currentPath) {
    currentPath = new Path();
    currentPath.strokeColor = strokeColor;
    currentPath.strokeWidth = parseFloat(document.getElementById('penStrokeWidth').value);
    penPoints = [];
  }
  
  currentPath.add(event.point);
  penPoints.push(event.point);
};

tools.pen.onMouseDrag = function(event) {
  if (currentPath && penPoints.length > 0) {
    var lastSegment = currentPath.lastSegment;
    if (lastSegment) {
      var handlePoint = event.point;
      lastSegment.handleOut = handlePoint.subtract(lastSegment.point);
      lastSegment.handleIn = lastSegment.handleOut.rotate(180);
    }
  }
};

tools.pen.onMouseUp = function(event) {
  // Point is finalized
};

tools.pen.onMouseMove = function(event) {
  if (currentPath && penPoints.length > 0) {
    document.body.style.cursor = 'crosshair';
  }
};

tools.pen.onKeyDown = function(event) {
  if (event.key === 'escape') {
    if (currentPath) {
      if (currentPath.segments.length > 1) {
        currentPath.fillColor = fillColor;
        currentPath.simplify();
        saveState();
      } else {
        currentPath.remove();
      }
      currentPath = null;
      penPoints = [];
    }
  } else if (event.key === 'enter') {
    if (currentPath) {
      currentPath.closed = true;
      currentPath.fillColor = fillColor;
      currentPath.strokeColor = strokeColor;
      currentPath.strokeWidth = parseFloat(document.getElementById('penStrokeWidth').value);
      currentPath.simplify();
      currentPath.selected = true;
      currentPath = null;
      penPoints = [];
      saveState();
    }
  }
};

// Pencil Tool
tools.pencil = new Tool();
tools.pencil.minDistance = 5;

tools.pencil.onMouseDown = function(event) {
  currentPath = new Path();
  currentPath.strokeColor = strokeColor;
  currentPath.strokeWidth = strokeWidth;
  currentPath.add(event.point);
};

tools.pencil.onMouseDrag = function(event) {
  currentPath.add(event.point);
};

tools.pencil.onMouseUp = function(event) {
  if (currentPath) {
    currentPath.simplify();
    currentPath.fillColor = fillColor;
    currentPath.selected = true;
    saveState();
    currentPath = null;
  }
};

// Brush Tool with settings
tools.brush = new Tool();
tools.brush.minDistance = 2;

tools.brush.onMouseDown = function(event) {
  currentPath = new Path();
  currentPath.strokeColor = strokeColor;
  currentPath.strokeWidth = brushSize;
  currentPath.strokeCap = document.getElementById('brushStyle').value;
  currentPath.strokeJoin = document.getElementById('brushStyle').value;
  currentPath.add(event.point);
};

tools.brush.onMouseDrag = function(event) {
  currentPath.add(event.point);
};

tools.brush.onMouseUp = function(event) {
  if (currentPath) {
    for (var i = 0; i < brushSmoothing; i++) {
      currentPath.smooth();
    }
    currentPath.fillColor = fillColor;
    currentPath.selected = true;
    saveState();
    currentPath = null;
  }
};

// Rectangle Tool with fixed behavior
tools.rectangle = new Tool();

tools.rectangle.onMouseDown = function(event) {
  startPoint = event.point;
  currentShape = new Path.Rectangle(startPoint, startPoint);
  currentShape.fillColor = fillColor;
  currentShape.strokeColor = strokeColor;
  currentShape.strokeWidth = strokeWidth;
};

tools.rectangle.onMouseDrag = function(event) {
  if (currentShape) {
    var rect = new Rectangle(startPoint, event.point);
    if (Key.modifiers.shift) {
      var size = Math.max(Math.abs(rect.width), Math.abs(rect.height));
      rect = new Rectangle(startPoint, new Point(startPoint.x + size, startPoint.y + size));
    }
    currentShape.remove();
    currentShape = new Path.Rectangle(rect);
    currentShape.fillColor = fillColor;
    currentShape.strokeColor = strokeColor;
    currentShape.strokeWidth = strokeWidth;
  }
};

tools.rectangle.onMouseUp = function() {
  if (currentShape) {
    currentShape.selected = true;
    saveState();
    currentShape = null;
  }
};

// NEW: Rounded Rectangle Tool
tools.roundedRectangle = new Tool();

tools.roundedRectangle.onMouseDown = function(event) {
  startPoint = event.point;
  currentShape = new Path.Rectangle({
    point: startPoint,
    size: [0, 0],
    radius: cornerRadius
  });
  currentShape.fillColor = fillColor;
  currentShape.strokeColor = strokeColor;
  currentShape.strokeWidth = strokeWidth;
};

tools.roundedRectangle.onMouseDrag = function(event) {
  if (currentShape) {
    var rect = new Rectangle(startPoint, event.point);
    if (Key.modifiers.shift) {
      var size = Math.max(Math.abs(rect.width), Math.abs(rect.height));
      rect = new Rectangle(startPoint, new Point(startPoint.x + size, startPoint.y + size));
    }
    currentShape.remove();
    currentShape = new Path.Rectangle({
      rectangle: rect,
      radius: cornerRadius
    });
    currentShape.fillColor = fillColor;
    currentShape.strokeColor = strokeColor;
    currentShape.strokeWidth = strokeWidth;
  }
};

tools.roundedRectangle.onMouseUp = function() {
  if (currentShape) {
    currentShape.selected = true;
    saveState();
    currentShape = null;
  }
};

// Ellipse Tool with fixed behavior
tools.ellipse = new Tool();

tools.ellipse.onMouseDown = function(event) {
  startPoint = event.point;
  currentShape = new Path.Ellipse({
    center: startPoint,
    radius: [0, 0]
  });
  currentShape.fillColor = fillColor;
  currentShape.strokeColor = strokeColor;
  currentShape.strokeWidth = strokeWidth;
};

tools.ellipse.onMouseDrag = function(event) {
  if (currentShape) {
    var rect = new Rectangle(startPoint, event.point);
    if (Key.modifiers.shift) {
      var size = Math.max(Math.abs(rect.width), Math.abs(rect.height));
      rect = new Rectangle(startPoint, new Point(startPoint.x + size, startPoint.y + size));
    }
    currentShape.remove();
    currentShape = new Path.Ellipse(rect);
    currentShape.fillColor = fillColor;
    currentShape.strokeColor = strokeColor;
    currentShape.strokeWidth = strokeWidth;
  }
};

tools.ellipse.onMouseUp = function() {
  if (currentShape) {
    currentShape.selected = true;
    saveState();
    currentShape = null;
  }
};

// Polygon Tool with sides control
tools.polygon = new Tool();

tools.polygon.onMouseDown = function(event) {
  startPoint = event.point;
  currentShape = new Path.RegularPolygon(startPoint, 0, polygonSides);
  currentShape.fillColor = fillColor;
  currentShape.strokeColor = strokeColor;
  currentShape.strokeWidth = strokeWidth;
};

tools.polygon.onMouseDrag = function(event) {
  if (currentShape) {
    var radius = startPoint.getDistance(event.point);
    currentShape.remove();
    currentShape = new Path.RegularPolygon(startPoint, radius, polygonSides);
    currentShape.fillColor = fillColor;
    currentShape.strokeColor = strokeColor;
    currentShape.strokeWidth = strokeWidth;
  }
};

tools.polygon.onMouseUp = function() {
  if (currentShape) {
    currentShape.selected = true;
    saveState();
    currentShape = null;
  }
};

// Star Tool with points control
tools.star = new Tool();

tools.star.onMouseDown = function(event) {
  startPoint = event.point;
  currentShape = new Path.Star(startPoint, 0, 0, 0, starPoints);
  currentShape.fillColor = fillColor;
  currentShape.strokeColor = strokeColor;
  currentShape.strokeWidth = strokeWidth;
};

tools.star.onMouseDrag = function(event) {
  if (currentShape) {
    var outerRadius = startPoint.getDistance(event.point);
    var innerRadius = outerRadius * (starInnerRadius / 100);
    currentShape.remove();
    currentShape = new Path.Star(startPoint, innerRadius, outerRadius, starPoints);
    currentShape.fillColor = fillColor;
    currentShape.strokeColor = strokeColor;
    currentShape.strokeWidth = strokeWidth;
  }
};

tools.star.onMouseUp = function() {
  if (currentShape) {
    currentShape.selected = true;
    saveState();
    currentShape = null;
  }
};

// Line Tool with fixed behavior
tools.line = new Tool();

tools.line.onMouseDown = function(event) {
  startPoint = event.point;
  currentShape = new Path.Line(startPoint, startPoint);
  currentShape.strokeColor = strokeColor;
  currentShape.strokeWidth = strokeWidth;
};

tools.line.onMouseDrag = function(event) {
  if (currentShape) {
    if (Key.modifiers.shift) {
      var angle = Math.atan2(event.point.y - startPoint.y, event.point.x - startPoint.x);
      angle = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4);
      var length = startPoint.getDistance(event.point);
      var endPoint = new Point(
        startPoint.x + length * Math.cos(angle),
        startPoint.y + length * Math.sin(angle)
      );
      currentShape.remove();
      currentShape = new Path.Line(startPoint, endPoint);
    } else {
      currentShape.remove();
      currentShape = new Path.Line(startPoint, event.point);
    }
    currentShape.strokeColor = strokeColor;
    currentShape.strokeWidth = strokeWidth;
  }
};

tools.line.onMouseUp = function() {
  if (currentShape) {
    currentShape.selected = true;
    saveState();
    currentShape = null;
  }
};

// Type Tool with improved UI
tools.type = new Tool();
var typeStartPoint = null;
var typeCurrentShape = null;

tools.type.onMouseDown = function(event) {
  typeStartPoint = event.point;
  typeCurrentShape = new Path.Rectangle(typeStartPoint, typeStartPoint);
  typeCurrentShape.strokeColor = '#22c55e';
  typeCurrentShape.strokeWidth = 1;
  typeCurrentShape.dashArray = [5, 5];
};

tools.type.onMouseDrag = function(event) {
  if (typeCurrentShape) {
    typeCurrentShape.remove();
    var rect = new Rectangle(typeStartPoint, event.point);
    typeCurrentShape = new Path.Rectangle(rect);
    typeCurrentShape.strokeColor = '#22c55e';
    typeCurrentShape.strokeWidth = 1;
    typeCurrentShape.dashArray = [5, 5];
  }
};

tools.type.onMouseUp = function(event) {
  if (typeCurrentShape) {
    var bounds = typeCurrentShape.bounds;
    typeCurrentShape.remove();
    
    var text = prompt('Enter text:', 'Sample Text');
    if (text) {
      var areaText = new PointText(bounds.topLeft);
      areaText.content = text;
      areaText.fillColor = fillColor;
      areaText.fontSize = textFontSize;
      areaText.fontFamily = textFontFamily;
      areaText.justification = textAlignment;
      areaText.position = bounds.center;
      areaText.selected = true;
      saveState();
    }
    typeCurrentShape = null;
    typeStartPoint = null;
  }
};

// Type on Path Tool
tools.typeOnPath = new Tool();

tools.typeOnPath.onMouseDown = function(event) {
  var hit = project.hitTest(event.point, {
    paths: true,
    stroke: true,
    tolerance: 5
  });
  
  if (hit && hit.item instanceof Path) {
    var text = prompt('Enter text:', 'Sample Text');
    if (text) {
      var pathText = new PointText(event.point);
      pathText.content = text;
      pathText.fillColor = fillColor;
      pathText.fontSize = textFontSize;
      pathText.fontFamily = textFontFamily;
      pathText.selected = true;
      
      showToolNotification('Text created on path');
      saveState();
    }
  } else {
    showToolNotification('Select a path first');
  }
};

// Touch Type Tool
tools.touchType = new Tool();

tools.touchType.onMouseDown = function(event) {
  var hit = project.hitTest(event.point, {
    fill: true,
    tolerance: 5
  });
  
  if (hit && hit.item instanceof PointText) {
    showToolNotification('Touch Type: Click and drag characters');
  } else {
    showToolNotification('Select text first');
  }
};

// Shape Builder Tool
tools.shapeBuilder = new Tool();

tools.shapeBuilder.onMouseDown = function(event) {
  var hit = project.hitTest(event.point, {
    fill: true,
    tolerance: 5
  });
  
  if (hit && hit.item) {
    if (!Key.modifiers.alt) {
      showToolNotification('Merging shapes...');
    } else {
      if (hit.item.parent) {
        hit.item.remove();
        saveState();
        showToolNotification('Shape removed');
      }
    }
  }
};

// Perspective Grid Tool
tools.perspectiveGrid = new Tool();

tools.perspectiveGrid.onMouseDown = function(event) {
  showToolNotification('Perspective Grid - Feature coming soon');
};

// Free Transform Tool
tools.freeTransform = new Tool();

tools.freeTransform.onMouseDown = function(event) {
  var hit = project.hitTest(event.point, {
    fill: true,
    tolerance: 5
  });
  
  if (hit && hit.item && !hit.item.locked) {
    if (!Key.modifiers.shift) {
      project.deselectAll();
    }
    hit.item.selected = true;
  }
};

tools.freeTransform.onMouseDrag = function(event) {
  if (project.selectedItems.length) {
    project.selectedItems.forEach(function(item) {
      if (!item.locked && item.name !== 'Artboard') {
        item.position += event.delta;
      }
    });
    updateProperties();
  }
};

tools.freeTransform.onMouseUp = function() {
  saveState();
};

// Eyedropper Tool
tools.eyedropper = new Tool();

tools.eyedropper.onMouseDown = function(event) {
  var hit = project.hitTest(event.point, {
    fill: true, 
    stroke: true, 
    tolerance: 5
  });
  
  if (hit && hit.item) {
    if (hit.type === 'fill' && hit.item.fillColor) {
      fillColor = hit.item.fillColor.clone();
      updateFillColorPreview();
    }
    if (hit.type === 'stroke' && hit.item.strokeColor) {
      strokeColor = hit.item.strokeColor.clone();
      updateStrokeColorPreview();
    }
    showToolNotification('Color picked');
  }
};

// Measure Tool
tools.measure = new Tool();
var measureStart = null;
var measureLine = null;

tools.measure.onMouseDown = function(event) {
  measureStart = event.point;
};

tools.measure.onMouseDrag = function(event) {
  if (measureLine) {
    measureLine.remove();
  }
  measureLine = new Path.Line(measureStart, event.point);
  measureLine.strokeColor = '#60a5fa';
  measureLine.strokeWidth = 1;
  measureLine.dashArray = [5, 5];
};

tools.measure.onMouseUp = function(event) {
  if (measureLine && measureStart) {
    var distance = measureStart.getDistance(event.point);
    showToolNotification('Distance: ' + distance.toFixed(2) + 'px');
    measureLine.remove();
    measureLine = null;
    measureStart = null;
  }
};

// Hand Tool (Pan) with improved controls
tools.hand = new Tool();
var handStart;

tools.hand.onMouseDown = function(event) {
  handStart = event.point;
  document.body.style.cursor = 'grabbing';
};

tools.hand.onMouseDrag = function(event) {
  var delta = event.point.subtract(handStart);
  view.center = view.center.subtract(delta);
};

tools.hand.onMouseUp = function() {
  document.body.style.cursor = 'default';
};

// Zoom Tool
tools.zoom = new Tool();

tools.zoom.onMouseDown = function(event) {
  var zoomFactor = Key.modifiers.alt ? 0.8 : 1.25;
  view.zoom = view.zoom * zoomFactor;
  view.center = event.point;
  updateZoomDisplay();
};

// Bind tool buttons
document.getElementById('selectTool').onclick = function() { activateTool('select'); };
document.getElementById('directSelectTool').onclick = function() { activateTool('directSelect'); };
document.getElementById('magicWandTool').onclick = function() { activateTool('magicWand'); };
document.getElementById('penTool').onclick = function() { activateTool('pen'); };
document.getElementById('pencilTool').onclick = function() { activateTool('pencil'); };
document.getElementById('brushTool').onclick = function() { activateTool('brush'); };
document.getElementById('rectangleTool').onclick = function() { activateTool('rectangle'); };
document.getElementById('roundedRectangleTool').onclick = function() { activateTool('roundedRectangle'); };
document.getElementById('ellipseTool').onclick = function() { activateTool('ellipse'); };
document.getElementById('polygonTool').onclick = function() { activateTool('polygon'); };
document.getElementById('starTool').onclick = function() { activateTool('star'); };
document.getElementById('lineTool').onclick = function() { activateTool('line'); };
document.getElementById('typeTool').onclick = function() { activateTool('type'); };
document.getElementById('typeOnPathTool').onclick = function() { activateTool('typeOnPath'); };
document.getElementById('touchTypeTool').onclick = function() { activateTool('touchType'); };
document.getElementById('shapeBuilderTool').onclick = function() { activateTool('shapeBuilder'); };
document.getElementById('perspectiveGridTool').onclick = function() { activateTool('perspectiveGrid'); };
document.getElementById('freeTransformTool').onclick = function() { activateTool('freeTransform'); };
document.getElementById('eyedropperTool').onclick = function() { activateTool('eyedropper'); };
document.getElementById('measureTool').onclick = function() { activateTool('measure'); };
document.getElementById('handTool').onclick = function() { activateTool('hand'); };
document.getElementById('zoomTool').onclick = function() { activateTool('zoom'); };

// Color picker buttons
document.getElementById('fillColor').onclick = function() {
  var popup = document.getElementById('fillColorPicker');
  popup.classList.toggle('active');
  document.getElementById('strokeColorPicker').classList.remove('active');
};

document.getElementById('strokeColor').onclick = function() {
  var popup = document.getElementById('strokeColorPicker');
  popup.classList.toggle('active');
  document.getElementById('fillColorPicker').classList.remove('active');
};

document.getElementById('defaultColors').onclick = function() {
  fillColor = new Color(1, 0, 0, 1);
  strokeColor = new Color(0, 0, 0, 1);
  updateFillColorPreview();
  updateStrokeColorPreview();
  
  document.getElementById('fillRed').value = 255;
  document.getElementById('fillGreen').value = 0;
  document.getElementById('fillBlue').value = 0;
  document.getElementById('fillOpacity').value = 100;
  document.getElementById('strokeRed').value = 0;
  document.getElementById('strokeGreen').value = 0;
  document.getElementById('strokeBlue').value = 0;
  document.getElementById('strokeOpacity').value = 100;
  
  if (project.selectedItems.length) {
    project.selectedItems.forEach(function(item) {
      item.fillColor = fillColor;
      item.strokeColor = strokeColor;
    });
  }
  
  showToolNotification('Default colors applied');
};

// Update fill color from sliders
function updateFillColor() {
  var r = parseInt(document.getElementById('fillRed').value);
  var g = parseInt(document.getElementById('fillGreen').value);
  var b = parseInt(document.getElementById('fillBlue').value);
  var a = parseInt(document.getElementById('fillOpacity').value) / 100;
  
  document.getElementById('fillRedNum').value = r;
  document.getElementById('fillGreenNum').value = g;
  document.getElementById('fillBlueNum').value = b;
  document.getElementById('fillOpacityVal').textContent = Math.round(a * 100) + '%';
  
  fillColor = new Color(r / 255, g / 255, b / 255, a);
  updateFillColorPreview();
}

function updateFillColorFromNum() {
  var r = parseInt(document.getElementById('fillRedNum').value);
  var g = parseInt(document.getElementById('fillGreenNum').value);
  var b = parseInt(document.getElementById('fillBlueNum').value);
  var a = parseInt(document.getElementById('fillOpacity').value) / 100;
  
  document.getElementById('fillRed').value = r;
  document.getElementById('fillGreen').value = g;
  document.getElementById('fillBlue').value = b;
  document.getElementById('fillOpacityVal').textContent = Math.round(a * 100) + '%';
  
  fillColor = new Color(r / 255, g / 255, b / 255, a);
  updateFillColorPreview();
}

function updateFillColorPreview() {
  var preview = document.getElementById('fillColorPreview');
  if (preview) {
    var css = fillColor.toCSS ? fillColor.toCSS(true) : 'rgb(255,0,0)';
    if (fillColor.alpha !== undefined && fillColor.alpha < 1) {
      css = 'rgba(' + Math.round(fillColor.red * 255) + ',' + Math.round(fillColor.green * 255) + ',' + Math.round(fillColor.blue * 255) + ',' + fillColor.alpha + ')';
    }
    preview.textContent = css;
    preview.style.backgroundColor = css;
  }
}

function applyFillColor() {
  if (project.selectedItems.length) {
    project.selectedItems.forEach(function(item) {
      item.fillColor = fillColor.clone();
    });
    saveState();
    showToolNotification('Fill color applied');
  }
  document.getElementById('fillColorPicker').classList.remove('active');
}

// Update stroke color from sliders
function updateStrokeColor() {
  var r = parseInt(document.getElementById('strokeRed').value);
  var g = parseInt(document.getElementById('strokeGreen').value);
  var b = parseInt(document.getElementById('strokeBlue').value);
  var a = parseInt(document.getElementById('strokeOpacity').value) / 100;
  
  document.getElementById('strokeRedNum').value = r;
  document.getElementById('strokeGreenNum').value = g;
  document.getElementById('strokeBlueNum').value = b;
  document.getElementById('strokeOpacityVal').textContent = Math.round(a * 100) + '%';
  
  strokeColor = new Color(r / 255, g / 255, b / 255, a);
  updateStrokeColorPreview();
}

function updateStrokeColorFromNum() {
  var r = parseInt(document.getElementById('strokeRedNum').value);
  var g = parseInt(document.getElementById('strokeGreenNum').value);
  var b = parseInt(document.getElementById('strokeBlueNum').value);
  var a = parseInt(document.getElementById('strokeOpacity').value) / 100;
  
  document.getElementById('strokeRed').value = r;
  document.getElementById('strokeGreen').value = g;
  document.getElementById('strokeBlue').value = b;
  document.getElementById('strokeOpacityVal').textContent = Math.round(a * 100) + '%';
  
  strokeColor = new Color(r / 255, g / 255, b / 255, a);
  updateStrokeColorPreview();
}

function updateStrokeColorPreview() {
  var preview = document.getElementById('strokeColorPreview');
  if (preview) {
    var css = strokeColor.toCSS ? strokeColor.toCSS(true) : 'rgb(0,0,0)';
    if (strokeColor.alpha !== undefined && strokeColor.alpha < 1) {
      css = 'rgba(' + Math.round(strokeColor.red * 255) + ',' + Math.round(strokeColor.green * 255) + ',' + Math.round(strokeColor.blue * 255) + ',' + strokeColor.alpha + ')';
    }
    preview.textContent = css;
    preview.style.backgroundColor = css;
  }
}

function applyStrokeColor() {
  if (project.selectedItems.length) {
    project.selectedItems.forEach(function(item) {
      item.strokeColor = strokeColor.clone();
    });
    saveState();
    showToolNotification('Stroke color applied');
  }
  document.getElementById('strokeColorPicker').classList.remove('active');
}

// Tool settings update functions
function updateTextToolSettings() {
  textFontSize = parseInt(document.getElementById('textFontSize').value);
  textFontFamily = document.getElementById('textFontFamily').value;
  document.getElementById('textFontSizeVal').textContent = textFontSize + 'px';
}

function setTextToolAlign(align) {
  textAlignment = align;
}

function updateBrushToolSettings() {
  brushSize = parseInt(document.getElementById('brushSize').value);
  brushSmoothing = parseInt(document.getElementById('brushSmoothing').value);
  document.getElementById('brushSizeVal').textContent = brushSize + 'px';
  document.getElementById('brushSmoothingVal').textContent = brushSmoothing;
}

function updateShapeToolSettings() {
  polygonSides = parseInt(document.getElementById('polygonSides').value);
  starPoints = parseInt(document.getElementById('starPoints').value);
  starInnerRadius = parseInt(document.getElementById('starInnerRadius').value);
  cornerRadius = parseInt(document.getElementById('cornerRadius') ? document.getElementById('cornerRadius').value : 10);
  document.getElementById('starInnerRadiusVal').textContent = starInnerRadius + '%';
}

function updatePenToolSettings() {
  document.getElementById('penStrokeWidthVal').textContent = document.getElementById('penStrokeWidth').value + 'px';
}

function updateZoomFromSlider() {
  var zoomValue = parseInt(document.getElementById('zoomSlider').value);
  view.zoom = zoomValue / 100;
  document.getElementById('zoomSliderVal').textContent = zoomValue + '%';
  updateZoomDisplay();
}

// Update properties panel
function updateProperties() {
  var item = project.selectedItems[0];
  var propX = document.getElementById('propX');
  var propY = document.getElementById('propY');
  var propW = document.getElementById('propW');
  var propH = document.getElementById('propH');
  var propRotation = document.getElementById('propRotation');
  var propShear = document.getElementById('propShear');
  var propOpacity = document.getElementById('propOpacity');
  var propBlendMode = document.getElementById('propBlendMode');
  
  if (item) {
    if (propX) propX.value = Math.round(item.position.x);
    if (propY) propY.value = Math.round(item.position.y);
    if (propW) propW.value = Math.round(item.bounds.width);
    if (propH) propH.value = Math.round(item.bounds.height);
    if (propRotation) propRotation.value = Math.round(item.rotation);
    if (propShear) propShear.value = Math.round(item.shear ? item.shear.x : 0);
    if (propOpacity) propOpacity.value = (item.opacity || 1) * 100;
    if (propBlendMode) propBlendMode.value = item.blendMode || 'normal';
    
    var statusSelection = document.getElementById('statusSelection');
    if (statusSelection) {
      statusSelection.textContent = item.className + ' selected';
    }
  } else {
    if (propX) propX.value = '';
    if (propY) propY.value = '';
    if (propW) propW.value = '';
    if (propH) propH.value = '';
    if (propRotation) propRotation.value = '';
    if (propShear) propShear.value = '';
    
    var statusSelection = document.getElementById('statusSelection');
    if (statusSelection) {
      statusSelection.textContent = 'No selection';
    }
  }
}

// Update transform from properties panel
function updateTransform() {
  var item = project.selectedItems[0];
  if (!item) return;
  
  var x = parseFloat(document.getElementById('propX').value);
  var y = parseFloat(document.getElementById('propY').value);
  var w = parseFloat(document.getElementById('propW').value);
  var h = parseFloat(document.getElementById('propH').value);
  var rotation = parseFloat(document.getElementById('propRotation').value);
  var shear = parseFloat(document.getElementById('propShear').value);
  
  if (!isNaN(x) && !isNaN(y)) {
    item.position = new Point(x, y);
  }
  if (!isNaN(w) && !isNaN(h)) {
    item.bounds.width = w;
    item.bounds.height = h;
  }
  if (!isNaN(rotation)) {
    item.rotation = rotation;
  }
  if (!isNaN(shear)) {
    item.shear = new Point(shear, 0);
  }
  
  saveState();
}

// Update opacity
function updateOpacity() {
  var opacity = parseFloat(document.getElementById('propOpacity').value);
  document.getElementById('opacityVal').textContent = opacity;
  
  if (project.selectedItems.length) {
    project.selectedItems.forEach(function(item) {
      item.opacity = opacity / 100;
    });
  }
}

// Update blend mode
function updateBlendMode() {
  var blendMode = document.getElementById('propBlendMode').value;
  
  if (project.selectedItems.length) {
    project.selectedItems.forEach(function(item) {
      item.blendMode = blendMode;
    });
  }
}

function updateLayersList() {
    var layersList = document.getElementById('layersList');
    if (!layersList) return;

    layersList.innerHTML = '';

    // Top layer first in list
    for (var i = project.layers.length - 1; i >= 0; i--) {
        var layer = project.layers[i];
        var layerItem = document.createElement('div');
        layerItem.className = 'layer-item' + (layer.active ? ' active' : '');
        layerItem.draggable = true;
        layerItem.dataset.index = i;
        layerItem.innerHTML = `
            <span class="layer-icon">üìÑ</span>
            <span class="layer-name">${layer.name}</span>
            <div class="layer-actions">
                <button class="btn btn-sm" onclick="toggleLayerVisibility(${i})">${layer.visible ? 'üëÅ' : 'üëÅ‚Äçüó®'}</button>
                <button class="btn btn-sm" onclick="toggleLayerLock(${i})">${layer.locked ? 'üîí' : 'üîì'}</button>
            </div>
        `;
        layerItem.onclick = function(e) {
            if (e.target.tagName !== 'BUTTON') {
                var idx = parseInt(this.dataset.index);
                project.layers[idx].activate();
                updateLayersList();
            }
        };
        layersList.appendChild(layerItem);
    }

    // Make draggable after append
    makeLayersDraggable();
}

function deleteLayer() {
  if (layers.length > 1) {
    layers.splice(currentLayerIndex, 1);
    currentLayerIndex = Math.min(currentLayerIndex, layers.length - 1);
    updateLayersList();
  }
}

function selectLayer(index) {
  currentLayerIndex = index;
  updateLayersList();
}

function toggleLayerVisibility(index) {
    var layer = project.layers[index];
    layer.visible = !layer.visible;
    updateLayersList();
}

function toggleLayerLock(index) {
    var layer = project.layers[index];
    layer.locked = !layer.locked;
    updateLayersList();
}

function addLayer() {
    var newLayer = new Layer();
    newLayer.name = 'Layer ' + project.layers.length;
    newLayer.activate();
    updateLayersList();
}

function deleteLayer() {
    if (project.layers.length > 2) {  // Keep background + at least one
        project.activeLayer.remove();
        if (project.layers.length > 1) {
            project.layers[project.layers.length - 1].activate();
        }
        updateLayersList();
    }
}

// Save/Undo/Redo
function saveState() {
  var json = project.exportJSON({ asString: false });
  undoStack.push(JSON.stringify(json));
  if (undoStack.length > 50) {
    undoStack.shift();
  }
  redoStack = [];
}

function undo() {
  if (undoStack.length > 1) {
    redoStack.push(undoStack.pop());
    project.clear();
    project.importJSON(JSON.parse(undoStack[undoStack.length - 1]));
  }
}

function redo() {
  if (redoStack.length > 0) {
    var state = redoStack.pop();
    undoStack.push(state);
    project.clear();
    project.importJSON(JSON.parse(state));
  }
}

// Edit operations
function cut() {
  if (project.selectedItems.length) {
    clipboard = JSON.stringify(project.selectedItems.map(function(item) {
      return item.exportJSON({ asString: false });
    }));
    project.selectedItems.forEach(function(item) {
      item.remove();
    });
    saveState();
  }
}

function copy() {
  if (project.selectedItems.length) {
    clipboard = JSON.stringify(project.selectedItems.map(function(item) {
      return item.exportJSON({ asString: false });
    }));
  }
}

function paste() {
  if (clipboard) {
    project.deselectAll();
    var items = JSON.parse(clipboard);
    items.forEach(function(itemData) {
      var item = project.importJSON(itemData);
      item.position = item.position.add(new Point(20, 20));
      item.selected = true;
    });
    saveState();
  }
}

function duplicate() {
  if (project.selectedItems.length) {
    project.selectedItems.forEach(function(item) {
      var clone = item.clone();
      clone.position = item.position.add(new Point(20, 20));
      clone.selected = true;
      item.selected = false;
    });
    saveState();
  }
}

function deleteSelection() {
  if (project.selectedItems.length) {
    project.selectedItems.forEach(function(item) {
      if (item.name !== 'Artboard') {
        item.remove();
      }
    });
    saveState();
    updateProperties();
  }
}

function selectAll() {
  project.activeLayer.children.forEach(function(item) {
    if (item.name !== 'Artboard' && !item.locked) {
      item.selected = true;
    }
  });
  updateProperties();
}

function deselectAll() {
  project.deselectAll();
  updateProperties();
}

// Arrange
function bringToFront() {
  if (project.selectedItems.length) {
    project.selectedItems.forEach(function(item) {
      item.sendToFront();
    });
    saveState();
  }
}

function sendToBack() {
  if (project.selectedItems.length) {
    project.selectedItems.forEach(function(item) {
      item.sendToBack();
    });
    saveState();
  }
}

function bringForward() {
  if (project.selectedItems.length) {
    project.selectedItems.forEach(function(item) {
      var siblings = project.activeLayer.children;
      var index = siblings.indexOf(item);
      if (index < siblings.length - 1) {
        item.insertAbove(siblings[index + 1]);
      }
    });
    saveState();
  }
}

function sendBackward() {
  if (project.selectedItems.length) {
    project.selectedItems.forEach(function(item) {
      var siblings = project.activeLayer.children;
      var index = siblings.indexOf(item);
      if (index > 0) {
        item.insertBelow(siblings[index - 1]);
      }
    });
    saveState();
  }
}

// FIXED: Group/Ungroup with proper functionality
function groupSelection() {
  if (project.selectedItems.length > 1) {
    var selected = Array.from(project.selectedItems);
    
    // Create a group from selected items
    var group = new Group(selected);
    
    project.deselectAll();
    group.selected = true;
    
    saveState();
    updateProperties();
    console.log('Grouped', selected.length, 'objects');
    showToolNotification('Grouped ' + selected.length + ' objects');
  } else {
    showToolNotification('Select 2 or more objects to group');
  }
}

function ungroupSelection() {
  var selected = Array.from(project.selectedItems);
  var ungroupedCount = 0;
  
  selected.forEach(function(item) {
    if (item instanceof Group) {
      item.ungroup();
      ungroupedCount++;
    }
  });
  
  if (ungroupedCount > 0) {
    saveState();
    showToolNotification('Ungrouped ' + ungroupedCount + ' groups');
  } else {
    showToolNotification('No groups selected');
  }
}

// Lock/Unlock
function lockSelection() {
  project.selectedItems.forEach(function(item) {
    item.locked = true;
  });
  project.deselectAll();
}

function unlockAll() {
  project.activeLayer.children.forEach(function(item) {
    if (item.name !== 'Artboard') {
      item.locked = false;
    }
  });
}

// Transform
function rotateSelection(angle) {
  if (project.selectedItems.length) {
    project.selectedItems.forEach(function(item) {
      item.rotate(angle);
    });
    saveState();
  }
}

function flipSelection(direction) {
  if (project.selectedItems.length) {
    project.selectedItems.forEach(function(item) {
      if (direction === 'horizontal') {
        item.scale(-1, 1);
      } else {
        item.scale(1, -1);
      }
    });
    saveState();
  }
}

// FIXED: Pathfinder operations with proper implementation
function pathfinder(operation) {
  var items = project.selectedItems.filter(function(item) {
    return item instanceof Path && item.selected && !(item instanceof Group);
  });
  
  if (items.length < 2) {
    showToolNotification('Select at least 2 paths for ' + operation);
    return;
  }
  
  var result = null;
  var keepOriginal = items.slice();
  
  try {
    switch(operation) {
      case 'unite':
        // Combine all shapes into one
        result = items[0].clone();
        for (var i = 1; i < items.length; i++) {
          result = result.unite(items[i]);
        }
        break;
        
      case 'subtract':
        // Subtract second shape from first
        result = items[0].exclude(items[1]);
        break;
        
      case 'intersect':
        // Find intersection
        result = items[0].intersect(items[1]);
        break;
        
      case 'exclude':
        // Exclude overlapping areas
        result = items[0].exclude(items[1]);
        break;
        
      case 'divide':
        // Divide shapes at intersections
        // This is a simplified version - Paper.js doesn't have direct divide
        showToolNotification('Divide - Feature coming soon');
        return;
        
      case 'trim':
        // Trim overlapping areas
        showToolNotification('Trim - Feature coming soon');
        return;
        
      case 'merge':
        // Merge shapes
        result = items[0].clone();
        for (var i = 1; i < items.length; i++) {
          result = result.unite(items[i]);
        }
        break;
        
      case 'crop':
        // Crop to intersection
        result = items[0].intersect(items[1]);
        break;
        
      case 'outline':
        // Convert strokes to outlines
        items.forEach(function(item) {
          if (item.strokeColor && item.strokeWidth > 0) {
            var outline = item.createOutline(item.strokeWidth);
            outline.fillColor = item.strokeColor;
            outline.strokeColor = null;
            item.remove();
          }
        });
        saveState();
        showToolNotification('Outlines created');
        return;
    }
    
    if (result) {
      // Remove original items
      keepOriginal.forEach(function(item) {
        item.remove();
      });
      
      // Apply colors and add result
      result.fillColor = fillColor;
      result.strokeColor = strokeColor;
      result.strokeWidth = strokeWidth;
      result.selected = true;
      
      saveState();
      showToolNotification('Pathfinder: ' + operation + ' completed');
    }
  } catch (error) {
    console.error('Pathfinder error:', error);
    showToolNotification('Pathfinder error: ' + error.message);
  }
}

// Select same
function selectSameFill() {
  if (project.selectedItems.length === 0) return;
  
  var targetColor = project.selectedItems[0].fillColor;
  project.deselectAll();
  
  project.activeLayer.children.forEach(function(item) {
    if (item.fillColor && item.fillColor.equals(targetColor)) {
      item.selected = true;
    }
  });
}

function selectSameStroke() {
  if (project.selectedItems.length === 0) return;
  
  var targetColor = project.selectedItems[0].strokeColor;
  project.deselectAll();
  
  project.activeLayer.children.forEach(function(item) {
    if (item.strokeColor && item.strokeColor.equals(targetColor)) {
      item.selected = true;
    }
  });
}

function selectSameStrokeWidth() {
  if (project.selectedItems.length === 0) return;
  
  var targetWidth = project.selectedItems[0].strokeWidth;
  project.deselectAll();
  
  project.activeLayer.children.forEach(function(item) {
    if (item.strokeWidth === targetWidth) {
      item.selected = true;
    }
  });
}

// Zoom
function zoomIn() {
  view.zoom = view.zoom * 1.25;
  updateZoomDisplay();
}

function zoomOut() {
  view.zoom = view.zoom * 0.8;
  updateZoomDisplay();
}

function zoomToFit() {
  if (project.activeLayer.children.length > 0) {
    view.fitBounds(project.activeLayer.bounds);
  } else {
    view.zoom = 1;
  }
  updateZoomDisplay();
}

function zoomTo100() {
  view.zoom = 1;
  updateZoomDisplay();
}

function updateZoomDisplay() {
  var zoomPercent = Math.round(view.zoom * 100);
  var statusZoom = document.getElementById('statusZoom');
  if (statusZoom) {
    statusZoom.textContent = zoomPercent + '%';
  }
  
  var zoomSlider = document.getElementById('zoomSlider');
  if (zoomSlider) {
    zoomSlider.value = zoomPercent;
    document.getElementById('zoomSliderVal').textContent = zoomPercent + '%';
  }
}

// View options
function toggleGrid() {
  showGrid = !showGrid;
}

function toggleRulers() {
  showRulers = !showRulers;
  var rulerH = document.getElementById('rulerH');
  var rulerV = document.getElementById('rulerV');
  var rulerCorner = document.getElementById('rulerCorner');
  
  if (rulerH) rulerH.style.display = showRulers ? 'block' : 'none';
  if (rulerV) rulerV.style.display = showRulers ? 'block' : 'none';
  if (rulerCorner) rulerCorner.style.display = showRulers ? 'block' : 'none';
}

function toggleSnap() {
  snapToGrid = !snapToGrid;
}

// Artboard options
function showArtboardOptions() {
  var width = prompt('Enter artboard width (points):', artboardSize.width);
  var height = prompt('Enter artboard height (points):', artboardSize.height);
  
  if (width && height) {
    artboardSize.width = parseInt(width);
    artboardSize.height = parseInt(height);
    
    project.activeLayer.children.forEach(function(item) {
      if (item.name === 'Artboard') {
        item.remove();
      }
    });
    
    createArtboard();
    saveState();
    showToolNotification('Artboard resized');
  }
}

function rotateArtboard(angle) {
  artboardRotation += angle;
  
  project.activeLayer.children.forEach(function(item) {
    if (item.name === 'Artboard') {
      item.rotate(angle);
    }
  });
  
  showToolNotification('Artboard rotated ' + angle + '¬∞');
}

// Draw grid
function onFrame(event) {
  if (showGrid) {
    // Grid would be drawn here
  }
}

// Export functions
function exportSVG() {
  var svg = project.exportSVG({ asString: true, embedImages: true });
  var blob = new Blob([svg], { type: 'image/svg+xml' });
  var url = URL.createObjectURL(blob);
  var a = document.createElement('a');
  a.href = url;
  a.download = 'artwork.svg';
  a.click();
  URL.revokeObjectURL(url);
}

function exportPNG() {
  var canvas = view.element;
  canvas.toBlob(function(blob) {
    var url = URL.createObjectURL(blob);
    var a = document.createElement('a');
    a.href = url;
    a.download = 'artwork.png';
    a.click();
    URL.revokeObjectURL(url);
  }, 'image/png');
}

function exportPDF() {
  var svg = project.exportSVG({ asString: true, embedImages: true });
  var blob = new Blob([svg], { type: 'application/pdf' });
  var url = URL.createObjectURL(blob);
  var a = document.createElement('a');
  a.href = url;
  a.download = 'artwork.pdf';
  a.click();
  URL.revokeObjectURL(url);
}

// File operations
function newDocument() {
  if (confirm('Create new document? All unsaved changes will be lost.')) {
    project.activeLayer.removeChildren();
    undoStack = [];
    redoStack = [];
    layers = [];
    initLayers();
    createArtboard();
    saveState();
    updateLayersList();
    updateProperties();
    console.log('New document created');
    
    var loader = document.getElementById('loader');
    if (loader) {
      loader.style.display = 'none';
    }
  }
}

function saveDocument() {
  var json = project.exportJSON({ asString: true });
  var blob = new Blob([json], { type: 'application/json' });
  var url = URL.createObjectURL(blob);
  var a = document.createElement('a');
  a.href = url;
  a.download = 'document.json';
  a.click();
  URL.revokeObjectURL(url);
}

function saveDocumentAs() {
  saveDocument();
}

function handleOpen(event) {
  var file = event.target.files[0];
  if (file) {
    var reader = new FileReader();
    reader.onload = function(e) {
      try {
        var data = e.target.result;
        if (file.name.endsWith('.json')) {
          project.clear();
          project.importJSON(data);
        } else if (file.name.endsWith('.svg')) {
          project.clear();
          project.importSVG(data);
        }
        saveState();
        console.log('File loaded successfully');
      } catch (error) {
        console.error('Error loading file:', error);
        alert('Error loading file. Please check the file format.');
      }
    };
    if (file.name.endsWith('.json')) {
      reader.readAsText(file);
    } else {
      reader.readAsText(file);
    }
  }
  event.target.value = '';
}

function handlePlace(event) {
  var file = event.target.files[0];
  if (file) {
    var reader = new FileReader();
    reader.onload = function(e) {
      var raster = new Raster({
        source: e.target.result,
        position: view.center
      });
      raster.onLoad = function() {
        console.log('Image loaded:', raster.size);
        raster.selected = true;
        saveState();
      };
    };
    reader.readAsDataURL(file);
  }
  event.target.value = '';
}

// Type operations
function createOutlines() {
  project.selectedItems.forEach(function(item) {
    if (item instanceof PointText) {
      var outline = item.createOutline();
      item.remove();
      outline.selected = true;
    }
  });
  saveState();
}

function findFont() {
  alert('Font search feature coming soon!');
}

// Transform dialog
function showTransformDialog() {
  var item = project.selectedItems[0];
  if (!item) {
    alert('Select an object first');
    return;
  }
  
  var width = prompt('Width:', Math.round(item.bounds.width));
  var height = prompt('Height:', Math.round(item.bounds.height));
  var rotation = prompt('Rotation:', Math.round(item.rotation));
  
  if (width && height && rotation) {
    item.bounds.width = parseFloat(width);
    item.bounds.height = parseFloat(height);
    item.rotation = parseFloat(rotation);
    saveState();
  }
}

// Geometry conversions
function convertToPoint() {
  alert('Convert to point - Feature coming soon');
}

function convertToCurve() {
  project.selectedItems.forEach(function(item) {
    if (item instanceof Path) {
      item.smooth();
    }
  });
  saveState();
}

// Context menu
document.addEventListener('contextmenu', function(event) {
  event.preventDefault();
  var contextMenu = document.getElementById('contextMenu');
  if (contextMenu) {
    contextMenu.style.display = 'block';
    contextMenu.style.left = event.pageX + 'px';
    contextMenu.style.top = event.pageY + 'px';
  }
});

document.addEventListener('click', function(event) {
  var contextMenu = document.getElementById('contextMenu');
  if (contextMenu) {
    contextMenu.style.display = 'none';
  }
  
  if (!event.target.closest('.color-picker-popup') && !event.target.closest('#fillColor') && !event.target.closest('#strokeColor')) {
    document.getElementById('fillColorPicker').classList.remove('active');
    document.getElementById('strokeColorPicker').classList.remove('active');
  }
});

// Desktop scroll wheel zoom and pan
var canvasElement = document.getElementById('canvas');
var isMiddlePanning = false;
var middlePanStart = null;

canvasElement.addEventListener('mousedown', function(event) {
    if (event.button === 1) {  // Middle button
        event.preventDefault();
        isMiddlePanning = true;
        middlePanStart = view.viewToProject(new Point(event.offsetX, event.offsetY));
        canvasElement.style.cursor = 'grabbing';
    }
});

canvasElement.addEventListener('mousemove', function(event) {
    if (isMiddlePanning) {
        var current = view.viewToProject(new Point(event.offsetX, event.offsetY));
        var delta = middlePanStart.subtract(current);
        view.center = view.center.add(delta);
        middlePanStart = current;
    }
});

canvasElement.addEventListener('mouseup', function(event) {
    if (event.button === 1) {
        isMiddlePanning = false;
        canvasElement.style.cursor = 'default';
    }
});

canvasElement.addEventListener('mouseleave', function() {
    isMiddlePanning = false;
    canvasElement.style.cursor = 'default';
});

// Keep your existing wheel zoom (optional: you can keep it or merge)
canvasElement.addEventListener('wheel', function(event) {
    event.preventDefault();
    if (!isMiddlePanning) {
        var zoomFactor = event.deltaY > 0 ? 0.9 : 1.1;
        view.zoom *= zoomFactor;
        updateZoomDisplay();
    }
}, { passive: false });
// Mobile touch zoom and pan - FIXED for better support
var lastTouchDistance = 0;
var lastTouchCenter = null;

canvasElement.addEventListener('touchstart', function(event) {
  if (event.touches.length === 2) {
    // Pinch to zoom
    lastTouchDistance = getTouchDistance(event.touches);
    lastTouchCenter = getTouchCenter(event.touches);
  } else if (event.touches.length === 1) {
    // Single touch - potential pan
    isPanning = true;
    panStart = new Point(event.touches[0].clientX, event.touches[0].clientY);
  }
}, { passive: true });

canvasElement.addEventListener('touchmove', function(event) {
  if (event.touches.length === 2) {
    // Pinch to zoom
    var currentDistance = getTouchDistance(event.touches);
    var zoomFactor = lastTouchDistance / currentDistance;
    
    var currentCenter = getTouchCenter(event.touches);
    var rect = canvasElement.getBoundingClientRect();
    var paperPoint = view.viewToProject(currentCenter.subtract(rect.topLeft));
    
    view.zoom = view.zoom * zoomFactor;
    updateZoomDisplay();
    
    lastTouchDistance = currentDistance;
    lastTouchCenter = currentCenter;
  } else if (event.touches.length === 1 && isPanning) {
    // Single finger pan - FIXED for proper movement
    var rect = canvasElement.getBoundingClientRect();
    var currentPoint = new Point(event.touches[0].clientX - rect.left, event.touches[0].clientY - rect.top);
    var delta = currentPoint.subtract(panStart);
    
    // Convert screen delta to paper.js delta
    var paperDelta = view.viewToProject(delta.subtract(new Point(rect.left, rect.top))).subtract(view.viewToProject(new Point(0, 0)));
    
    view.center = view.center.subtract(paperDelta);
    panStart = currentPoint;
  }
}, { passive: false });

canvasElement.addEventListener('touchend', function(event) {
  isPanning = false;
  panStart = null;
  lastTouchDistance = 0;
  lastTouchCenter = null;
});

function getTouchDistance(touches) {
  var dx = touches[0].clientX - touches[1].clientX;
  var dy = touches[0].clientY - touches[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}

function getTouchCenter(touches) {
  return new Point(
    (touches[0].clientX + touches[1].clientX) / 2,
    (touches[0].clientY + touches[1].clientY) / 2
  );
}

// Keyboard shortcuts
document.addEventListener('keydown', function(event) {
  if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;
  
  if ((event.ctrlKey || event.metaKey) && (event.key === 'n' || event.key === 'N')) {
    if (event.shiftKey) {
      event.preventDefault();
      event.stopPropagation();
      newDocument();
    }
  }
  if ((event.ctrlKey || event.metaKey) && (event.key === 's' || event.key === 'S')) {
    if (event.shiftKey) {
      event.preventDefault();
      event.stopPropagation();
      saveDocument();
    }
  }
  if ((event.ctrlKey || event.metaKey) && (event.key === 'o' || event.key === 'O')) {
    event.preventDefault();
    event.stopPropagation();
    document.getElementById('openFile').click();
  }
  
  // Tool shortcuts
  if (event.key === 'v' || event.key === 'V') {
    if (!event.ctrlKey && !event.metaKey) activateTool('select');
  }
  if (event.key === 'a' || event.key === 'A') {
    if (!event.ctrlKey && !event.metaKey) activateTool('directSelect');
  }
  if (event.key === 'y' || event.key === 'Y') {
    if (!event.ctrlKey && !event.metaKey) activateTool('magicWand');
  }
  if (event.key === 'p' || event.key === 'P') {
    if (!event.ctrlKey && !event.metaKey) activateTool('pen');
  }
  if (event.key === 'n' || event.key === 'N') {
    if (!event.ctrlKey && !event.metaKey) activateTool('pencil');
  }
  if (event.key === 'b' || event.key === 'B') {
    if (!event.ctrlKey && !event.metaKey) activateTool('brush');
  }
  if (event.key === 'm' || event.key === 'M') {
    if (!event.ctrlKey && !event.metaKey) activateTool('rectangle');
  }
  if (event.key === 'l' || event.key === 'L') {
    if (!event.ctrlKey && !event.metaKey) activateTool('ellipse');
  }
  if (event.key === 't' || event.key === 'T') {
    if (!event.ctrlKey && !event.metaKey) activateTool('type');
  }
  if (event.key === 'i' || event.key === 'I') {
    if (!event.ctrlKey && !event.metaKey) activateTool('eyedropper');
  }
  if (event.key === 'h' || event.key === 'H') {
    if (!event.ctrlKey && !event.metaKey) activateTool('hand');
  }
  if (event.key === 'z' || event.key === 'Z') {
    if (event.ctrlKey || event.metaKey) {
      event.preventDefault();
      if (event.shiftKey) {
        redo();
      } else {
        undo();
      }
    } else {
      activateTool('zoom');
    }
  }
  
  if ((event.ctrlKey || event.metaKey) && event.key === 'c') copy();
  if ((event.ctrlKey || event.metaKey) && event.key === 'x') cut();
  if ((event.ctrlKey || event.metaKey) && event.key === 'v') {
    if (!event.shiftKey) paste();
  }
  if ((event.ctrlKey || event.metaKey) && event.key === 'd') {
    event.preventDefault();
    duplicate();
  }
  if (event.key === 'Delete' || event.key === 'Backspace') {
    if (event.target.tagName !== 'INPUT') {
      deleteSelection();
    }
  }
  if ((event.ctrlKey || event.metaKey) && event.key === 'a') {
    event.preventDefault();
    selectAll();
  }
  if ((event.ctrlKey || event.metaKey) && event.shiftKey && (event.key === 'a' || event.key === 'A')) {
    event.preventDefault();
    deselectAll();
  }
  if ((event.ctrlKey || event.metaKey) && event.key === 'g') {
    event.preventDefault();
    if (event.shiftKey) {
      ungroupSelection();
    } else {
      groupSelection();
    }
  }
  
  if ((event.ctrlKey || event.metaKey) && event.key === ']') {
    if (event.shiftKey) {
      bringToFront();
    } else {
      bringForward();
    }
  }
  if ((event.ctrlKey || event.metaKey) && event.key === '[') {
    if (event.shiftKey) {
      sendToBack();
    } else {
      sendBackward();
    }
  }
  
  if ((event.ctrlKey || event.metaKey) && (event.key === '=' || event.key === '+')) {
    event.preventDefault();
    zoomIn();
  }
  if ((event.ctrlKey || event.metaKey) && event.key === '-') {
    event.preventDefault();
    zoomOut();
  }
  if ((event.ctrlKey || event.metaKey) && event.key === '0') {
    event.preventDefault();
    zoomToFit();
  }
  if ((event.ctrlKey || event.metaKey) && event.key === '1') {
    event.preventDefault();
    zoomTo100();
  }
  
  if (event.key === 'Escape') {
    deselectAll();
    if (currentPath) {
      currentPath.remove();
      currentPath = null;
      penPoints = [];
    }
  }
});

  // Arrow key nudging (1px or 10px with Shift)
document.addEventListener('keydown', function(event) {
    if (project.selectedItems.length === 0) return;
    if (['INPUT', 'TEXTAREA'].includes(event.target.tagName)) return;

    var deltaX = 0, deltaY = 0;
    var step = event.shiftKey ? 10 : 1;

    switch (event.key) {
        case 'ArrowUp':    deltaY = -step; break;
        case 'ArrowDown':  deltaY = step;  break;
        case 'ArrowLeft':  deltaX = -step; break;
        case 'ArrowRight': deltaX = step;  break;
        default: return;
    }

    if (deltaX !== 0 || deltaY !== 0) {
        event.preventDefault();
        project.selectedItems.forEach(item => {
            if (!item.locked && item.name !== 'Artboard') {
                item.position += new Point(deltaX, deltaY);
            }
        });
        updateProperties();
        saveState();
    }
});

// Mouse and Touch position tracking
view.onMouseMove = function(event) {
  var statusPosition = document.getElementById('statusPosition');
  if (statusPosition) {
    statusPosition.textContent = 'X: ' + Math.round(event.point.x) + ' Y: ' + Math.round(event.point.y);
  }
};

// Selection changed handler
project.on('selectionchanged', updateProperties);

// Proper initialization after Paper.js is fully ready
view.onFrame = function(event) {
    if (event.count === 5) {  // Wait a few frames for everything to settle
        console.log('Paper.js ready - initializing editor...');
        
        initLayers();           // Creates background + Layer 1
        createArtboard();       // Puts white artboard in background
        activateTool('select'); // Activate selection tool
        saveState();            // Save initial state for undo
        
        // Hide loader
        var loader = document.getElementById('loader');
        if (loader) {
            loader.style.display = 'none';
        }
        
        console.log('Editor fully initialized!');
    }
};
console.log('Paper.js setup complete!');

view.onFrame = function(event) {
  if (event.count === 10) {
    var loader = document.getElementById('loader');
    if (loader) {
      loader.style.display = 'none';
      console.log('Loader hidden, editor ready!');
    }
  }
};

// Expose functions to global scope for HTML onclick handlers
window.newDocument = newDocument;
window.saveDocument = saveDocument;
window.saveDocumentAs = saveDocumentAs;
window.handleOpen = handleOpen;
window.handlePlace = handlePlace;
window.exportSVG = exportSVG;
window.exportPNG = exportPNG;
window.exportPDF = exportPDF;
window.undo = undo;
window.redo = redo;
window.cut = cut;
window.copy = copy;
window.paste = paste;
window.duplicate = duplicate;
window.deleteSelection = deleteSelection;
window.selectAll = selectAll;
window.deselectAll = deselectAll;
window.groupSelection = groupSelection;
window.ungroupSelection = ungroupSelection;
window.lockSelection = lockSelection;
window.unlockAll = unlockAll;
window.bringToFront = bringToFront;
window.sendToBack = sendToBack;
window.bringForward = bringForward;
window.sendBackward = sendBackward;
window.rotateSelection = rotateSelection;
window.flipSelection = flipSelection;
window.showTransformDialog = showTransformDialog;
window.pathfinder = pathfinder;
window.createOutlines = createOutlines;
window.findFont = findFont;
window.selectSameFill = selectSameFill;
window.selectSameStroke = selectSameStroke;
window.selectSameStrokeWidth = selectSameStrokeWidth;
window.zoomIn = zoomIn;
window.zoomOut = zoomOut;
window.zoomToFit = zoomToFit;
window.zoomTo100 = zoomTo100;
window.toggleGrid = toggleGrid;
window.toggleRulers = toggleRulers;
window.toggleSnap = toggleSnap;
window.showPanel = showPanel;
window.updateTransform = updateTransform;
window.updateOpacity = updateOpacity;
window.updateBlendMode = updateBlendMode;
window.convertToPoint = convertToPoint;
window.convertToCurve = convertToCurve;
window.addLayer = addLayer;
window.deleteLayer = deleteLayer;
window.addFill = addFill;
window.addStroke = addStroke;
window.addSwatch = addSwatch;
window.clearSwatches = clearSwatches;
window.setGradientType = setGradientType;
window.updateStroke = updateStroke;
window.setStrokeCap = setStrokeCap;
window.setStrokeJoin = setStrokeJoin;
window.align = align;
window.distribute = distribute;
window.updateTypography = updateTypography;
window.setFontStyle = setFontStyle;
window.setTextAlign = setTextAlign;
window.showArtboardOptions = showArtboardOptions;
window.rotateArtboard = rotateArtboard;
window.updateFillColor = updateFillColor;
window.updateFillColorFromNum = updateFillColorFromNum;
window.applyFillColor = applyFillColor;
window.updateStrokeColor = updateStrokeColor;
window.updateStrokeColorFromNum = updateStrokeColorFromNum;
window.applyStrokeColor = applyStrokeColor;
window.toggleToolPanel = toggleToolPanel;
window.updateTextToolSettings = updateTextToolSettings;
window.setTextToolAlign = setTextToolAlign;
window.updateBrushToolSettings = updateBrushToolSettings;
window.updateShapeToolSettings = updateShapeToolSettings;
window.updatePenToolSettings = updatePenToolSettings;
window.updateZoomFromSlider = updateZoomFromSlider;
  function makeLayersDraggable() {
    const list = document.getElementById('layersList');
    let draggedItem = null;

    list.addEventListener('dragstart', (e) => {
        if (e.target.classList.contains('layer-item')) {
            draggedItem = e.target;
            e.target.style.opacity = '0.4';
            e.dataTransfer.effectAllowed = 'move';
        }
    });

    list.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
    });

    list.addEventListener('dragend', (e) => {
        if (draggedItem) draggedItem.style.opacity = '';
    });

    list.addEventListener('drop', (e) => {
        e.preventDefault();
        if (draggedItem && e.target.classList.contains('layer-item') && draggedItem !== e.target) {
            const allItems = Array.from(list.querySelectorAll('.layer-item'));
            const draggedIdx = parseInt(draggedItem.dataset.index);
            const targetIdx = parseInt(e.target.dataset.index);

            const draggedLayer = project.layers[draggedIdx];

            // Reorder layers array (higher index = on top)
            if (draggedIdx < targetIdx) {
                draggedLayer.index = targetIdx;  // Paper.js Layer has .index property
            } else {
                draggedLayer.index = targetIdx;
            }

            updateLayersList();
        }
    });
}
</script>

<script>
// Panel tab switching
document.querySelectorAll('.panel-tab').forEach(tab => {
  tab.addEventListener('click', function() {
    document.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.panel-section').forEach(s => s.classList.remove('active'));
    
    this.classList.add('active');
    document.getElementById('panel-' + this.dataset.panel).classList.add('active');
  });
});

// Dock toggle
const dock = document.getElementById('panelDock');
const dockToggle = document.getElementById('dockToggle');
const panelCloseBtn = document.getElementById('panelCloseBtn');
let dockVisible = true;

function toggleDock() {
  dockVisible = !dockVisible;
  dock.classList.toggle('visible', dockVisible);
  dock.classList.toggle('hidden', !dockVisible);
  dockToggle.textContent = dockVisible ? '‚óÄ' : '‚ñ∂';
}

dockToggle.onclick = toggleDock;
if (panelCloseBtn) {
  panelCloseBtn.onclick = toggleDock;
}

// Show specific panel
function showPanel(panelName) {
  document.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.panel-section').forEach(s => s.classList.remove('active'));
  
  var tab = document.querySelector('.panel-tab[data-panel="' + panelName + '"]');
  if (tab) tab.classList.add('active');
  
  var section = document.getElementById('panel-' + panelName);
  if (section) section.classList.add('active');
  
  if (!dockVisible) {
    dock.classList.add('visible');
    dock.classList.remove('hidden');
    dockVisible = true;
    dockToggle.textContent = '‚óÄ';
  }
  
  var panelNames = {
    'properties': 'Properties Panel',
    'layers': 'Layers Panel',
    'appearance': 'Appearance Panel',
    'swatches': 'Swatches Panel',
    'gradient': 'Gradient Panel',
    'stroke': 'Stroke Panel',
    'align': 'Align Panel',
    'character': 'Character Panel',
    'paragraph': 'Paragraph Panel'
  };
  
  if (panelNames[panelName]) {
    showToolNotification(panelNames[panelName]);
  }
}

// Gradient controls
document.getElementById('gradientAngle').addEventListener('input', function() {
  document.getElementById('gradientAngleVal').textContent = this.value + '¬∞';
});

// Stroke controls
document.getElementById('strokeWeight').addEventListener('input', function() {
  document.getElementById('strokeWeightVal').textContent = this.value + ' px';
});

// Window resize handler
window.addEventListener('resize', function() {
  if (window.innerWidth > 900) {
    dock.classList.add('visible');
    dock.classList.remove('hidden');
    dockVisible = true;
  }
});

// Swatches
const defaultSwatches = [
  '#000000', '#ffffff', '#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff',
  '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#dfe6e9', '#6c5ce7', '#fd79a8',
  '#e17055', '#00b894', '#0984e3', '#6c5ce7', '#fdcb6e', '#636e72', '#2d3436', '#b2bec3'
];

function initSwatches() {
  const swatchGrid = document.getElementById('swatchGrid');
  if (!swatchGrid) return;
  
  swatchGrid.innerHTML = '';
  defaultSwatches.forEach(color => {
    const swatch = document.createElement('div');
    swatch.className = 'swatch';
    swatch.style.backgroundColor = color;
    swatch.onclick = function() {
      if (window.project && window.project.selectedItems && window.project.selectedItems.length) {
        window.project.selectedItems.forEach(item => {
          item.fillColor = color;
        });
      }
    };
    swatchGrid.appendChild(swatch);
  });
}

// Appearance panel functions
function addFill() {
  const appearanceList = document.getElementById('appearanceList');
  if (appearanceList) {
    const item = document.createElement('div');
    item.className = 'appearance-item';
    item.innerHTML = `
      <span class="type">Fill</span>
      <div class="color-preview" style="background-color: #ff0000"></div>
      <span class="value">#ff0000</span>
    `;
    appearanceList.appendChild(item);
  }
}

function addStroke() {
  const appearanceList = document.getElementById('appearanceList');
  if (appearanceList) {
    const item = document.createElement('div');
    item.className = 'appearance-item';
    item.innerHTML = `
      <span class="type">Stroke</span>
      <div class="color-preview" style="background-color: #000000"></div>
      <span class="value">#000000</span>
    `;
    appearanceList.appendChild(item);
  }
}

// Stroke panel functions
function setStrokeCap(cap) {
  if (window.project && window.project.selectedItems && window.project.selectedItems.length) {
    window.project.selectedItems.forEach(item => {
      item.strokeCap = cap;
    });
  }
}

function setStrokeJoin(join) {
  if (window.project && window.project.selectedItems && window.project.selectedItems.length) {
    window.project.selectedItems.forEach(item => {
      item.strokeJoin = join;
    });
  }
}

function updateStroke() {
  const weight = parseFloat(document.getElementById('strokeWeight').value);
  const dash = document.getElementById('strokeDash').value;
  const color = document.getElementById('strokeColorInput').value;
  
  if (window.project && window.project.selectedItems && window.project.selectedItems.length) {
    window.project.selectedItems.forEach(item => {
      item.strokeWidth = weight;
      if (dash) {
        const dashArray = dash.split(',').map(d => parseFloat(d.trim()));
        item.dashArray = dashArray;
      } else {
        item.dashArray = [];
      }
      item.strokeColor = color;
    });
  }
}

// Align functions
function align(alignment) {
  if (!window.project || !window.project.selectedItems || window.project.selectedItems.length < 2) return;
  
  const items = window.project.selectedItems;
  const bounds = items.map(item => item.bounds);
  
  switch(alignment) {
    case 'left':
      items.forEach(item => item.position.x = bounds[0].left);
      break;
    case 'right':
      items.forEach(item => item.position.x = bounds[0].right - (item.bounds.width / 2));
      break;
    case 'top':
      items.forEach(item => item.position.y = bounds[0].top);
      break;
    case 'bottom':
      items.forEach(item => item.position.y = bounds[0].bottom - (item.bounds.height / 2));
      break;
    case 'center-h':
      items.forEach(item => item.position.x = bounds[0].center.x);
      break;
    case 'center-v':
      items.forEach(item => item.position.y = bounds[0].center.y);
      break;
  }
}

function distribute(distribution) {
  if (!project || !project.selectedItems || project.selectedItems.length < 3) return;
  
  const items = project.selectedItems;
  alert('Distribute feature - arrange items evenly');
}

// Typography functions
function updateTypography() {
  if (!window.project || !window.project.selectedItems || window.project.selectedItems.length === 0) return;
  
  const fontFamily = document.getElementById('fontFamily').value;
  const fontSize = parseInt(document.getElementById('fontSize').value);
  const lineHeight = parseInt(document.getElementById('lineHeight').value);
  const letterSpacing = parseInt(document.getElementById('letterSpacing').value);
  
  window.project.selectedItems.forEach(item => {
    if (item instanceof PointText) {
      item.fontFamily = fontFamily;
      item.fontSize = fontSize;
      item.leading = lineHeight;
    }
  });
}

function setFontStyle(style) {
  if (!window.project || !window.project.selectedItems || window.project.selectedItems.length === 0) return;
  
  window.project.selectedItems.forEach(item => {
    if (item instanceof PointText) {
      switch(style) {
        case 'bold':
          item.fontWeight = 'bold';
          break;
        case 'italic':
          item.fontStyle = 'italic';
          break;
        case 'underline':
          break;
      }
    }
  });
}

function setTextAlign(align) {
  if (!window.project || !window.project.selectedItems || window.project.selectedItems.length === 0) return;
  
  window.project.selectedItems.forEach(item => {
    if (item instanceof PointText) {
      item.justification = align;
    }
  });
}

// Swatch functions
function addSwatch() {
  const color = prompt('Enter hex color:', '#000000');
  if (color && /^#[0-9A-Fa-f]{6}$/.test(color)) {
    defaultSwatches.push(color);
    initSwatches();
  }
}

function clearSwatches() {
  if (confirm('Clear all custom swatches?')) {
    defaultSwatches.length = 8;
    initSwatches();
  }
}

// Gradient functions
function setGradientType(type) {
  alert('Gradient type: ' + type);
}

// Initialize on load
window.onload = function() {
  initSwatches();
  addFill();
  addStroke();
  
  // Update color previews
  updateFillColorPreview();
  updateStrokeColorPreview();
  
  // Initialize zoom slider
  var zoomSlider = document.getElementById('zoomSlider');
  if (zoomSlider) {
    zoomSlider.value = Math.round(view.zoom * 100);
    document.getElementById('zoomSliderVal').textContent = Math.round(view.zoom * 100) + '%';
  }
};

// Mobile touch support for position tracking
document.addEventListener('DOMContentLoaded', function() {
  var canvas = document.getElementById('canvas');
  if (canvas) {
    canvas.addEventListener('touchmove', function(e) {
      if (e.touches.length > 0) {
        var touch = e.touches[0];
        var rect = canvas.getBoundingClientRect();
        var x = touch.clientX - rect.left;
        var y = touch.clientY - rect.top;
        var statusPosition = document.getElementById('statusPosition');
        if (statusPosition) {
          statusPosition.textContent = 'X: ' + Math.round(x) + ' Y: ' + Math.round(y);
        }
      }
    }, { passive: true });
  }
});
</script>
</body>
</html>




