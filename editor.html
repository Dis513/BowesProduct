<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Image Editor ‚Äì BowesProduct</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  /* Reset and base styles */
  *, *::before, *::after { box-sizing: border-box; }
  html, body {
    margin: 0;
    background: #020617;
    color: white;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    overflow-x: hidden;
    height: 100vh;
    display: flex;
    flex-direction: column;
  }
  
  /* ================= HEADER ================= */
  .site-header {
    position: sticky;
    top: 0;
    z-index: 1000;
    background: rgba(2,6,23,0.98);
    border-bottom: 1px solid #1e293b;
    width: 100%;
    backdrop-filter: blur(10px);
  }
  .header-inner {
    max-width: 1400px;
    margin: 0 auto;
    padding: 0.75rem 1rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
  }
  .header-left {
    display: flex;
    align-items: center;
    gap: 1.5rem;
    flex-wrap: wrap;
  }
  
  /* Logo/Brand */
  .brand {
    font-size: 1.25rem;
    font-weight: 700;
    color: #fff;
    text-decoration: none;
    letter-spacing: -0.025em;
  }
  
  /* Navigation Links */
  .nav-links {
    display: flex;
    gap: 0.5rem;
    align-items: center;
  }
  .nav-link {
    padding: 0.5rem 1rem;
    font-size: 0.875rem;
    background: transparent;
    border: none;
    border-radius: 8px;
    color: #94a3b8;
    cursor: pointer;
    transition: all 0.2s ease;
    text-decoration: none;
    white-space: nowrap;
    font-weight: 500;
  }
  .nav-link:hover {
    color: #fff;
    background: rgba(255,255,255,0.05);
  }
  .nav-link.active {
    color: #fff;
    background: #3b82f6;
    font-weight: 600;
  }
  
  /* Profile and Level Info */
  #levelInfo {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    font-size: 0.875rem;
  }
  #profilePic {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    border: 2px solid #3b82f6;
    display: none;
  }
  #levelText {
    white-space: nowrap;
    color: #94a3b8;
    font-weight: 500;
  }
  .xp-bar-container {
    width: 70px;
    height: 6px;
    background: #1e293b;
    border-radius: 3px;
    overflow: hidden;
  }
  #xpBar {
    height: 100%;
    background: linear-gradient(90deg, #3b82f6, #8b5cf6);
    width: 0%;
    transition: width 0.3s ease;
  }
  
  /* Auth Button */
  #authBtn {
    cursor: pointer;
    padding: 0.5rem 1.25rem;
    background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
    border: none;
    border-radius: 8px;
    color: #fff;
    font-size: 0.875rem;
    font-weight: 600;
    transition: all 0.2s ease;
    white-space: nowrap;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  }
  #authBtn:hover {
    background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(59,130,246,0.3);
  }
  
  /* ================= MAIN LAYOUT ================= */
  .main-container {
    display: flex;
    flex: 1;
    height: calc(100vh - 70px);
    overflow: hidden;
  }
  
  /* ================= LEFT PANEL (Tabs) ================= */
  .left-panel {
    width: 200px;
    min-width: 160px;
    background: #0f172a;
    border-right: 1px solid #1e293b;
    padding: 1rem 0.75rem;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
  }
  .left-panel h3 {
    margin: 0 0 0.75rem 0;
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: #64748b;
    padding: 0 0.25rem;
  }
  .tab-btn {
    width: 100%;
    padding: 0.625rem 0.75rem;
    background: transparent;
    border: none;
    border-radius: 8px;
    color: #94a3b8;
    font-size: 0.875rem;
    cursor: pointer;
    transition: all 0.2s ease;
    text-align: left;
    font-weight: 500;
  }
  .tab-btn:hover {
    color: #fff;
    background: rgba(255,255,255,0.05);
  }
  .tab-btn.active {
    color: #fff;
    background: #3b82f6;
    font-weight: 600;
  }
  
  /* ================= CENTER PANEL (Canvas) ================= */
  .center-panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: #0a0a0a;
    padding: 1.5rem;
    min-width: 0;
  }
  #canvas {
    max-width: 100%;
    max-height: calc(100% - 80px);
    background: #111;
    border: 1px solid #333;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.5);
  }
  .canvas-toolbar {
    display: flex;
    gap: 0.5rem;
    margin-top: 1rem;
    flex-wrap: wrap;
    justify-content: center;
  }
  .toolbar-btn {
    padding: 0.625rem 1rem;
    background: #1e293b;
    border: 1px solid #334155;
    border-radius: 8px;
    color: #fff;
    font-size: 0.875rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  .toolbar-btn:hover {
    background: #334155;
    border-color: #475569;
  }
  .toolbar-btn.primary {
    background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
    border: none;
    font-weight: 600;
  }
  .toolbar-btn.primary:hover {
    background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(59,130,246,0.3);
  }
  .toolbar-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }
  
  /* ================= RIGHT PANEL (Controls) ================= */
  .right-panel {
    width: 280px;
    min-width: 240px;
    background: #0f172a;
    border-left: 1px solid #1e293b;
    padding: 1rem 0.75rem;
    overflow-y: auto;
  }
  .right-panel h3 {
    margin: 0 0 1rem 0;
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: #64748b;
  }
  
  /* ================= PANEL CONTROLS ================= */
  .panel-section {
    margin-bottom: 1.25rem;
    padding-bottom: 1.25rem;
    border-bottom: 1px solid #1e293b;
  }
  .panel-section:last-child {
    border-bottom: none;
    margin-bottom: 0;
    padding-bottom: 0;
  }
  .panel-section h4 {
    margin: 0 0 0.75rem 0;
    font-size: 0.875rem;
    color: #e2e8f0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-weight: 600;
  }
  
  /* Toggle Switch */
  .toggle {
    padding: 0.25rem 0.625rem;
    font-size: 0.7rem;
    font-weight: 700;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
    background: #1e293b;
    color: #64748b;
    border: 1px solid #334155;
  }
  .toggle.on {
    background: #22c55e;
    color: #fff;
    border-color: #22c55e;
  }
  .toggle:hover {
    opacity: 0.9;
  }
  
  /* Control Groups */
  .control-group {
    margin-bottom: 0.875rem;
  }
  .control-group:last-child {
    margin-bottom: 0;
  }
  .control-group label {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.8rem;
    color: #94a3b8;
    margin-bottom: 0.5rem;
    font-weight: 500;
  }
  .control-group label input[type="checkbox"] {
    margin-right: 0.5rem;
  }
  
  /* Range Sliders */
  input[type="range"] {
    width: 100%;
    height: 6px;
    border-radius: 3px;
    background: #1e293b;
    outline: none;
    -webkit-appearance: none;
  }
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #3b82f6;
    cursor: pointer;
    transition: all 0.2s;
  }
  input[type="range"]::-webkit-slider-thumb:hover {
    background: #2563eb;
    transform: scale(1.1);
  }
  
  /* Color Input */
  input[type="color"] {
    width: 100%;
    height: 36px;
    border: 1px solid #334155;
    border-radius: 6px;
    background: #1e293b;
    cursor: pointer;
    padding: 2px;
  }
  
  /* Checkbox */
  input[type="checkbox"] {
    width: 18px;
    height: 18px;
    accent-color: #3b82f6;
  }
  
  /* ================= RESPONSIVE DESIGN ================= */
  @media (max-width: 768px) {
    .header-inner {
      padding: 0.6rem 0.75rem;
      gap: 0.75rem;
    }
    .brand {
      font-size: 1rem;
    }
    .nav-links {
      gap: 0.25rem;
    }
    .nav-link {
      padding: 0.4rem 0.6rem;
      font-size: 0.8rem;
    }
    #profilePic {
      width: 30px;
      height: 30px;
    }
    .xp-bar-container {
      width: 50px;
    }
    #levelText {
      font-size: 0.75rem;
    }
    #authBtn {
      padding: 0.4rem 0.8rem;
      font-size: 0.8rem;
    }
    
    .main-container {
      flex-direction: column;
      height: auto;
    }
    
    .left-panel {
      width: 100%;
      flex-direction: row;
      overflow-x: auto;
      border-right: none;
      border-bottom: 1px solid #1e293b;
      padding: 0.5rem 0.75rem;
      gap: 0.25rem;
    }
    .left-panel h3 {
      display: none;
    }
    .tab-btn {
      padding: 0.5rem 0.6rem;
      font-size: 0.8rem;
      white-space: nowrap;
    }
    
    .center-panel {
      height: 50vh;
      min-height: 300px;
      padding: 0.75rem;
    }
    
    .right-panel {
      width: 100%;
      border-left: none;
      border-top: 1px solid #1e293b;
      max-height: 40vh;
    }
    
    .canvas-toolbar {
      gap: 0.35rem;
    }
    .toolbar-btn {
      padding: 0.5rem 0.75rem;
      font-size: 0.8rem;
    }
  }
  
  @media (max-width: 480px) {
    .header-inner {
      flex-direction: column;
      align-items: stretch;
      gap: 0.5rem;
    }
    .header-left {
      flex-direction: column;
      align-items: stretch;
      gap: 0.75rem;
    }
    .nav-links {
      justify-content: space-between;
    }
    .nav-link {
      flex: 1;
      text-align: center;
      padding: 0.5rem;
      font-size: 0.75rem;
    }
    #levelInfo {
      justify-content: center;
      flex-direction: column;
      gap: 0.25rem;
    }
    .xp-bar-container {
      width: 100%;
      height: 4px;
    }
  }
</style>
<script src="https://sites.super.myninja.ai/_assets/ninja-daytona-script.js"></script>
</head>
<body>

<!-- HEADER -->
<header class="site-header">
  <div class="header-inner">
    <div class="header-left">
      <a href="#" class="brand">BowesProduct</a>
      <nav class="nav-links">
        <a href="#" class="nav-link">Home</a>
        <a href="#" class="nav-link">Features</a>
        <a href="#" class="nav-link">About</a>
        <a href="#" class="nav-link active">Editor</a>
        <a href="#" class="nav-link">Pricing</a>
      </nav>
      <div id="levelInfo" style="display:none;">
        <img id="profilePic" src="" alt="Profile" />
        <span id="levelText"></span>
        <div class="xp-bar-container">
          <div id="xpBar"></div>
        </div>
      </div>
    </div>
    <div class="header-right">
      <button id="authBtn">Login</button>
    </div>
  </div>
</header>

<!-- MAIN CONTENT -->
<div class="main-container">
  <!-- LEFT PANEL -->
  <aside class="left-panel">
    <h3>Effects</h3>
    <button class="tab-btn active" data-tab="basic">Basic</button>
    <button class="tab-btn" data-tab="color">Color</button>
    <button class="tab-btn" data-tab="blur">Blur</button>
    <button class="tab-btn" data-tab="stylize">Stylize</button>
    <button class="tab-btn" data-tab="artistic">Artistic</button>
    <button class="tab-btn" data-tab="distort">Distort</button>
  </aside>

  <!-- CENTER PANEL -->
  <main class="center-panel">
    <canvas id="canvas"></canvas>
    <div class="canvas-toolbar">
      <input type="file" id="imageInput" accept="image/*" style="display:none;" />
      <button class="toolbar-btn primary" onclick="document.getElementById('imageInput').click()">üìÅ Upload</button>
      <button class="toolbar-btn" id="undoBtn" disabled>‚Ü© Undo</button>
      <button class="toolbar-btn" id="redoBtn" disabled>‚Ü™ Redo</button>
      <button class="toolbar-btn" id="resetBtn" disabled>‚Ü∫ Reset</button>
      <button class="toolbar-btn primary" id="exportBtn" disabled>üíæ Export</button>
    </div>
  </main>

  <!-- RIGHT PANEL -->
  <aside class="right-panel">
    <h3>Controls</h3>
    <div id="panelContent">Select a tab to see controls</div>
  </aside>
</div>

<!-- Firebase SDK -->
<script type="module">
  // Firebase configuration
  const firebaseConfig = {
    apiKey: "AIzaSyB4JMVBMcWcN2wKsaVYmnggHH5ue1mUfaA",
    authDomain: "bowesproduct.firebaseapp.com",
    projectId: "bowesproduct"
  };
  
  // Import Firebase modules
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js";
  import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-auth.js";
  import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js";
  
  // Initialize Firebase
  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);
  const provider = new GoogleAuthProvider();
  
  const authBtn = document.getElementById("authBtn");
  const profilePic = document.getElementById("profilePic");
  const levelInfo = document.getElementById("levelInfo");
  const levelText = document.getElementById("levelText");
  const xpBar = document.getElementById("xpBar");
  
  authBtn.onclick = () => {
    if (auth.currentUser) {
      signOut(auth);
    } else {
      signInWithPopup(auth, provider).catch((error) => {
        console.error("Auth error:", error);
      });
    }
  };
  
  onAuthStateChanged(auth, async (user) => {
    if (!user) {
      authBtn.textContent = "Login";
      profilePic.style.display = "none";
      levelInfo.style.display = "none";
      return;
    }
    
    authBtn.textContent = "Logout";
    profilePic.src = user.photoURL || "";
    profilePic.style.display = "block";
    
    const ref = doc(db, "users", user.uid);
    let snap = await getDoc(ref);
    
    if (!snap.exists()) {
      await setDoc(ref, { xp: 10 });
      snap = await getDoc(ref);
    }
    
    const xp = snap.data().xp || 0;
    const levels = [0, 200, 500, 1000, 2000];
    let level = levels.filter(v => xp >= v).length - 1;
    let next = levels[level + 1] ?? levels[level];
    let progress = next === levels[level] ? 100 : ((xp - levels[level]) / (next - levels[level])) * 100;
    
    levelText.textContent = `Lvl ${level} ‚Ä¢ ${xp} XP`;
    xpBar.style.width = progress + "%";
    levelInfo.style.display = "flex";
  });
</script>

<script>
// ================= IMAGE EDITOR ENGINE =================
class ImageEditor {
  constructor() {
    this.canvas = document.getElementById('canvas');
    this.ctx = this.canvas.getContext('2d');
    this.originalImage = null;
    this.isImageLoaded = false;
    this.undoStack = [];
    this.redoStack = [];
    this.maxUndo = 20;
    
    // All adjustments with default values
    this.adjustments = {
      brightness: 0,
      contrast: 0,
      exposure: 0,
      sharpen: 0,
      hueRotate: 0,
      saturation: 100,
      lightness: 0,
      temperature: 0,
      tint: 0,
      invert: false,
      grayscale: false,
      sepia: false,
      blur: 0,
      motionAngle: 0,
      motionAmount: 0,
      dropShadow: { enabled: false, x: 5, y: 5, blur: 10, opacity: 50, color: '#000000' },
      innerGlow: { enabled: false, blur: 20, opacity: 50, color: '#60a5fa' },
      outerGlow: { enabled: false, blur: 20, opacity: 50, color: '#60a5fa' },
      vignette: 0,
      coloredPencil: 0,
      cutout: 0,
      dryBrush: 0,
      filmGrain: 0,
      fresco: 0,
      neonGlow: 0,
      paintDaubs: 0,
      posterEdges: 0,
      watercolor: 0,
      ripple: 0,
      twirl: 0,
      wave: 0,
      zigzag: 0,
      glass: 0
    };
    
    // Effect enabled states
    this.effectsEnabled = {
      brightness: true,
      contrast: true,
      exposure: true,
      sharpen: false,
      hsl: true,
      temperature: true,
      basicColor: true,
      blur: false,
      motionBlur: false,
      dropShadow: false,
      innerGlow: false,
      outerGlow: false,
      vignette: false,
      coloredPencil: false,
      cutout: false,
      dryBrush: false,
      filmGrain: false,
      fresco: false,
      neonGlow: false,
      paintDaubs: false,
      posterEdges: false,
      watercolor: false,
      ripple: false,
      twirl: false,
      wave: false,
      zigzag: false,
      glass: false
    };
    
    this.tabs = {
      'basic': this.getBasicControls(),
      'color': this.getColorControls(),
      'blur': this.getBlurControls(),
      'stylize': this.getStylizeControls(),
      'artistic': this.getArtisticControls(),
      'distort': this.getDistortControls()
    };
    
    this.init();
  }
  
  init() {
    this.loadTab('basic');
    this.initEventListeners();
    this.updateButtonStates();
  }
  
  initEventListeners() {
    // Tab buttons
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        this.loadTab(btn.dataset.tab);
      });
    });
    
    // Image upload
    document.getElementById('imageInput').addEventListener('change', (e) => {
      this.loadImage(e.target.files[0]);
    });
    
    // Toolbar buttons
    document.getElementById('undoBtn').addEventListener('click', () => this.undo());
    document.getElementById('redoBtn').addEventListener('click', () => this.redo());
    document.getElementById('resetBtn').addEventListener('click', () => this.reset());
    document.getElementById('exportBtn').addEventListener('click', () => this.exportPNG());
  }
  
  updateButtonStates() {
    const hasImage = this.isImageLoaded;
    document.getElementById('undoBtn').disabled = !hasImage || this.undoStack.length <= 1;
    document.getElementById('redoBtn').disabled = !hasImage || this.redoStack.length === 0;
    document.getElementById('resetBtn').disabled = !hasImage;
    document.getElementById('exportBtn').disabled = !hasImage;
  }
  
  loadImage(file) {
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => {
        this.originalImage = img;
        this.isImageLoaded = true;
        
        // Calculate dimensions to fit within bounds
        const maxW = Math.min(800, window.innerWidth - 40);
        const maxH = Math.min(600, window.innerHeight - 200);
        
        let width = img.width;
        let height = img.height;
        
        if (width > maxW) {
          height = (maxW / width) * height;
          width = maxW;
        }
        if (height > maxH) {
          width = (maxH / height) * width;
          height = maxH;
        }
        
        this.canvas.width = width;
        this.canvas.height = height;
        this.ctx.drawImage(img, 0, 0, width, height);
        
        // Reset stacks
        this.undoStack = [];
        this.redoStack = [];
        this.saveState();
        this.applyEffects();
        this.updateButtonStates();
      };
      img.onerror = () => {
        alert('Failed to load image. Please try another file.');
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  }
  
  saveState() {
    if (this.isImageLoaded) {
      this.undoStack.push(this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height));
      if (this.undoStack.length > this.maxUndo) {
        this.undoStack.shift();
      }
      this.redoStack = [];
      this.updateButtonStates();
    }
  }
  
  undo() {
    if (this.undoStack.length > 1) {
      this.redoStack.push(this.undoStack.pop());
      const data = this.undoStack[this.undoStack.length - 1];
      this.ctx.putImageData(data, 0, 0);
      this.updateButtonStates();
    }
  }
  
  redo() {
    if (this.redoStack.length > 0) {
      const data = this.redoStack.pop();
      this.ctx.putImageData(data, 0, 0);
      this.undoStack.push(data);
      this.updateButtonStates();
    }
  }
  
  reset() {
    if (!this.originalImage) return;
    
    // Reset all adjustments
    this.adjustments = {
      brightness: 0,
      contrast: 0,
      exposure: 0,
      sharpen: 0,
      hueRotate: 0,
      saturation: 100,
      lightness: 0,
      temperature: 0,
      tint: 0,
      invert: false,
      grayscale: false,
      sepia: false,
      blur: 0,
      motionAngle: 0,
      motionAmount: 0,
      dropShadow: { enabled: false, x: 5, y: 5, blur: 10, opacity: 50, color: '#000000' },
      innerGlow: { enabled: false, blur: 20, opacity: 50, color: '#60a5fa' },
      outerGlow: { enabled: false, blur: 20, opacity: 50, color: '#60a5fa' },
      vignette: 0,
      coloredPencil: 0,
      cutout: 0,
      dryBrush: 0,
      filmGrain: 0,
      fresco: 0,
      neonGlow: 0,
      paintDaubs: 0,
      posterEdges: 0,
      watercolor: 0,
      ripple: 0,
      twirl: 0,
      wave: 0,
      zigzag: 0,
      glass: 0
    };
    
    // Reload current tab to update UI
    const activeTab = document.querySelector('.tab-btn.active');
    if (activeTab) {
      this.loadTab(activeTab.dataset.tab);
    }
    
    this.applyEffects();
  }
  
  loadTab(tabName) {
    const content = this.tabs[tabName] || '';
    document.getElementById('panelContent').innerHTML = content;
    this.attachControlListeners();
  }
  
  attachControlListeners() {
    document.querySelectorAll('#panelContent input, #panelContent select').forEach(input => {
      input.addEventListener('input', (e) => this.handleInputChange(e.target));
      input.addEventListener('change', (e) => this.handleInputChange(e.target));
    });
  }
  
  handleInputChange(target) {
    const param = target.dataset.param;
    let value;
    
    if (target.type === 'checkbox') {
      value = target.checked;
    } else if (target.type === 'range' || target.type === 'number') {
      value = parseFloat(target.value);
    } else if (target.type === 'color') {
      value = target.value;
    }
    
    // Update display value
    const valDisplay = document.getElementById(`${param}-val`);
    if (valDisplay) {
      let displayValue = value;
      if (param.includes('hueRotate') || param.includes('Angle')) displayValue += '¬∞';
      else if (param.includes('saturation') || param.includes('lightness') || param.includes('opacity')) displayValue += '%';
      else if (param.includes('blur') || param.includes('Blur')) displayValue += 'px';
      valDisplay.textContent = displayValue;
    }
    
    // Store adjustment
    if (param.includes('-')) {
      const [section, subParam] = param.split('-');
      if (!this.adjustments[section]) {
        this.adjustments[section] = {};
      }
      this.adjustments[section][subParam] = value;
    } else {
      this.adjustments[param] = value;
    }
    
    this.applyEffects();
  }
  
  toggleEffect(effectName) {
    this.effectsEnabled[effectName] = !this.effectsEnabled[effectName];
    this.updateToggleUI(effectName);
    this.applyEffects();
  }
  
  updateToggleUI(effectName) {
    const toggle = document.querySelector(`[data-effect="${effectName}"]`);
    if (toggle) {
      if (this.effectsEnabled[effectName]) {
        toggle.classList.add('on');
        toggle.textContent = 'ON';
      } else {
        toggle.classList.remove('on');
        toggle.textContent = 'OFF';
      }
    }
  }
  
  getBasicControls() {
    return `
      <div class="panel-section">
        <h4>Brightness <span class="toggle ${this.effectsEnabled.brightness ? 'on' : ''}" data-effect="brightness" onclick="editor.toggleEffect('brightness')">ON</span></h4>
        <div class="control-group">
          <label>Amount <span id="brightness-val">${this.adjustments.brightness}</span></label>
          <input type="range" min="-100" max="100" value="${this.adjustments.brightness}" data-param="brightness" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Contrast <span class="toggle ${this.effectsEnabled.contrast ? 'on' : ''}" data-effect="contrast" onclick="editor.toggleEffect('contrast')">ON</span></h4>
        <div class="control-group">
          <label>Amount <span id="contrast-val">${this.adjustments.contrast}</span></label>
          <input type="range" min="-100" max="100" value="${this.adjustments.contrast}" data-param="contrast" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Exposure <span class="toggle ${this.effectsEnabled.exposure ? 'on' : ''}" data-effect="exposure" onclick="editor.toggleEffect('exposure')">ON</span></h4>
        <div class="control-group">
          <label>Amount <span id="exposure-val">${this.adjustments.exposure}</span></label>
          <input type="range" min="-5" max="5" step="0.1" value="${this.adjustments.exposure}" data-param="exposure" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Sharpen <span class="toggle ${this.effectsEnabled.sharpen ? 'on' : ''}" data-effect="sharpen" onclick="editor.toggleEffect('sharpen')">OFF</span></h4>
        <div class="control-group">
          <label>Amount <span id="sharpen-val">${this.adjustments.sharpen}</span></label>
          <input type="range" min="0" max="100" value="${this.adjustments.sharpen}" data-param="sharpen" />
        </div>
      </div>
    `;
  }
  
  getColorControls() {
    return `
      <div class="panel-section">
        <h4>Hue/Sat/Light <span class="toggle ${this.effectsEnabled.hsl ? 'on' : ''}" data-effect="hsl" onclick="editor.toggleEffect('hsl')">ON</span></h4>
        <div class="control-group">
          <label>Hue <span id="hueRotate-val">${this.adjustments.hueRotate}¬∞</span></label>
          <input type="range" min="-180" max="180" value="${this.adjustments.hueRotate}" data-param="hueRotate" />
        </div>
        <div class="control-group">
          <label>Saturation <span id="saturation-val">${this.adjustments.saturation}%</span></label>
          <input type="range" min="0" max="200" value="${this.adjustments.saturation}" data-param="saturation" />
        </div>
        <div class="control-group">
          <label>Lightness <span id="lightness-val">${this.adjustments.lightness}%</span></label>
          <input type="range" min="-100" max="100" value="${this.adjustments.lightness}" data-param="lightness" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Temperature <span class="toggle ${this.effectsEnabled.temperature ? 'on' : ''}" data-effect="temperature" onclick="editor.toggleEffect('temperature')">ON</span></h4>
        <div class="control-group">
          <label>Warmth <span id="temperature-val">${this.adjustments.temperature}</span></label>
          <input type="range" min="-100" max="100" value="${this.adjustments.temperature}" data-param="temperature" />
        </div>
        <div class="control-group">
          <label>Tint <span id="tint-val">${this.adjustments.tint}</span></label>
          <input type="range" min="-100" max="100" value="${this.adjustments.tint}" data-param="tint" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Basic Color <span class="toggle ${this.effectsEnabled.basicColor ? 'on' : ''}" data-effect="basicColor" onclick="editor.toggleEffect('basicColor')">ON</span></h4>
        <div class="control-group">
          <label><input type="checkbox" ${this.adjustments.invert ? 'checked' : ''} data-param="invert" /> Invert</label>
        </div>
        <div class="control-group">
          <label><input type="checkbox" ${this.adjustments.grayscale ? 'checked' : ''} data-param="grayscale" /> Grayscale</label>
        </div>
        <div class="control-group">
          <label><input type="checkbox" ${this.adjustments.sepia ? 'checked' : ''} data-param="sepia" /> Sepia</label>
        </div>
      </div>
    `;
  }
  
  getBlurControls() {
    return `
      <div class="panel-section">
        <h4>Blur <span class="toggle ${this.effectsEnabled.blur ? 'on' : ''}" data-effect="blur" onclick="editor.toggleEffect('blur')">OFF</span></h4>
        <div class="control-group">
          <label>Radius <span id="blur-val">${this.adjustments.blur}px</span></label>
          <input type="range" min="0" max="50" value="${this.adjustments.blur}" data-param="blur" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Motion Blur <span class="toggle ${this.effectsEnabled.motionBlur ? 'on' : ''}" data-effect="motionBlur" onclick="editor.toggleEffect('motionBlur')">OFF</span></h4>
        <div class="control-group">
          <label>Angle <span id="motionAngle-val">${this.adjustments.motionAngle}¬∞</span></label>
          <input type="range" min="0" max="360" value="${this.adjustments.motionAngle}" data-param="motionAngle" />
        </div>
        <div class="control-group">
          <label>Amount <span id="motionAmount-val">${this.adjustments.motionAmount}</span></label>
          <input type="range" min="0" max="50" value="${this.adjustments.motionAmount}" data-param="motionAmount" />
        </div>
      </div>
    `;
  }
  
  getStylizeControls() {
    return `
      <div class="panel-section">
        <h4>Drop Shadow <span class="toggle ${this.effectsEnabled.dropShadow ? 'on' : ''}" data-effect="dropShadow" onclick="editor.toggleEffect('dropShadow')">OFF</span></h4>
        <div class="control-group">
          <label>X Offset <span id="dropShadow-x-val">${this.adjustments.dropShadow.x}</span></label>
          <input type="range" min="-50" max="50" value="${this.adjustments.dropShadow.x}" data-param="dropShadow-x" />
        </div>
        <div class="control-group">
          <label>Y Offset <span id="dropShadow-y-val">${this.adjustments.dropShadow.y}</span></label>
          <input type="range" min="-50" max="50" value="${this.adjustments.dropShadow.y}" data-param="dropShadow-y" />
        </div>
        <div class="control-group">
          <label>Blur <span id="dropShadow-blur-val">${this.adjustments.dropShadow.blur}px</span></label>
          <input type="range" min="0" max="50" value="${this.adjustments.dropShadow.blur}" data-param="dropShadow-blur" />
        </div>
        <div class="control-group">
          <label>Opacity <span id="dropShadow-opacity-val">${this.adjustments.dropShadow.opacity}%</span></label>
          <input type="range" min="0" max="100" value="${this.adjustments.dropShadow.opacity}" data-param="dropShadow-opacity" />
        </div>
        <div class="control-group">
          <label>Color</label>
          <input type="color" value="${this.adjustments.dropShadow.color}" data-param="dropShadow-color" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Inner Glow <span class="toggle ${this.effectsEnabled.innerGlow ? 'on' : ''}" data-effect="innerGlow" onclick="editor.toggleEffect('innerGlow')">OFF</span></h4>
        <div class="control-group">
          <label>Blur <span id="innerGlow-blur-val">${this.adjustments.innerGlow.blur}px</span></label>
          <input type="range" min="0" max="100" value="${this.adjustments.innerGlow.blur}" data-param="innerGlow-blur" />
        </div>
        <div class="control-group">
          <label>Opacity <span id="innerGlow-opacity-val">${this.adjustments.innerGlow.opacity}%</span></label>
          <input type="range" min="0" max="100" value="${this.adjustments.innerGlow.opacity}" data-param="innerGlow-opacity" />
        </div>
        <div class="control-group">
          <label>Color</label>
          <input type="color" value="${this.adjustments.innerGlow.color}" data-param="innerGlow-color" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Outer Glow <span class="toggle ${this.effectsEnabled.outerGlow ? 'on' : ''}" data-effect="outerGlow" onclick="editor.toggleEffect('outerGlow')">OFF</span></h4>
        <div class="control-group">
          <label>Blur <span id="outerGlow-blur-val">${this.adjustments.outerGlow.blur}px</span></label>
          <input type="range" min="0" max="100" value="${this.adjustments.outerGlow.blur}" data-param="outerGlow-blur" />
        </div>
        <div class="control-group">
          <label>Opacity <span id="outerGlow-opacity-val">${this.adjustments.outerGlow.opacity}%</span></label>
          <input type="range" min="0" max="100" value="${this.adjustments.outerGlow.opacity}" data-param="outerGlow-opacity" />
        </div>
        <div class="control-group">
          <label>Color</label>
          <input type="color" value="${this.adjustments.outerGlow.color}" data-param="outerGlow-color" />
        </div>
      </div>
      <div class="panel-section">
        <h4>Vignette <span class="toggle ${this.effectsEnabled.vignette ? 'on' : ''}" data-effect="vignette" onclick="editor.toggleEffect('vignette')">OFF</span></h4>
        <div class="control-group">
          <label>Strength <span id="vignette-val">${this.adjustments.vignette}</span></label>
          <input type="range" min="0" max="100" value="${this.adjustments.vignette}" data-param="vignette" />
        </div>
      </div>
    `;
  }
  
  getArtisticControls() {
    const effects = [
      { key: 'coloredPencil', label: 'Colored Pencil' },
      { key: 'cutout', label: 'Cutout' },
      { key: 'dryBrush', label: 'Dry Brush' },
      { key: 'filmGrain', label: 'Film Grain' },
      { key: 'fresco', label: 'Fresco' },
      { key: 'neonGlow', label: 'Neon Glow' },
      { key: 'paintDaubs', label: 'Paint Daubs' },
      { key: 'posterEdges', label: 'Poster Edges' },
      { key: 'watercolor', label: 'Watercolor' }
    ];
    
    let html = '';
    effects.forEach(effect => {
      const value = this.adjustments[effect.key];
      const enabled = this.effectsEnabled[effect.key];
      html += `
        <div class="panel-section">
          <h4>${effect.label} <span class="toggle ${enabled ? 'on' : ''}" data-effect="${effect.key}" onclick="editor.toggleEffect('${effect.key}')">OFF</span></h4>
          <div class="control-group">
            <label>Intensity <span id="${effect.key}-val">${value}</span></label>
            <input type="range" min="0" max="100" value="${value}" data-param="${effect.key}" />
          </div>
        </div>
      `;
    });
    return html;
  }
  
  getDistortControls() {
    const effects = [
      { key: 'ripple', label: 'Ripple' },
      { key: 'twirl', label: 'Twirl' },
      { key: 'wave', label: 'Wave' },
      { key: 'zigzag', label: 'Zigzag' },
      { key: 'glass', label: 'Glass' }
    ];
    
    let html = '';
    effects.forEach(effect => {
      const value = this.adjustments[effect.key];
      const enabled = this.effectsEnabled[effect.key];
      html += `
        <div class="panel-section">
          <h4>${effect.label} <span class="toggle ${enabled ? 'on' : ''}" data-effect="${effect.key}" onclick="editor.toggleEffect('${effect.key}')">OFF</span></h4>
          <div class="control-group">
            <label>Amount <span id="${effect.key}-val">${value}</span></label>
            <input type="range" min="0" max="100" value="${value}" data-param="${effect.key}" />
          </div>
        </div>
      `;
    });
    return html;
  }
  
  exportPNG() {
    if (!this.isImageLoaded) return;
    
    // Create a temporary canvas to export with current effects
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = this.canvas.width;
    tempCanvas.height = this.canvas.height;
    const tempCtx = tempCanvas.getContext('2d');
    
    // Copy current canvas content
    tempCtx.drawImage(this.canvas, 0, 0);
    
    // Create download link
    const link = document.createElement('a');
    link.download = 'bowesproduct-edited.png';
    link.href = tempCanvas.toDataURL('image/png');
    link.click();
  }
  
  applyEffects() {
    if (!this.isImageLoaded || !this.originalImage) return;
    
    // Clear and draw original image
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Build filter string
    let filters = '';
    
    // Basic adjustments
    if (this.effectsEnabled.brightness) {
      const brightness = 1 + (this.adjustments.brightness / 100);
      filters += ` brightness(${brightness})`;
    }
    
    if (this.effectsEnabled.contrast) {
      const contrast = 1 + (this.adjustments.contrast / 100);
      filters += ` contrast(${contrast})`;
    }
    
    if (this.effectsEnabled.exposure) {
      const exposure = 1 + (this.adjustments.exposure / 10);
      filters += ` brightness(${exposure})`;
    }
    
    // Color adjustments
    if (this.effectsEnabled.hsl) {
      filters += ` hue-rotate(${this.adjustments.hueRotate}deg)`;
      filters += ` saturate(${this.adjustments.saturation}%)`;
      filters += ` brightness(${100 + parseInt(this.adjustments.lightness)}%)`;
    }
    
    if (this.effectsEnabled.basicColor) {
      if (this.adjustments.invert) {
        filters += ` invert(100%)`;
      }
      if (this.adjustments.grayscale) {
        filters += ` grayscale(100%)`;
      }
      if (this.adjustments.sepia) {
        filters += ` sepia(100%)`;
      }
    }
    
    // Temperature (simulate with color overlay)
    if (this.effectsEnabled.temperature && (this.adjustments.temperature !== 0 || this.adjustments.tint !== 0)) {
      // Will be applied as overlay
    }
    
    // Blur
    if (this.effectsEnabled.blur && this.adjustments.blur > 0) {
      filters += ` blur(${this.adjustments.blur}px)`;
    }
    
    // Apply filter
    this.ctx.filter = filters || 'none';
    this.ctx.drawImage(this.originalImage, 0, 0, this.canvas.width, this.canvas.height);
    this.ctx.filter = 'none';
    
    // Apply temperature/tint overlay
    if (this.effectsEnabled.temperature && (this.adjustments.temperature !== 0 || this.adjustments.tint !== 0)) {
      const temp = this.adjustments.temperature;
      const tint = this.adjustments.tint;
      
      this.ctx.save();
      this.ctx.globalCompositeOperation = 'overlay';
      this.ctx.globalAlpha = Math.abs(temp + tint) / 200;
      
      if (temp > 0) {
        this.ctx.fillStyle = `rgba(255, 200, 150, 1)`;
      } else if (temp < 0) {
        this.ctx.fillStyle = `rgba(150, 180, 255, 1)`;
      }
      
      if (tint > 0) {
        this.ctx.fillStyle = `rgba(200, 255, 200, 1)`;
      } else if (tint < 0) {
        this.ctx.fillStyle = `rgba(255, 200, 200, 1)`;
      }
      
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      this.ctx.restore();
    }
    
    // Apply drop shadow
    if (this.effectsEnabled.dropShadow) {
      const shadow = this.adjustments.dropShadow;
      this.ctx.save();
      this.ctx.globalCompositeOperation = 'multiply';
      this.ctx.globalAlpha = shadow.opacity / 100;
      this.ctx.filter = `blur(${shadow.blur}px)`;
      this.ctx.fillStyle = shadow.color;
      this.ctx.fillRect(shadow.x, shadow.y, this.canvas.width, this.canvas.height);
      this.ctx.restore();
    }
    
    // Apply inner glow
    if (this.effectsEnabled.innerGlow) {
      const glow = this.adjustments.innerGlow;
      this.ctx.save();
      this.ctx.globalCompositeOperation = 'source-atop';
      this.ctx.strokeStyle = glow.color;
      this.ctx.lineWidth = glow.blur * 2;
      this.ctx.globalAlpha = glow.opacity / 100;
      this.ctx.strokeRect(0, 0, this.canvas.width, this.canvas.height);
      this.ctx.restore();
    }
    
    // Apply outer glow
    if (this.effectsEnabled.outerGlow) {
      const glow = this.adjustments.outerGlow;
      this.ctx.save();
      this.ctx.globalCompositeOperation = 'screen';
      this.ctx.strokeStyle = glow.color;
      this.ctx.lineWidth = glow.blur * 2;
      this.ctx.globalAlpha = glow.opacity / 100;
      this.ctx.strokeRect(0, 0, this.canvas.width, this.canvas.height);
      this.ctx.restore();
    }
    
    // Apply vignette
    if (this.effectsEnabled.vignette && this.adjustments.vignette > 0) {
      const strength = this.adjustments.vignette / 100;
      const gradient = this.ctx.createRadialGradient(
        this.canvas.width / 2, this.canvas.height / 2, 0,
        this.canvas.width / 2, this.canvas.height / 2, Math.max(this.canvas.width, this.canvas.height) * 0.7
      );
      gradient.addColorStop(0, 'rgba(0,0,0,0)');
      gradient.addColorStop(1, `rgba(0,0,0,${strength})`);
      
      this.ctx.save();
      this.ctx.globalCompositeOperation = 'multiply';
      this.ctx.fillStyle = gradient;
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      this.ctx.restore();
    }
    
    // Apply film grain
    if (this.effectsEnabled.filmGrain && this.adjustments.filmGrain > 0) {
      const intensity = this.adjustments.filmGrain / 100;
      const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      const data = imageData.data;
      
      for (let i = 0; i < data.length; i += 4) {
        const noise = (Math.random() - 0.5) * intensity * 255;
        data[i] += noise;
        data[i + 1] += noise;
        data[i + 2] += noise;
      }
      
      this.ctx.putImageData(imageData, 0, 0);
    }
    
    // Apply sharpen
    if (this.effectsEnabled.sharpen && this.adjustments.sharpen > 0) {
      this.applyConvolution([
        0, -1, 0,
        -1, 5, -1,
        0, -1, 0
      ], this.adjustments.sharpen / 100);
    }
    
    // Apply artistic effects (simplified versions)
    this.applyArtisticEffects();
    
    // Apply distort effects
    this.applyDistortEffects();
    
    // Save state after applying effects
    // Don't call saveState() here to avoid infinite loop
  }
  
  applyConvolution(kernel, strength = 1) {
    if (!this.isImageLoaded) return;
    
    const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
    const data = imageData.data;
    const width = this.canvas.width;
    const height = this.canvas.height;
    const output = this.ctx.createImageData(width, height);
    const outputData = output.data;
    
    const side = Math.round(Math.sqrt(kernel.length));
    const halfSide = Math.floor(side / 2);
    
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let r = 0, g = 0, b = 0;
        
        for (let cy = 0; cy < side; cy++) {
          for (let cx = 0; cx < side; cx++) {
            const scy = y + cy - halfSide;
            const scx = x + cx - halfSide;
            
            if (scy >= 0 && scy < height && scx >= 0 && scx < width) {
              const srcOffset = (scy * width + scx) * 4;
              const wt = kernel[cy * side + cx];
              
              r += data[srcOffset] * wt;
              g += data[srcOffset + 1] * wt;
              b += data[srcOffset + 2] * wt;
            }
          }
        }
        
        const offset = (y * width + x) * 4;
        const originalR = data[offset];
        const originalG = data[offset + 1];
        const originalB = data[offset + 2];
        
        outputData[offset] = originalR + (r - originalR) * strength;
        outputData[offset + 1] = originalG + (g - originalG) * strength;
        outputData[offset + 2] = originalB + (b - originalB) * strength;
        outputData[offset + 3] = data[offset + 3];
      }
    }
    
    this.ctx.putImageData(output, 0, 0);
  }
  
  applyArtisticEffects() {
    // Colored Pencil
    if (this.effectsEnabled.coloredPencil && this.adjustments.coloredPencil > 0) {
      const intensity = this.adjustments.coloredPencil / 100;
      const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      const data = imageData.data;
      
      for (let i = 0; i < data.length; i += 4) {
        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
        data[i] = data[i] + (avg - data[i]) * intensity * 0.5;
        data[i + 1] = data[i + 1] + (avg - data[i + 1]) * intensity * 0.5;
        data[i + 2] = data[i + 2] + (avg - data[i + 2]) * intensity * 0.5;
      }
      
      this.ctx.putImageData(imageData, 0, 0);
    }
    
    // Poster Edges
    if (this.effectsEnabled.posterEdges && this.adjustments.posterEdges > 0) {
      const intensity = this.adjustments.posterEdges / 100;
      const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      const data = imageData.data;
      const width = this.canvas.width;
      const height = this.canvas.height;
      
      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          const offset = (y * width + x) * 4;
          const rightOffset = (y * width + x + 1) * 4;
          const bottomOffset = ((y + 1) * width + x) * 4;
          
          const edgeX = Math.abs(data[offset] - data[rightOffset]) +
                       Math.abs(data[offset + 1] - data[rightOffset + 1]) +
                       Math.abs(data[offset + 2] - data[rightOffset + 2]);
          
          const edgeY = Math.abs(data[offset] - data[bottomOffset]) +
                       Math.abs(data[offset + 1] - data[bottomOffset + 1]) +
                       Math.abs(data[offset + 2] - data[bottomOffset + 2]);
          
          const edge = (edgeX + edgeY) / 6 * intensity;
          
          if (edge > 30) {
            data[offset] = 0;
            data[offset + 1] = 0;
            data[offset + 2] = 0;
          }
        }
      }
      
      this.ctx.putImageData(imageData, 0, 0);
    }
    
    // Watercolor
    if (this.effectsEnabled.watercolor && this.adjustments.watercolor > 0) {
      const intensity = this.adjustments.watercolor / 100;
      this.applyConvolution([
        1/9, 1/9, 1/9,
        1/9, 1/9, 1/9,
        1/9, 1/9, 1/9
      ], intensity);
    }
    
    // Neon Glow
    if (this.effectsEnabled.neonGlow && this.adjustments.neonGlow > 0) {
      const intensity = this.adjustments.neonGlow / 100;
      this.ctx.save();
      this.ctx.globalCompositeOperation = 'screen';
      this.ctx.globalAlpha = intensity;
      this.ctx.filter = `blur(${10 + intensity * 20}px)`;
      this.ctx.drawImage(this.canvas, 0, 0);
      this.ctx.restore();
    }
    
    // Cutout (posterization)
    if (this.effectsEnabled.cutout && this.adjustments.cutout > 0) {
      const intensity = this.adjustments.cutout / 100;
      const levels = Math.max(2, Math.round(8 - intensity * 6));
      const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      const data = imageData.data;
      
      for (let i = 0; i < data.length; i += 4) {
        data[i] = Math.round(data[i] / (256 / levels)) * (256 / levels);
        data[i + 1] = Math.round(data[i + 1] / (256 / levels)) * (256 / levels);
        data[i + 2] = Math.round(data[i + 2] / (256 / levels)) * (256 / levels);
      }
      
      this.ctx.putImageData(imageData, 0, 0);
    }
    
    // Film Grain
    if (this.effectsEnabled.filmGrain && this.adjustments.filmGrain > 0) {
      const intensity = this.adjustments.filmGrain / 100;
      const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      const data = imageData.data;
      
      for (let i = 0; i < data.length; i += 4) {
        const noise = (Math.random() - 0.5) * intensity * 100;
        data[i] = Math.max(0, Math.min(255, data[i] + noise));
        data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));
        data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise));
      }
      
      this.ctx.putImageData(imageData, 0, 0);
    }
    
    // Paint Daubs
    if (this.effectsEnabled.paintDaubs && this.adjustments.paintDaubs > 0) {
      const intensity = this.adjustments.paintDaubs / 100;
      const radius = Math.round(2 + intensity * 8);
      this.applyConvolution(
        Array(radius * radius).fill(1 / (radius * radius)),
        intensity
      );
    }
    
    // Dry Brush
    if (this.effectsEnabled.dryBrush && this.adjustments.dryBrush > 0) {
      const intensity = this.adjustments.dryBrush / 100;
      const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      const data = imageData.data;
      const factor = 1 - intensity * 0.5;
      
      for (let i = 0; i < data.length; i += 4) {
        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
        data[i] = data[i] * factor + avg * (1 - factor);
        data[i + 1] = data[i + 1] * factor + avg * (1 - factor);
        data[i + 2] = data[i + 2] * factor + avg * (1 - factor);
      }
      
      this.ctx.putImageData(imageData, 0, 0);
    }
    
    // Fresco
    if (this.effectsEnabled.fresco && this.adjustments.fresco > 0) {
      const intensity = this.adjustments.fresco / 100;
      const levels = Math.max(4, Math.round(12 - intensity * 8));
      const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      const data = imageData.data;
      
      for (let i = 0; i < data.length; i += 4) {
        data[i] = Math.round(data[i] / (256 / levels)) * (256 / levels);
        data[i + 1] = Math.round(data[i + 1] / (256 / levels)) * (256 / levels);
        data[i + 2] = Math.round(data[i + 2] / (256 / levels)) * (256 / levels);
      }
      
      this.ctx.putImageData(imageData, 0, 0);
      
      if (intensity > 0.3) {
        this.applyConvolution([
          0.1, 0.1, 0.1,
          0.1, 0.2, 0.1,
          0.1, 0.1, 0.1
        ], intensity * 0.5);
      }
    }
  }
  
  applyDistortEffects() {
    // Ripple
    if (this.effectsEnabled.ripple && this.adjustments.ripple > 0) {
      const amount = this.adjustments.ripple;
      const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      const output = this.ctx.createImageData(this.canvas.width, this.canvas.height);
      
      for (let y = 0; y < this.canvas.height; y++) {
        for (let x = 0; x < this.canvas.width; x++) {
          const dx = x - this.canvas.width / 2;
          const dy = y - this.canvas.height / 2;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx);
          
          const offset = Math.sin(distance / 20) * amount;
          const newX = Math.round(this.canvas.width / 2 + Math.cos(angle + offset) * distance);
          const newY = Math.round(this.canvas.height / 2 + Math.sin(angle + offset) * distance);
          
          const srcOffset = (y * this.canvas.width + x) * 4;
          const dstOffset = (Math.min(this.canvas.height - 1, Math.max(0, newY)) * this.canvas.width + Math.min(this.canvas.width - 1, Math.max(0, newX))) * 4;
          
          if (newX >= 0 && newX < this.canvas.width && newY >= 0 && newY < this.canvas.height) {
            output.data[srcOffset] = imageData.data[dstOffset];
            output.data[srcOffset + 1] = imageData.data[dstOffset + 1];
            output.data[srcOffset + 2] = imageData.data[dstOffset + 2];
            output.data[srcOffset + 3] = imageData.data[dstOffset + 3];
          }
        }
      }
      
      this.ctx.putImageData(output, 0, 0);
    }
    
    // Wave
    if (this.effectsEnabled.wave && this.adjustments.wave > 0) {
      const amount = this.adjustments.wave / 10;
      const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      const output = this.ctx.createImageData(this.canvas.width, this.canvas.height);
      
      for (let y = 0; y < this.canvas.height; y++) {
        for (let x = 0; x < this.canvas.width; x++) {
          const offsetX = Math.round(Math.sin(y / 20) * amount);
          const newY = y;
          const newX = Math.min(this.canvas.width - 1, Math.max(0, x + offsetX));
          
          const srcOffset = (y * this.canvas.width + x) * 4;
          const dstOffset = (newY * this.canvas.width + newX) * 4;
          
          output.data[srcOffset] = imageData.data[dstOffset];
          output.data[srcOffset + 1] = imageData.data[dstOffset + 1];
          output.data[srcOffset + 2] = imageData.data[dstOffset + 2];
          output.data[srcOffset + 3] = imageData.data[dstOffset + 3];
        }
      }
      
      this.ctx.putImageData(output, 0, 0);
    }
    
    // Twirl
    if (this.effectsEnabled.twirl && this.adjustments.twirl > 0) {
      const amount = this.adjustments.twirl / 1000;
      const maxRadius = Math.min(this.canvas.width, this.canvas.height) / 3;
      const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      const output = this.ctx.createImageData(this.canvas.width, this.canvas.height);
      
      for (let y = 0; y < this.canvas.height; y++) {
        for (let x = 0; x < this.canvas.width; x++) {
          const dx = x - this.canvas.width / 2;
          const dy = y - this.canvas.height / 2;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          let newX = x;
          let newY = y;
          
          if (distance < maxRadius) {
            const angle = Math.atan2(dy, dx);
            const twistAngle = angle + amount * (maxRadius - distance);
            newX = Math.round(this.canvas.width / 2 + Math.cos(twistAngle) * distance);
            newY = Math.round(this.canvas.height / 2 + Math.sin(twistAngle) * distance);
          }
          
          const srcOffset = (y * this.canvas.width + x) * 4;
          const dstOffset = (Math.min(this.canvas.height - 1, Math.max(0, newY)) * this.canvas.width + Math.min(this.canvas.width - 1, Math.max(0, newX))) * 4;
          
          output.data[srcOffset] = imageData.data[dstOffset];
          output.data[srcOffset + 1] = imageData.data[dstOffset + 1];
          output.data[srcOffset + 2] = imageData.data[dstOffset + 2];
          output.data[srcOffset + 3] = imageData.data[dstOffset + 3];
        }
      }
      
      this.ctx.putImageData(output, 0, 0);
    }
    
    // Zigzag
    if (this.effectsEnabled.zigzag && this.adjustments.zigzag > 0) {
      const amount = this.adjustments.zigzag / 5;
      const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      const output = this.ctx.createImageData(this.canvas.width, this.canvas.height);
      
      for (let y = 0; y < this.canvas.height; y++) {
        for (let x = 0; x < this.canvas.width; x++) {
          const dx = x - this.canvas.width / 2;
          const dy = y - this.canvas.height / 2;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx);
          
          const radiusMod = Math.sin(distance / 15) * amount;
          const newX = Math.round(this.canvas.width / 2 + Math.cos(angle) * (distance + radiusMod));
          const newY = Math.round(this.canvas.height / 2 + Math.sin(angle) * (distance + radiusMod));
          
          const srcOffset = (y * this.canvas.width + x) * 4;
          const dstOffset = (Math.min(this.canvas.height - 1, Math.max(0, newY)) * this.canvas.width + Math.min(this.canvas.width - 1, Math.max(0, newX))) * 4;
          
          output.data[srcOffset] = imageData.data[dstOffset];
          output.data[srcOffset + 1] = imageData.data[dstOffset + 1];
          output.data[srcOffset + 2] = imageData.data[dstOffset + 2];
          output.data[srcOffset + 3] = imageData.data[dstOffset + 3];
        }
      }
      
      this.ctx.putImageData(output, 0, 0);
    }
    
    // Glass
    if (this.effectsEnabled.glass && this.adjustments.glass > 0) {
      const amount = Math.round(this.adjustments.glass / 5);
      const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      const output = this.ctx.createImageData(this.canvas.width, this.canvas.height);
      
      for (let y = 0; y < this.canvas.height; y++) {
        for (let x = 0; x < this.canvas.width; x++) {
          const offsetX = Math.floor(Math.random() * amount * 2) - amount;
          const offsetY = Math.floor(Math.random() * amount * 2) - amount;
          
          const newX = Math.min(this.canvas.width - 1, Math.max(0, x + offsetX));
          const newY = Math.min(this.canvas.height - 1, Math.max(0, y + offsetY));
          
          const srcOffset = (y * this.canvas.width + x) * 4;
          const dstOffset = (newY * this.canvas.width + newX) * 4;
          
          output.data[srcOffset] = imageData.data[dstOffset];
          output.data[srcOffset + 1] = imageData.data[dstOffset + 1];
          output.data[srcOffset + 2] = imageData.data[dstOffset + 2];
          output.data[srcOffset + 3] = imageData.data[dstOffset + 3];
        }
      }
      
      this.ctx.putImageData(output, 0, 0);
    }
  }
}

// Instantiate editor when DOM is ready
let editor;
document.addEventListener('DOMContentLoaded', () => {
  editor = new ImageEditor();
});
</script>

</body>
</html>
